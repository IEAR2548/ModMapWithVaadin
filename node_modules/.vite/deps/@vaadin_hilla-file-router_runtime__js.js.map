{
  "version": 3,
  "sources": ["file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/createRoute.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/react-auth/src/ProtectedRoute.tsx", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/react-auth/src/useAuth.tsx", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/react-auth/src/index.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/RouterConfigurationBuilder.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/shared/convertComponentNameToTitle.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/shared/transformTree.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/useViewConfig.ts", "../../@vaadin/hilla-react-signals/src/polyfills.ts", "../../nanoid/url-alphabet/index.js", "../../nanoid/index.browser.js", "../../@vaadin/hilla-react-signals/src/events.ts", "../../@vaadin/hilla-react-signals/src/FullStackSignal.ts", "../../@vaadin/hilla-react-signals/src/ValueSignal.ts", "../../@vaadin/hilla-react-signals/src/NumberSignal.ts", "../../@vaadin/hilla-react-signals/src/CollectionSignal.ts", "../../@vaadin/hilla-react-signals/src/ListSignal.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/createMenuItems.ts"],
  "sourcesContent": ["import type { AgnosticRoute, Module, ViewConfig } from '../types.js';\n\n/**\n * Extends a router module's config with additional properties. The original\n * module config is preferred over the extension.\n *\n * @param module - The module to extend.\n * @param config - The extension config.\n * @returns\n */\nexport function extendModule(module: Module | null, config?: ViewConfig): Module {\n  return {\n    ...module,\n    config: {\n      ...config,\n      ...(module?.config as ViewConfig),\n    },\n  };\n}\n\n/**\n * Create a single framework-agnostic route object. Later, it can be transformed into a framework-specific route object,\n * e.g., the one used by React Router.\n *\n * @param path - A route path segment.\n * @param children - An array of child routes.\n *\n * @returns A framework-agnostic route object.\n */\nexport function createRoute(path: string, children?: readonly AgnosticRoute[]): AgnosticRoute;\nexport function createRoute(path: string, module: Module, children?: readonly AgnosticRoute[]): AgnosticRoute;\nexport function createRoute(\n  path: string,\n  moduleOrChildren?: Module | readonly AgnosticRoute[],\n  children?: readonly AgnosticRoute[],\n): AgnosticRoute {\n  let module: Module | undefined;\n  if (Array.isArray(moduleOrChildren)) {\n    // eslint-disable-next-line no-param-reassign\n    children = moduleOrChildren;\n  } else {\n    module = moduleOrChildren as Module | undefined;\n  }\n\n  return {\n    path,\n    module,\n    children,\n  };\n}\n", "import { useContext, type JSX } from 'react';\nimport type { RouteObject } from 'react-router';\nimport { type IndexRouteObject, Navigate, type NonIndexRouteObject, useLocation } from 'react-router';\nimport { type AccessProps, AuthContext } from './useAuth.js';\n\ntype CustomMetadata = Record<string, any>;\n\ntype HandleWithAuth = Readonly<{ handle?: AccessProps & CustomMetadata }>;\n\ntype Override<T, E> = E & Omit<T, keyof E>;\n\ntype IndexRouteObjectWithAuth = Override<IndexRouteObject, HandleWithAuth>;\ntype NonIndexRouteObjectWithAuth = Override<\n  Override<NonIndexRouteObject, HandleWithAuth>,\n  {\n    children?: RouteObjectWithAuth[];\n  }\n>;\nexport type RouteObjectWithAuth = IndexRouteObjectWithAuth | NonIndexRouteObjectWithAuth;\n\ninterface ProtectedRouteProps {\n  redirectPath: string;\n  access: AccessProps;\n  element: JSX.Element;\n}\n\nfunction ProtectedRoute({ redirectPath, access, element }: ProtectedRouteProps): JSX.Element | null {\n  const {\n    state: { initializing, loading },\n    hasAccess,\n  } = useContext(AuthContext);\n\n  const location = useLocation();\n\n  if (initializing || loading) {\n    return <div></div>;\n  }\n\n  if (!hasAccess(access)) {\n    return <Navigate to={redirectPath} state={{ from: location }} replace />;\n  }\n\n  return element;\n}\n\nProtectedRoute.type = 'ProtectedRoute'; // This is for copilot to recognize this\n\nfunction* traverse<T extends RouteObject>(routes: T[]): Generator<T, undefined, undefined> {\n  for (const route of routes) {\n    yield route;\n    if (route.children) {\n      yield* traverse(route.children as T[]);\n    }\n  }\n}\n\n/**\n * Adds protection to a single route that requires authentication.\n * These route should contain the {@link AccessProps.loginRequired} and/or\n * {@link AccessProps.rolesAllowed} property to get the protection. Route\n * without that property won't be protected.\n *\n * @param route - the route to protect\n * @param redirectPath - the path to redirect to if the route is protected\n * and the user is not authenticated.\n * @returns the route extended with protection if needed\n */\nexport function protectRoute(route: RouteObjectWithAuth, redirectPath: string = '/login'): RouteObjectWithAuth {\n  const { handle } = route;\n  const requiresAuth = handle?.loginRequired ?? handle?.requiresLogin ?? handle?.rolesAllowed?.length;\n\n  if (requiresAuth) {\n    route.element = (\n      <ProtectedRoute\n        redirectPath={redirectPath}\n        access={handle as AccessProps}\n        element={route.element as JSX.Element}\n      />\n    );\n  }\n\n  return route;\n}\n\n/**\n * Protects a route tree with {@link protectRoute} function.\n *\n * @param routes - the roots of the route tree that requires protection.\n * @param redirectPath - the path to redirect to if the route is\n * protected and the user is not authenticated.\n * @returns the protected route tree\n */\nexport function protectRoutes(routes: RouteObjectWithAuth[], redirectPath: string = '/login'): RouteObjectWithAuth[] {\n  for (const route of traverse(routes)) {\n    protectRoute(route, redirectPath);\n  }\n\n  return routes;\n}\n", "import {\n  login as _login,\n  type LoginOptions,\n  type LoginResult,\n  logout as _logout,\n  type LogoutOptions,\n  UnauthorizedResponseError,\n} from '@vaadin/hilla-frontend';\nimport { type Context, createContext, type Dispatch, useContext, useEffect, useReducer } from 'react';\n\ntype LoginFunction = (username: string, password: string, options?: LoginOptions) => Promise<LoginResult>;\ntype LogoutFunction = () => Promise<void>;\n\nconst LOGIN_FETCH = 'LOGIN_FETCH';\nconst LOGIN_SUCCESS = 'LOGIN_SUCCESS';\nconst LOGIN_FAILURE = 'LOGIN_FAILURE';\nconst LOGOUT = 'LOGOUT';\n\n/**\n * The type of the function that is used to get the authenticated user.\n */\nexport type GetUserFn<TUser> = () => Promise<TUser | undefined>;\n\ntype AuthState<TUser> = Readonly<{\n  initializing: boolean;\n  loading: boolean;\n  user?: TUser;\n  error?: string;\n  getAuthenticatedUser?: GetUserFn<TUser>;\n}>;\n\ntype LoginFetchAction = Readonly<{\n  type: typeof LOGIN_FETCH;\n}>;\n\ntype LoginSuccessAction = Readonly<{\n  user: unknown;\n  type: typeof LOGIN_SUCCESS;\n}>;\n\ntype LoginFailureAction = Readonly<{\n  error: string;\n  type: typeof LOGIN_FAILURE;\n}>;\n\ntype LoginActions = LoginFailureAction | LoginFetchAction | LoginSuccessAction;\n\ntype LogoutAction = Readonly<{\n  type: typeof LOGOUT;\n}>;\n\nfunction createAuthenticateThunk<TUser>(dispatch: Dispatch<LoginActions>, getAuthenticatedUser: GetUserFn<TUser>) {\n  async function authenticate() {\n    dispatch({ type: LOGIN_FETCH });\n\n    // Get user info from endpoint\n    const user = await getAuthenticatedUser().catch((error: unknown) => {\n      if (error instanceof UnauthorizedResponseError) {\n        // 401 response: the user is not authenticated\n        return undefined;\n      }\n\n      throw error;\n    });\n\n    if (user) {\n      dispatch({\n        user,\n        type: LOGIN_SUCCESS,\n      });\n    } else {\n      dispatch({\n        error: 'Not authenticated',\n        type: LOGIN_FAILURE,\n      });\n    }\n  }\n\n  return authenticate;\n}\n\nfunction createUnauthenticateThunk(dispatch: Dispatch<LogoutAction>) {\n  return () => {\n    dispatch({ type: LOGOUT });\n  };\n}\n\nconst initialState: AuthState<unknown> = {\n  initializing: true,\n  loading: false,\n};\n\nfunction reducer(state: AuthState<unknown>, action: LoginActions | LogoutAction) {\n  switch (action.type) {\n    case LOGIN_FETCH:\n      return {\n        initializing: false,\n        loading: true,\n      };\n    case LOGIN_SUCCESS:\n      return {\n        initializing: false,\n        loading: false,\n        user: action.user,\n      };\n    case LOGIN_FAILURE:\n      return {\n        initializing: false,\n        loading: false,\n        error: action.error,\n      };\n    case LOGOUT:\n      return { initializing: false, loading: false };\n    default:\n      return state;\n  }\n}\n\n/**\n * The properties that can be used to control access to a route.\n * They can be added to the route type handler as properties.\n */\nexport type AccessProps = Readonly<{\n  /**\n   * If true, the user must be logged in to access the route.\n   */\n  loginRequired?: boolean;\n  /**\n   * If true, the user must be logged in to access the route.\n   *\n   * @deprecated Use `loginRequired` instead.\n   */\n  requiresLogin?: boolean;\n  /**\n   * The list of roles that are allowed to access the route.\n   */\n  rolesAllowed?: readonly [string, ...string[]];\n}>;\n\n/**\n * The type of the authentication hook.\n */\nexport type Authentication<TUser> = Readonly<{\n  state: AuthState<TUser>;\n  login: LoginFunction;\n  logout: LogoutFunction;\n  hasAccess(accessProps: AccessProps): boolean;\n}>;\n\n/**\n * The hook that can be used to get the authentication state.\n * It returns the state of the authentication.\n */\nexport const AuthContext: Context<Authentication<unknown>> = createContext<Authentication<unknown>>({\n  state: initialState,\n  login() {\n    throw new Error('AuthContext not initialized');\n  },\n  logout() {\n    throw new Error('AuthContext not initialized');\n  },\n  hasAccess(): boolean {\n    throw new Error('AuthContext not initialized');\n  },\n});\n\ninterface AuthConfig<TUser> {\n  getRoles?(user: TUser): readonly string[];\n}\n\ninterface AuthProviderProps<TUser> extends React.PropsWithChildren {\n  getAuthenticatedUser: GetUserFn<TUser>;\n  config?: AuthConfig<TUser>;\n}\n\ninterface UserWithRoles {\n  roles?: any;\n}\n\nconst getDefaultRoles = (user: unknown) => {\n  const userWithRoles = user as UserWithRoles;\n  return Array.isArray(userWithRoles.roles) ? userWithRoles.roles : [];\n};\n\nfunction AuthProvider<TUser>({ children, getAuthenticatedUser, config }: AuthProviderProps<TUser>) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const authenticate = createAuthenticateThunk(dispatch, getAuthenticatedUser);\n  const unauthenticate = createUnauthenticateThunk(dispatch);\n\n  async function login(username: string, password: string, options?: LoginOptions): Promise<LoginResult> {\n    const result = await _login(username, password, options);\n\n    if (!result.error) {\n      await authenticate();\n    }\n\n    return result;\n  }\n\n  async function logout(options?: LogoutOptions): Promise<void> {\n    await _logout(options);\n    unauthenticate();\n  }\n\n  function hasAccess({ loginRequired, requiresLogin, rolesAllowed }: AccessProps): boolean {\n    const requiresAuth = loginRequired ?? requiresLogin ?? rolesAllowed;\n    if (!requiresAuth) {\n      return true;\n    }\n\n    if (!state.user) {\n      return false;\n    }\n\n    if (rolesAllowed) {\n      const userRoles = config?.getRoles ? config.getRoles(state.user as TUser) : getDefaultRoles(state.user);\n      return rolesAllowed.some((allowedRole) => userRoles.includes(allowedRole));\n    }\n\n    return true;\n  }\n\n  useEffect(() => {\n    authenticate().catch(() => {\n      // Do nothing\n    });\n  }, []);\n\n  const auth = {\n    state,\n    login,\n    logout,\n    hasAccess,\n  };\n\n  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;\n}\n\nexport type AuthHook<TUser> = () => Authentication<TUser>;\n\n/**\n * The hook that can be used to authenticate the user.\n * It returns the state of the authentication and the functions\n * to authenticate and unauthenticate the user.\n */\nfunction useAuth<TUser>(): Authentication<TUser> {\n  return useContext(AuthContext) as Authentication<TUser>;\n}\n\ninterface AuthModule<TUser> {\n  AuthProvider: React.FC<React.PropsWithChildren>;\n  useAuth: AuthHook<TUser>;\n}\n\nexport function configureAuth<TUser>(\n  getAuthenticatedUser: GetUserFn<TUser>,\n  config?: AuthConfig<TUser>,\n): AuthModule<TUser> {\n  function PreconfiguredAuthProvider({ children }: React.PropsWithChildren) {\n    return (\n      <AuthProvider<TUser> getAuthenticatedUser={getAuthenticatedUser} config={config}>\n        {children}\n      </AuthProvider>\n    );\n  }\n\n  return {\n    AuthProvider: PreconfiguredAuthProvider,\n    useAuth: useAuth as AuthHook<TUser>,\n  };\n}\n", "export * from './ProtectedRoute.js';\nexport * from './useAuth.js';\n\n// @ts-expect-error: esbuild injection\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call\n((feature, vaadinObj = (window.Vaadin ??= {})) => {\n  vaadinObj.registrations ??= [];\n  vaadinObj.registrations.push({\n    is: feature ? `@vaadin/hilla-react-auth/${feature}` : '@vaadin/hilla-react-auth',\n    version: '24.7.2',\n  });\n})();\n", "/* eslint-disable @typescript-eslint/consistent-type-assertions */\nimport { protectRoute } from '@vaadin/hilla-react-auth';\nimport { type ComponentType, createElement } from 'react';\nimport { createBrowserRouter, type IndexRouteObject, type NonIndexRouteObject, type RouteObject } from 'react-router';\nimport { convertComponentNameToTitle } from '../shared/convertComponentNameToTitle.js';\nimport { transformTree } from '../shared/transformTree.js';\nimport type {\n  AgnosticRoute,\n  Module,\n  RouteModule,\n  RouterBuildOptions,\n  RouterConfiguration,\n  ViewConfig,\n} from '../types.js';\n\ninterface RouteBase {\n  path?: string;\n  children?: readonly this[];\n}\n\nfunction isReactRouteModule(module: Module): module is RouteModule<ComponentType> {\n  return (\n    ('default' in module && typeof module.default === 'function') ||\n    ('config' in module && typeof module.config === 'object')\n  );\n}\n\nexport type RouteList = readonly RouteObject[];\nexport type WritableRouteList = RouteObject[];\n\nexport type RouteTransformerOptions<T> = Readonly<{\n  children?: RouteList;\n  original?: RouteObject;\n  overriding?: T;\n  dupe: boolean;\n}>;\n\nexport type RouteTransformer<T> = (opts: RouteTransformerOptions<T>) => RouteObject | undefined;\n\ntype RoutesModifier = (routes: RouteList | undefined) => RouteList | undefined;\n\nfunction createRouteKey<T extends RouteBase>(route: T): string {\n  return `${route.path ?? ''}-${route.children ? 'n' : 'i'}`;\n}\n\nenum RouteHandleFlags {\n  FLOW_LAYOUT = 'flowLayout',\n  IGNORE_FALLBACK = 'ignoreFallback',\n  SKIP_LAYOUTS = 'skipLayouts',\n}\n\nfunction getRouteHandleFlag<T extends RouteHandleFlags>(route: RouteObject, flag: T): boolean | undefined {\n  if (typeof route.handle === 'object' && flag in route.handle) {\n    return (route.handle as Record<T, boolean>)[flag];\n  }\n\n  return undefined;\n}\n\n/**\n * A builder for creating a Vaadin-specific router for React with\n * authentication and server routes support.\n */\nexport class RouterConfigurationBuilder {\n  readonly #modifiers: RoutesModifier[] = [];\n\n  /**\n   * Adds the given routes to the current list of routes. All the routes are\n   * deeply merged to preserve the path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withReactRoutes(routes: RouteList): this {\n    return this.update(routes);\n  }\n\n  /**\n   * Adds the given file routes to the current list of routes. All the routes\n   * are transformed to React RouterObjects and deeply merged to preserve the\n   * path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withFileRoutes(routes: readonly AgnosticRoute[]): this {\n    return this.update(routes, ({ original, overriding: added, children }) => {\n      if (added) {\n        const { module, path, flowLayout } = added;\n        if (module && !isReactRouteModule(module)) {\n          throw new Error(\n            `The module for the \"${path}\" section doesn't have the React component exported by default or a ViewConfig object exported as \"config\"`,\n          );\n        }\n\n        const element = module?.default ? createElement(module.default) : undefined;\n        const handle = {\n          ...module?.config,\n          title: module?.config?.title ?? convertComponentNameToTitle(module?.default),\n          flowLayout: module?.config?.flowLayout ?? flowLayout,\n        };\n\n        if (path === '' && !children) {\n          return {\n            ...original,\n            element,\n            handle,\n            index: true,\n          } as IndexRouteObject;\n        }\n\n        return {\n          ...original,\n          path: module?.config?.route ?? path,\n          element,\n          children,\n          handle,\n        } as NonIndexRouteObject;\n      }\n\n      return original;\n    });\n  }\n\n  /**\n   * Adds the given server route element to each branch of the current list of\n   * routes.\n   *\n   * @param component - The React component to add to each branch of the\n   * current list of routes.\n   * @param config - An optional configuration that will be applied to\n   * each fallback component.\n   */\n  withFallback(component: ComponentType, config?: ViewConfig): this {\n    this.withLayout(component);\n\n    // Fallback adds two routes, so that the index (empty path) has a fallback too\n    const fallbackRoutes: RouteList = [\n      { path: '*', element: createElement(component), handle: config },\n      { index: true, element: createElement(component), handle: config },\n    ];\n\n    this.update(fallbackRoutes, ({ original, overriding: added, children, dupe }) => {\n      if (original && !getRouteHandleFlag(original, RouteHandleFlags.IGNORE_FALLBACK) && !dupe) {\n        if (!children) {\n          return original;\n        }\n\n        const _fallback = [...fallbackRoutes];\n\n        if (children.some(({ path }) => path === '*')) {\n          _fallback.shift();\n        }\n\n        if (children.some(({ index: i, path }) => i ?? path?.includes('?'))) {\n          _fallback.pop();\n        }\n\n        return {\n          ...original,\n          children: [...children, ..._fallback],\n        } as RouteObject;\n      }\n\n      return added!;\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the layoutComponent as the parent layout to views with the flowLayouts ViewConfiguration set.\n   *\n   * @param layoutComponent - layout component to use, usually Flow\n   */\n  withLayout(layoutComponent: ComponentType): this {\n    this.#modifiers.push((originalRoutes) => {\n      if (!originalRoutes) {\n        return originalRoutes;\n      }\n\n      type Accumulator<T extends RouteList> = Readonly<{\n        server: T;\n        client: T;\n        ambivalent: T;\n      }>;\n\n      const result = transformTree<RouteList, Accumulator<RouteList>>(originalRoutes, null, (routes, next) =>\n        // Split a single routes list onto three separate lists:\n        // - A list of server routes\n        // - A list of client routes\n        // - A list of routes which will be moved to either server or client\n        // list. It depends on the parent route.\n        routes.reduce<Accumulator<WritableRouteList>>(\n          (lists, route) => {\n            const { server, client, ambivalent } = next(route.children ?? []);\n\n            const flag = getRouteHandleFlag(route, RouteHandleFlags.FLOW_LAYOUT);\n\n            // If the route has `flowLayout` flag explicitly enabled, it goes to\n            // the server list. The children are also affected by the flag\n            // unless they have it explicitly disabled.\n            if (flag === true) {\n              lists.server.push({\n                ...route,\n                children: route.children ? [...server, ...ambivalent] : undefined,\n              } as RouteObject);\n            } else if (server.length > 0) {\n              // Even if the route doesn't have the flag, it goes to the server\n              // list if any of the children has the flag enabled.\n              lists.server.push({\n                ...route,\n                children: route.children ? server : undefined,\n              } as RouteObject);\n            }\n\n            // If the route has `flowLayout` flag explicitly disabled, it goes\n            // to the client list. The route children are not affected by the\n            // flag.\n            if (flag === false || client.length > 0) {\n              lists.client.push({\n                ...route,\n                children: route.children ? client : undefined,\n              } as RouteObject);\n            }\n\n            // The route without the flag go to the `default` list. Then it will\n            // be moved to either server or client list based on the parent\n            // route.\n            if (\n              flag === undefined &&\n              (lists.server.every(({ path }) => path !== route.path) || ambivalent.length > 0)\n            ) {\n              lists.ambivalent.push({\n                ...route,\n                children: route.children ? ambivalent : undefined,\n              } as RouteObject);\n            }\n\n            return lists;\n          },\n          { server: [], client: [], ambivalent: [] },\n        ),\n      );\n\n      return [\n        ...(result.server.length\n          ? [\n              // The server routes are wrapped with the route that has a layout\n              // element. It also has the `IGNORE_FALLBACK` flag to remove the\n              // fallback route from reach.\n              {\n                element: createElement(layoutComponent),\n                children: result.server as RouteObject[],\n                handle: {\n                  [RouteHandleFlags.IGNORE_FALLBACK]: true,\n                },\n              },\n            ]\n          : []),\n        // The client routes are preserved without wrapping.\n        ...result.client,\n        // The ambivalent routes are considered as client routes.\n        ...result.ambivalent,\n      ];\n    });\n\n    return this;\n  }\n\n  /**\n   * Protects all the routes that require authentication. For more details see\n   * {@link @vaadin/hilla-react-auth#protectRoutes} function.\n   *\n   * @param redirectPath - the path to redirect to if the route is protected\n   * and the user is not authenticated.\n   */\n  protect(redirectPath?: string): this {\n    this.update(undefined, ({ original: route, children }) => {\n      const finalRoute = protectRoute(route!, redirectPath);\n      finalRoute.children = children as RouteObject[] | undefined;\n      return finalRoute;\n    });\n\n    return this;\n  }\n\n  /**\n   * Deeply updates the current list of routes with the given routes merging\n   * them in process.\n   *\n   * @param routes - A list of routes to merge with the current list.\n   * @param callback - A callback to transform the routes during the merge.\n   */\n  update(routes: undefined, callback: RouteTransformer<undefined>): this;\n  update<T extends RouteBase>(routes: readonly T[], callback?: RouteTransformer<T>): this;\n  update<T extends RouteBase>(\n    routes: readonly T[] | undefined,\n    callback: RouteTransformer<T | undefined> = ({ original, overriding, children }) =>\n      ({\n        ...original,\n        ...overriding,\n        children,\n      }) as RouteObject,\n  ): this {\n    this.#modifiers.push((existingRoutes) =>\n      // Going through the existing and added list of routes.\n      transformTree<readonly [RouteList | undefined, readonly T[] | undefined], RouteList | undefined>(\n        [existingRoutes, routes],\n        null,\n        ([original, added], next) => {\n          if (original && added) {\n            // If we have both original and added routes, we have to merge them.\n            const final: Array<RouteObject | undefined> = [];\n            const pathKeys = new Set([...original.map(createRouteKey), ...added.map(createRouteKey)]);\n\n            for (const pathKey of pathKeys) {\n              // We can have multiple routes with the same path, so we have to\n              // consider all of them.\n              const originalRoutes = original.filter((r) => createRouteKey(r) === pathKey);\n              // We can have only one route with the same path in the added list.\n              const addedRoutes = added.filter((r) => createRouteKey(r) === pathKey);\n\n              if (addedRoutes.length > 1) {\n                throw new Error('Adding multiple routes with the same path is not allowed');\n              }\n\n              const addedRoute = addedRoutes[0] as T | undefined;\n\n              if (originalRoutes.length > 0 && addedRoute) {\n                // In case we have both original and added routes, we run\n                // the callback for each original route in pair with the added\n                // route. To make the difference, we flag all the routes except\n                // the last one as `dupe`.\n                //\n                // Why the last one is not `dupe`? According to the\n                // `react-router` logic, the last route is the fallback for all\n                // routes with the same path. So, if we apply callback to it,\n                // we implicitly apply it to all other routes with the same\n                // path.\n                //\n                // In case this logic doesn't work, the user can apply the\n                // callback without considering the `dupe` flag.\n                for (let i = 0; i < originalRoutes.length; i++) {\n                  final.push(\n                    callback({\n                      original: originalRoutes[i],\n                      overriding: addedRoute,\n                      children: next([originalRoutes[i].children, addedRoute.children]),\n                      dupe: i < originalRoutes.length - 1,\n                    }) ?? originalRoutes[i],\n                  );\n                }\n              } else if (originalRoutes.length > 0) {\n                // In case we don't have the added route with the path being\n                // processed, we run the callback for each original route.\n                for (let i = 0; i < originalRoutes.length; i++) {\n                  final.push(\n                    callback({\n                      original: originalRoutes[i],\n                      children: next([originalRoutes[i].children, undefined]),\n                      dupe: i < originalRoutes.length - 1,\n                    }) ?? originalRoutes[i],\n                  );\n                }\n              } else {\n                // In case we don't have the original route with the path being\n                // processed, we run the callback for only the added route.\n                const result = callback({\n                  overriding: addedRoute,\n                  children: next([undefined, addedRoute!.children]),\n                  dupe: false,\n                });\n\n                if (result) {\n                  final.push(result);\n                }\n              }\n            }\n\n            return final.filter((r) => r != null);\n          } else if (original) {\n            // If we have only original routes, we run the callback for each\n            // original route.\n            return original\n              .map((route) =>\n                callback({\n                  original: route,\n                  children: next([route.children, undefined]),\n                  dupe: false,\n                }),\n              )\n              .filter((r) => r != null);\n          } else if (added) {\n            // If we have only added routes, we run the callback for each added\n            // route.\n            return added\n              .map((route) =>\n                callback({\n                  overriding: route,\n                  children: next([undefined, route.children]),\n                  dupe: false,\n                }),\n              )\n              .filter((r) => r != null);\n          }\n\n          return undefined;\n        },\n      ),\n    );\n    return this;\n  }\n\n  /**\n   * Builds the router with the current list of routes.\n   */\n  build(options?: RouterBuildOptions): RouterConfiguration {\n    this.#withLayoutSkipping();\n    const routes = this.#modifiers.reduce<RouteList | undefined>((acc, mod) => mod(acc) ?? acc, undefined) ?? [];\n\n    return {\n      routes,\n      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options }),\n    };\n  }\n\n  #withLayoutSkipping(): this {\n    this.#modifiers.push((originalRoutes) => {\n      if (!originalRoutes) {\n        return originalRoutes;\n      }\n\n      type Accumulator<T extends RouteList> = Readonly<{\n        skipped: T;\n        regular: T;\n      }>;\n\n      const result = transformTree<RouteList, Accumulator<RouteList>>(originalRoutes, null, (routes, next) =>\n        // Split a single routes list onto two separate lists.\n        routes.reduce<Accumulator<WritableRouteList>>(\n          (lists, route) => {\n            // If the route has `skipLayout` flag, it goes to the `skipped` list.\n            if (getRouteHandleFlag(route, RouteHandleFlags.SKIP_LAYOUTS)) {\n              lists.skipped.push(route);\n              return lists;\n            }\n\n            // If the route is leaf, it goes to the `regular` list.\n            if (!route.children?.length) {\n              lists.regular.push(route);\n              return lists;\n            }\n\n            // As of children, we have to split them into two lists as well.\n            const { skipped, regular } = next(route.children ?? []);\n\n            // If we have `skipped` list of children, we have to remove the\n            // `element` property of the router to prevent the layout from\n            // rendering. Then, we add the current route to the `skipped` list.\n            if (skipped.length > 0) {\n              const { element, ...rest } = route;\n\n              lists.skipped.push({\n                ...rest,\n                children: skipped,\n              } as RouteObject);\n            }\n\n            // In case of `regular` children, we just add the current route to\n            // the `regular` list if there are any children.\n            if (regular.length > 0) {\n              lists.regular.push({\n                ...route,\n                children: regular,\n              } as RouteObject);\n            }\n\n            return lists;\n          },\n          { skipped: [], regular: [] },\n        ),\n      );\n\n      // We don't need a fallback for the skipped routes, so we have to wrap\n      // them with the route with the `IGNORE_FALLBACK` flag.\n      return [\n        ...(result.skipped.length\n          ? [\n              {\n                children: result.skipped as RouteObject[],\n                handle: {\n                  [RouteHandleFlags.IGNORE_FALLBACK]: true,\n                },\n              },\n            ]\n          : []),\n        ...result.regular,\n      ];\n    });\n\n    return this;\n  }\n}\n", "const viewPattern = /view/giu;\nconst upperCaseSplitPattern = /(?=[A-Z])/gu;\n\n/**\n * Converts the name of the component to a page title.\n *\n * @param component - The component to convert the name from.\n *\n * @returns The page title.\n */\nexport function convertComponentNameToTitle(component: unknown): string {\n  let name: string;\n\n  if (\n    component &&\n    (typeof component === 'object' || typeof component === 'function') &&\n    'name' in component &&\n    typeof component.name === 'string'\n  ) {\n    ({ name } = component);\n  } else {\n    name = String(component);\n  }\n\n  return name.replace(viewPattern, '').split(upperCaseSplitPattern).join(' ');\n}\n", "export function transformTree<T extends readonly unknown[], U, C extends object | null = null>(\n  nodes: T,\n  context: C,\n  transformer: (nodes: T, next: (nodes: T, ctx?: C) => U, context: C) => U,\n): U {\n  return transformer(nodes, (n, ctx = context) => transformTree(n, ctx, transformer), context);\n}\n", "import type { UIMatch } from 'react-router';\nimport { useMatches } from 'react-router';\nimport type { ViewConfig } from '../types.js';\n\n/**\n * Hook to return the {@link ViewConfig} for the current route.\n */\nexport function useViewConfig<M extends ViewConfig>(): M | undefined {\n  const matches = useMatches() as ReadonlyArray<UIMatch<unknown, M>>;\n  return matches[matches.length - 1]?.handle;\n}\n", "// TODO: Remove this polyfill when we move to ECMA2024\ndeclare global {\n  interface PromiseConstructor {\n    withResolvers<T>(): {\n      resolve(value: T): void;\n      reject(reason?: unknown): void;\n      promise: Promise<T>;\n    };\n  }\n}\n\nif (!('withResolvers' in Promise)) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Promise, 'withResolvers', {\n    configurable: true,\n    value<T>() {\n      let resolve: (value: T) => void;\n      let reject: (reason?: unknown) => void;\n      const promise = new Promise<T>((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n      });\n      return { resolve: resolve!, reject: reject!, promise };\n    },\n  });\n}\n\nexport {};\n", "export const urlAlphabet =\r\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\r\n", "import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\r\nexport { urlAlphabet } from './url-alphabet/index.js'\r\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\r\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\r\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\r\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\r\n  return (size = defaultSize) => {\r\n    let id = ''\r\n    while (true) {\r\n      let bytes = getRandom(step)\r\n      let j = step | 0\r\n      while (j--) {\r\n        id += alphabet[bytes[j] & mask] || ''\r\n        if (id.length >= size) return id\r\n      }\r\n    }\r\n  }\r\n}\r\nexport let customAlphabet = (alphabet, size = 21) =>\r\n  customRandom(alphabet, size | 0, random)\r\nexport let nanoid = (size = 21) => {\r\n  let id = ''\r\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\r\n  while (size--) {\r\n    id += scopedUrlAlphabet[bytes[size] & 63]\r\n  }\r\n  return id\r\n}\r\n", "import { nanoid } from 'nanoid';\n\nexport type StateEvent = Readonly<{\n  id: string;\n  type: string;\n  value: unknown;\n  accepted: boolean;\n  parentSignalId?: string;\n}>;\n\n/**\n * Creates a new state event type.\n */\ntype CreateStateEventType<V, T extends string, C extends Record<string, unknown> = Record<never, never>> = Readonly<{\n  type: T;\n  value: V;\n}> &\n  Readonly<C> &\n  StateEvent;\n\n/**\n * A state event received from the server describing the current state of the\n * signal.\n */\nexport type SnapshotStateEvent<T> = CreateStateEventType<T, 'snapshot'>;\n\n/**\n * A state event defines a new value of the signal shared with the server. The\n */\nexport type SetStateEvent<T> = CreateStateEventType<T, 'set'>;\n\nexport function createSetStateEvent<T>(value: T, signalId?: string, parentSignalId?: string): SetStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'set',\n    value,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type ReplaceStateEvent<T> = CreateStateEventType<T, 'replace', { expected: T }>;\n\nexport function createReplaceStateEvent<T>(\n  expected: T,\n  value: T,\n  signalId?: string,\n  parentSignalId?: string,\n): ReplaceStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'replace',\n    value,\n    expected,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type IncrementStateEvent = CreateStateEventType<number, 'increment'>;\n\nexport function createIncrementStateEvent(delta: number): IncrementStateEvent {\n  return {\n    id: nanoid(),\n    type: 'increment',\n    value: delta,\n    accepted: false,\n  };\n}\n\nexport type ListEntry<T> = Readonly<{\n  id: string;\n  prev?: string;\n  next?: string;\n  value: T;\n}>;\n\nexport type ListSnapshotStateEvent<T> = CreateStateEventType<never, 'snapshot', { entries: Array<ListEntry<T>> }>;\n\nexport type InsertLastStateEvent<T> = CreateStateEventType<T, 'insert', { position: 'last'; entryId?: string }>;\n\nexport function createInsertLastStateEvent<T>(value: T): InsertLastStateEvent<T> {\n  return {\n    id: nanoid(),\n    type: 'insert',\n    value,\n    position: 'last',\n    accepted: false,\n  };\n}\n\nexport type RemoveStateEvent = CreateStateEventType<never, 'remove', { entryId: string }>;\n\nexport function createRemoveStateEvent(entryId: string): RemoveStateEvent {\n  return {\n    id: nanoid(),\n    type: 'remove',\n    entryId,\n    value: undefined as never,\n    accepted: false,\n  };\n}\n\nfunction isStateEvent(event: unknown): event is StateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    typeof (event as { type?: unknown }).type === 'string' &&\n    typeof (event as { value?: unknown }).value !== 'undefined' &&\n    typeof (event as { accepted?: unknown }).accepted === 'boolean'\n  );\n}\n\nexport function isSnapshotStateEvent<T>(event: unknown): event is SnapshotStateEvent<T> {\n  return isStateEvent(event) && event.type === 'snapshot';\n}\n\nexport function isSetStateEvent<T>(event: unknown): event is SetStateEvent<T> {\n  return isStateEvent(event) && event.type === 'set';\n}\n\nexport function isReplaceStateEvent<T>(event: unknown): event is ReplaceStateEvent<T> {\n  return (\n    isStateEvent(event) && typeof (event as { expected?: unknown }).expected !== 'undefined' && event.type === 'replace'\n  );\n}\n\nexport function isIncrementStateEvent(event: unknown): event is IncrementStateEvent {\n  return isStateEvent(event) && event.type === 'increment';\n}\n\nexport function isListSnapshotStateEvent<T>(event: unknown): event is ListSnapshotStateEvent<T> {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'snapshot' &&\n    (event as { entries?: unknown }).entries instanceof Array &&\n    typeof (event as { accepted?: unknown }).accepted !== 'undefined'\n  );\n}\n\nexport function isInsertLastStateEvent<T>(event: unknown): event is InsertLastStateEvent<T> {\n  return isStateEvent(event) && event.type === 'insert' && (event as { position?: unknown }).position === 'last';\n}\n\nexport function isRemoveStateEvent(event: unknown): event is RemoveStateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'remove' &&\n    typeof (event as { entryId?: unknown }).entryId === 'string' &&\n    typeof (event as { value?: unknown }).value === 'undefined'\n  );\n}\n", "import type { ActionOnLostSubscription, ConnectClient, Subscription } from '@vaadin/hilla-frontend';\nimport { nanoid } from 'nanoid';\nimport { computed, signal, Signal } from './core.js';\nimport { createSetStateEvent, type StateEvent } from './events.js';\n\nconst ENDPOINT = 'SignalsHandler';\n\n/**\n * A return type for signal operations that exposes a `result` property of type\n * `Promise`, that resolves when the operation is completed. It allows defining\n * callbacks to be run after the operation is completed, or error handling when\n * the operation fails.\n *\n * @example\n * ```ts\n * const sharedName = NameService.sharedName({ defaultValue: '' });\n * sharedName.replace('John').result\n *    .then(() => console.log('Name updated successfully'))\n *    .catch((error) => console.error('Failed to update the name:', error));\n * ```\n */\nexport interface Operation {\n  result: Promise<void>;\n}\n\n/**\n * An abstraction of a signal that tracks the number of subscribers, and calls\n * the provided `onSubscribe` and `onUnsubscribe` callbacks for the first\n * subscription and the last unsubscription, respectively.\n * @internal\n */\nexport abstract class DependencyTrackingSignal<T> extends Signal<T> {\n  readonly #onFirstSubscribe: () => void;\n  readonly #onLastUnsubscribe: () => void;\n\n  // -1 means to ignore the first subscription that is created internally in the\n  // FullStackSignal constructor.\n  #subscribeCount = -1;\n\n  protected constructor(value: T | undefined, onFirstSubscribe: () => void, onLastUnsubscribe: () => void) {\n    super(value);\n    this.#onFirstSubscribe = onFirstSubscribe;\n    this.#onLastUnsubscribe = onLastUnsubscribe;\n  }\n\n  protected override S(node: unknown): void {\n    super.S(node);\n    if (this.#subscribeCount === 0) {\n      this.#onFirstSubscribe();\n    }\n    this.#subscribeCount += 1;\n  }\n\n  protected override U(node: unknown): void {\n    super.U(node);\n    this.#subscribeCount -= 1;\n    if (this.#subscribeCount === 0) {\n      this.#onLastUnsubscribe();\n    }\n  }\n}\n\n/**\n * An object that describes a data object to connect to the signal provider\n * service.\n */\nexport type ServerConnectionConfig = Readonly<{\n  /**\n   * The client instance to be used for communication.\n   */\n  client: ConnectClient;\n\n  /**\n   * The name of the signal provider service endpoint.\n   */\n  endpoint: string;\n\n  /**\n   * The name of the signal provider service method.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments to be sent to the endpoint\n   * method that provides the signal when subscribing to it.\n   */\n  params?: Record<string, unknown>;\n\n  /**\n   * The unique identifier of the parent signal in the client.\n   */\n  parentClientSignalId?: string;\n}>;\n\n/**\n * A server connection manager.\n */\nclass ServerConnection {\n  readonly #id: string;\n  readonly config: ServerConnectionConfig;\n  #subscription?: Subscription<StateEvent>;\n\n  constructor(id: string, config: ServerConnectionConfig) {\n    this.config = config;\n    this.#id = id;\n  }\n\n  get subscription() {\n    return this.#subscription;\n  }\n\n  connect() {\n    const { client, endpoint, method, params, parentClientSignalId } = this.config;\n\n    this.#subscription ??= client.subscribe(ENDPOINT, 'subscribe', {\n      providerEndpoint: endpoint,\n      providerMethod: method,\n      clientSignalId: this.#id,\n      params,\n      parentClientSignalId,\n    });\n\n    return this.#subscription;\n  }\n\n  async update(event: StateEvent): Promise<void> {\n    const onTheFly = !this.#subscription;\n\n    if (onTheFly) {\n      this.connect();\n    }\n\n    await this.config.client.call(ENDPOINT, 'update', {\n      clientSignalId: this.#id,\n      event,\n    });\n\n    if (onTheFly) {\n      this.disconnect();\n    }\n  }\n\n  disconnect() {\n    this.#subscription?.cancel();\n    this.#subscription = undefined;\n  }\n}\n\nexport const $update = Symbol('update');\nexport const $processServerResponse = Symbol('processServerResponse');\nexport const $setValueQuietly = Symbol('setValueQuietly');\nexport const $resolveOperation = Symbol('resolveOperation');\nexport const $createOperation = Symbol('createOperation');\n\n/**\n * A signal that holds a shared value. Each change to the value is propagated to\n * the server-side signal provider. At the same time, each change received from\n * the server-side signal provider is propagated to the local signal and it's\n * subscribers.\n *\n * @internal\n */\nexport abstract class FullStackSignal<T> extends DependencyTrackingSignal<T> {\n  /**\n   * The unique identifier of the signal necessary to communicate with the\n   * server.\n   */\n  readonly id: string;\n\n  /**\n   * The server connection manager.\n   */\n  readonly server: ServerConnection;\n\n  /**\n   * Defines whether the signal is currently awaits a server-side response.\n   */\n  readonly pending = computed(() => this.#pending.value);\n\n  /**\n   * Defines whether the signal has an error.\n   */\n  readonly error = computed(() => this.#error.value);\n\n  readonly #pending = signal(false);\n  readonly #error = signal<Error | undefined>(undefined);\n\n  // Paused at the very start to prevent the signal from sending the initial\n  // value to the server.\n  #paused = true;\n\n  constructor(value: T | undefined, config: ServerConnectionConfig, id?: string) {\n    super(\n      value,\n      () => this.#connect(),\n      () => this.#disconnect(),\n    );\n    this.id = id ?? nanoid();\n    this.server = new ServerConnection(this.id, config);\n\n    this.subscribe((v) => {\n      if (!this.#paused) {\n        this.#pending.value = true;\n        this.#error.value = undefined;\n        // For internal signals, the provided non-null to the constructor should\n        // be used along with the parent client side signal id when sending the\n        // set event to the server. For internal signals this combination is\n        // needed for addressing the correct parent/child signal instances on\n        // the server. For a standalone signal, both of them should be passed in\n        // as undefined:\n        const signalId = config.parentClientSignalId !== undefined ? this.id : undefined;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this[$update](createSetStateEvent(v, signalId, config.parentClientSignalId));\n      }\n    });\n\n    this.#paused = false;\n  }\n\n  // stores the promise handlers associated to operations\n  readonly #operationPromises = new Map<\n    string,\n    {\n      resolve(value: PromiseLike<void> | void): void;\n      reject(reason?: any): void;\n    }\n  >();\n\n  // creates the object to be returned by operations to allow defining callbacks\n  protected [$createOperation]({ id, promise }: { id?: string; promise?: Promise<void> }): Operation {\n    const thens = this.#operationPromises;\n    const promises: Array<Promise<void>> = [];\n\n    if (promise) {\n      // Add the provided promise to the list of promises\n      promises.push(promise);\n    }\n\n    if (id) {\n      // Create a promise to be associated to the provided id\n      promises.push(\n        new Promise<void>((resolve, reject) => {\n          thens.set(id, { resolve, reject });\n        }),\n      );\n    }\n\n    if (promises.length === 0) {\n      // If no promises were added, return a resolved promise\n      promises.push(Promise.resolve());\n    }\n\n    return {\n      result: Promise.allSettled(promises).then((results) => {\n        const lastResult = results[results.length - 1];\n        if (lastResult.status === 'fulfilled') {\n          return undefined;\n        }\n        throw lastResult.reason;\n      }),\n    };\n  }\n\n  /**\n   * Sets the local value of the signal without sending any events to the server\n   * @param value - The new value.\n   * @internal\n   */\n  protected [$setValueQuietly](value: T): void {\n    this.#paused = true;\n    super.value = value;\n    this.#paused = false;\n  }\n\n  /**\n   * A method to update the server with the new value.\n   *\n   * @param event - The event to update the server with.\n   * @returns The server response promise.\n   */\n  protected async [$update](event: StateEvent): Promise<void> {\n    return this.server\n      .update(event)\n      .catch((error: unknown) => {\n        this.#error.value = error instanceof Error ? error : new Error(String(error));\n      })\n      .finally(() => {\n        this.#pending.value = false;\n      });\n  }\n\n  /**\n   * Resolves the operation promise associated with the given event id.\n   *\n   * @param eventId - The event id.\n   * @param reason - The reason to reject the promise (if any).\n   */\n  protected [$resolveOperation](eventId: string, reason?: string): void {\n    const operationPromise = this.#operationPromises.get(eventId);\n    if (operationPromise) {\n      this.#operationPromises.delete(eventId);\n      if (reason) {\n        operationPromise.reject(reason);\n      } else {\n        operationPromise.resolve();\n      }\n    }\n  }\n\n  /**\n   * A method with to process the server response. The implementation is\n   * specific for each signal type.\n   *\n   * @param event - The server response event.\n   */\n  protected abstract [$processServerResponse](event: StateEvent): void;\n\n  #connect() {\n    this.server\n      .connect()\n      .onSubscriptionLost(() => 'resubscribe' as ActionOnLostSubscription)\n      .onNext((event: StateEvent) => {\n        this.#paused = true;\n        this[$processServerResponse](event);\n        this.#paused = false;\n      });\n  }\n\n  #disconnect() {\n    if (this.server.subscription === undefined) {\n      return;\n    }\n    this.server.disconnect();\n  }\n}\n", "import { nanoid } from 'nanoid';\nimport {\n  createReplaceStateEvent,\n  createSetStateEvent,\n  isReplaceStateEvent,\n  isSetStateEvent,\n  isSnapshotStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  FullStackSignal,\n  type Operation,\n} from './FullStackSignal.js';\n\ntype PendingRequestsRecord<T> = Readonly<{\n  id: string;\n  callback(value: T): T;\n}> & { canceled: boolean };\n\n/**\n * An operation subscription that can be canceled.\n */\nexport interface OperationSubscription extends Operation {\n  cancel(): void;\n}\n\n/**\n * A full-stack signal that holds an arbitrary value.\n */\nexport class ValueSignal<T> extends FullStackSignal<T> {\n  readonly #pendingRequests = new Map<string, PendingRequestsRecord<T>>();\n\n  /**\n   * Sets the value.\n   * Note that the value change event that is propagated to the server as the\n   * result of this operation is not taking the last seen value into account and\n   * will overwrite the shared value on the server unconditionally (AKA: \"Last\n   * Write Wins\"). If you need to perform a conditional update, use the\n   * `replace` method instead.\n   *\n   * @param value - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  set(value: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createSetStateEvent(value, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    this[$setValueQuietly](value);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Replaces the value with a new one only if the current value is equal to the\n   * expected value.\n   *\n   * @param expected - The expected value.\n   * @param newValue - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  replace(expected: T, newValue: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Tries to update the value by applying the callback function to the current\n   * value. In case of a concurrent change, the callback is run again with an\n   * updated input value. This is repeated until the result can be applied\n   * without concurrent changes, or the operation is canceled.\n   *\n   * Note that there is no guarantee that cancel() will be effective always,\n   * since a succeeding operation might already be on its way to the server.\n   *\n   * @param callback - The function that is applied on the current value to\n   *                   produce the new value.\n   * @returns An operation object that allows to perform additional actions,\n   *                   including cancellation.\n   */\n  update(callback: (value: T) => T): OperationSubscription {\n    const newValue = callback(this.value);\n    const event = createReplaceStateEvent(this.value, newValue);\n    const promise = this[$update](event);\n    const pendingRequest = { id: nanoid(), callback, canceled: false };\n    this.#pendingRequests.set(event.id, pendingRequest);\n    return {\n      ...this[$createOperation]({ id: pendingRequest.id, promise }),\n      cancel: () => {\n        pendingRequest.canceled = true;\n      },\n    };\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    const record = this.#pendingRequests.get(event.id);\n    if (record) {\n      this.#pendingRequests.delete(event.id);\n\n      if (!(event.accepted || record.canceled)) {\n        this.update(record.callback);\n      }\n    }\n\n    let reason: string | undefined;\n    if (event.accepted || isSnapshotStateEvent<T>(event)) {\n      this.#applyAcceptedEvent(event);\n    } else {\n      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;\n    }\n    // `then` callbacks can be associated to the record or the event\n    // it depends on the operation that was performed\n    [record?.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id!, reason));\n  }\n\n  #applyAcceptedEvent(event: StateEvent): void {\n    if (isSetStateEvent<T>(event) || isSnapshotStateEvent<T>(event)) {\n      this.value = event.value;\n    } else if (isReplaceStateEvent<T>(event)) {\n      if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {\n        this.value = event.value;\n      }\n    }\n  }\n}\n", "import { createIncrementStateEvent, isIncrementStateEvent, type StateEvent } from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\n/**\n * A signal that holds a number value. The underlying\n * value of this signal is stored and updated as a\n * shared value on the server.\n *\n * After obtaining the NumberSignal instance from\n * a server-side service that returns one, the value\n * can be updated using the `value` property,\n * and it can be read with or without the\n * `value` property (similar to a normal signal):\n *\n * @example\n * ```tsx\n * const counter = CounterService.counter();\n *\n * return (\n *    <Button onClick={() => counter.incrementBy(1)}>\n *      Click count: { counter }\n *    </Button>\n *    <Button onClick={() => counter.value = 0}>Reset</Button>\n * );\n * ```\n */\nexport class NumberSignal extends ValueSignal<number> {\n  readonly #sentIncrementEvents = new Map<string, StateEvent>();\n  /**\n   * Increments the value by the specified delta. The delta can be negative to\n   * decrease the value.\n   *\n   * This method differs from using the `++` or `+=` operators directly on the\n   * signal value. It performs an atomic operation to prevent conflicts from\n   * concurrent changes, ensuring that other users' modifications are not\n   * accidentally overwritten.\n   *\n   * @param delta - The delta to increment the value by. The delta can be\n   * negative.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  incrementBy(delta: number): Operation {\n    if (delta === 0) {\n      return { result: Promise.resolve() };\n    }\n    this[$setValueQuietly](this.value + delta);\n    const event = createIncrementStateEvent(delta);\n    this.#sentIncrementEvents.set(event.id, event);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (event.accepted && isIncrementStateEvent(event)) {\n      const sentEvent = this.#sentIncrementEvents.get(event.id);\n      if (sentEvent) {\n        this.#sentIncrementEvents.delete(event.id);\n      } else {\n        this[$setValueQuietly](this.value + event.value);\n      }\n      this[$resolveOperation](event.id);\n    } else {\n      super[$processServerResponse](event);\n    }\n  }\n}\n", "import { FullStackSignal } from './FullStackSignal.js';\n\n/**\n * A {@link FullStackSignal} that represents a collection of values.\n *\n * @typeParam T - The type of the values in the collection.\n */\nexport abstract class CollectionSignal<T> extends FullStackSignal<T> {\n  override get value(): T {\n    return super.value;\n  }\n\n  /**\n   * @readonly\n   */\n  override set value(_: never) {\n    throw new Error('Value of the collection signals cannot be set.');\n  }\n}\n", "import { CollectionSignal } from './CollectionSignal.js';\nimport {\n  createInsertLastStateEvent,\n  createRemoveStateEvent,\n  type InsertLastStateEvent,\n  isInsertLastStateEvent,\n  isListSnapshotStateEvent,\n  isRemoveStateEvent,\n  type ListSnapshotStateEvent,\n  type RemoveStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n  type ServerConnectionConfig,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\ntype EntryId = string;\ntype Entry<T> = {\n  id: EntryId;\n  value: ValueSignal<T>;\n  next?: EntryId;\n  prev?: EntryId;\n};\n\n/**\n * A {@link FullStackSignal} that represents a shared list of values, where each\n * value is represented by a {@link ValueSignal}.\n * The list can be modified by calling the defined methods to insert or remove\n * items, but the `value` property of a `ListSignal` instance is read-only and\n * cannot be assigned directly.\n * The value of each item in the list can be manipulated similar to a regular\n * {@link ValueSignal}.\n *\n * @typeParam T - The type of the values in the list.\n */\nexport class ListSignal<T> extends CollectionSignal<ReadonlyArray<ValueSignal<T>>> {\n  #head?: EntryId;\n  #tail?: EntryId;\n\n  readonly #values = new Map<string, Entry<T>>();\n\n  constructor(config: ServerConnectionConfig) {\n    const initialValue: Array<ValueSignal<T>> = [];\n    super(initialValue, config);\n  }\n\n  #computeItems(): ReadonlyArray<ValueSignal<T>> {\n    let current = this.#head;\n    const result: Array<ValueSignal<T>> = [];\n    while (current !== undefined) {\n      const entry = this.#values.get(current)!;\n      result.push(entry.value);\n      current = entry.next;\n    }\n    return result;\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (!event.accepted) {\n      this[$resolveOperation](\n        event.id,\n        `Server rejected the operation with id '${event.id}'. See the server log for more details.`,\n      );\n      return;\n    }\n    if (isListSnapshotStateEvent<T>(event)) {\n      this.#handleSnapshotEvent(event);\n    } else if (isInsertLastStateEvent<T>(event)) {\n      this.#handleInsertLastUpdate(event);\n    } else if (isRemoveStateEvent(event)) {\n      this.#handleRemoveUpdate(event);\n    }\n    this[$resolveOperation](event.id);\n  }\n\n  #handleInsertLastUpdate(event: InsertLastStateEvent<T>): void {\n    if (event.entryId === undefined) {\n      throw new Error('Unexpected state: Entry id should be defined when insert last event is accepted');\n    }\n    const valueSignal = new ValueSignal<T>(\n      event.value,\n      { ...this.server.config, parentClientSignalId: this.id },\n      event.entryId,\n    );\n    const newEntry: Entry<T> = { id: valueSignal.id, value: valueSignal };\n\n    if (this.#head === undefined) {\n      this.#head = newEntry.id;\n      this.#tail = this.#head;\n    } else {\n      const tailEntry = this.#values.get(this.#tail!)!;\n      tailEntry.next = newEntry.id;\n      newEntry.prev = this.#tail;\n      this.#tail = newEntry.id;\n    }\n    this.#values.set(valueSignal.id, newEntry);\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleRemoveUpdate(event: RemoveStateEvent): void {\n    const entryToRemove = this.#values.get(event.entryId);\n    if (entryToRemove === undefined) {\n      return;\n    }\n    this.#values.delete(event.id);\n    if (this.#head === entryToRemove.id) {\n      if (entryToRemove.next === undefined) {\n        this.#head = undefined;\n        this.#tail = undefined;\n      } else {\n        const newHead = this.#values.get(entryToRemove.next)!;\n        this.#head = newHead.id;\n        newHead.prev = undefined;\n      }\n    } else {\n      const prevEntry = this.#values.get(entryToRemove.prev!)!;\n      const nextEntry = entryToRemove.next !== undefined ? this.#values.get(entryToRemove.next) : undefined;\n      if (nextEntry === undefined) {\n        this.#tail = prevEntry.id;\n        prevEntry.next = undefined;\n      } else {\n        prevEntry.next = nextEntry.id;\n        nextEntry.prev = prevEntry.id;\n      }\n    }\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleSnapshotEvent(event: ListSnapshotStateEvent<T>): void {\n    event.entries.forEach((entry) => {\n      this.#values.set(entry.id, {\n        id: entry.id,\n        prev: entry.prev,\n        next: entry.next,\n        value: new ValueSignal(entry.value, { ...this.server.config, parentClientSignalId: this.id }, entry.id),\n      });\n      if (entry.prev === undefined) {\n        this.#head = entry.id;\n      }\n      if (entry.next === undefined) {\n        this.#tail = entry.id;\n      }\n    });\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  /**\n   * Inserts a new value at the end of the list.\n   * @param value - The value to insert.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  insertLast(value: T): Operation {\n    const event = createInsertLastStateEvent(value);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Removes the given item from the list.\n   * @param item - The item to remove.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  remove(item: ValueSignal<T>): Operation {\n    const entryToRemove = this.#values.get(item.id);\n    if (entryToRemove === undefined) {\n      return { result: Promise.resolve() };\n    }\n    const removeEvent = createRemoveStateEvent(entryToRemove.value.id);\n    const promise = this[$update](removeEvent);\n    return this[$createOperation]({ id: removeEvent.id, promise });\n  }\n}\n", "/// <reference types=\"vite/client\" />\nimport { type Signal, signal } from '@vaadin/hilla-react-signals';\nimport type { VaadinWindow } from '../shared/internal.js';\nimport type { MenuItem, ViewConfig } from '../types.js';\n\nexport const viewsSignal: Signal<Readonly<Record<string, Readonly<ViewConfig>>> | undefined> = signal(\n  (window as VaadinWindow).Vaadin?.views,\n);\n\nfunction isExcluded(value: ViewConfig): boolean {\n  return !!value.menu?.exclude;\n}\n\nfunction hasVariablePathSegment(path: string): boolean {\n  return path.split('/').some((segment) => segment.startsWith(':'));\n}\n\n/**\n * Creates menu items from the views provided by the server. The views are sorted according to the\n * {@link ViewConfig.menu.order}, filtered out if they are explicitly excluded via {@link ViewConfig.menu.exclude}.\n * Note that views with no order are put below views with an order. Ties are resolved based on the path string\n * comparison.\n *\n * @returns A list of menu items.\n */\nexport function createMenuItems(): readonly MenuItem[] {\n  // @ts-expect-error: esbuild injection\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n  ((feature, vaadinObj = (window.Vaadin ??= {})) => {\n  vaadinObj.registrations ??= [];\n  vaadinObj.registrations.push({\n    is: feature ? `@vaadin/hilla-file-router/${feature}` : '@vaadin/hilla-file-router',\n    version: '24.7.2',\n  });\n})('createMenuItems', (window as VaadinWindow).Vaadin);\n  const collator = new Intl.Collator('en-US');\n  if (!viewsSignal.value) {\n    return [];\n  }\n\n  const views = Object.entries(viewsSignal.value);\n\n  return (\n    views\n      // Filter out the views that are explicitly excluded from the menu.\n      .filter(([path, value]) => !isExcluded(value) && !hasVariablePathSegment(path))\n      // Map the views to menu items.\n      .map(([path, config]) => ({\n        to: path,\n        icon: config.menu?.icon,\n        title: config.menu?.title ?? config.title,\n        order: config.menu?.order,\n      }))\n      // Sort views according to the order specified in the view configuration.\n      .sort((menuA, menuB) => {\n        const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);\n        return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);\n      })\n  );\n}\n\nif (import.meta.hot) {\n  import.meta.hot.on('fs-route-update', () => {\n    fetch('?v-r=routeinfo')\n      .then(async (resp) => resp.json())\n      .then((json) => {\n        viewsSignal.value = json;\n      })\n      .catch((e: unknown) => {\n        console.error('Failed to fetch route info', e);\n      });\n  });\n}\n"],
  "mappings": "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",
  "names": ["module: Module | null", "config?: ViewConfig", "path: string", "moduleOrChildren?: Module | readonly AgnosticRoute[]", "children?: readonly AgnosticRoute[]", "module: Module | undefined", "import_react", "initialState: AuthState<unknown>", "AuthContext: Context<Authentication<unknown>>", "_jsx", "route: RouteObjectWithAuth", "redirectPath: string", "_a", "_jsx", "import_react", "component: unknown", "name: string", "nodes: T", "context: C", "transformer: (nodes: T, next: (nodes: T, ctx?: C) => U, context: C) => U", "n", "module: Module", "route: T", "RouteHandleFlags", "route: RouteObject", "flag: T", "#modifiers", "routes: RouteList", "routes: readonly AgnosticRoute[]", "_a", "component: ComponentType", "config?: ViewConfig", "fallbackRoutes: RouteList", "layoutComponent: ComponentType", "redirectPath?: string", "routes: readonly T[] | undefined", "callback: RouteTransformer<T | undefined>", "final: Array<RouteObject | undefined>", "r", "options?: RouterBuildOptions", "#withLayoutSkipping", "_a", "_a", "viewsSignal: Signal<Readonly<Record<string, Readonly<ViewConfig>>> | undefined>", "value: ViewConfig", "_a", "path: string", "e: unknown"]
}
