import {
  PolylitMixin
} from "./chunk-2XOX65VI.js";
import {
  ifDefined
} from "./chunk-GCEQFJ47.js";
import {
  PopoverOverlayMixin,
  PopoverPositionMixin,
  PopoverTargetMixin
} from "./chunk-NK7Q7TKS.js";
import {
  OverlayClassMixin
} from "./chunk-UF5ES3VB.js";
import {
  overlayStyles
} from "./chunk-K56GLCGU.js";
import {
  isLastOverlay
} from "./chunk-NPC7FAUI.js";
import {
  generateUniqueId
} from "./chunk-4SWSK3CD.js";
import {
  ThemableMixin,
  ThemePropertyMixin
} from "./chunk-KEWLZU7R.js";
import {
  ElementMixin
} from "./chunk-QN4QZSZG.js";
import {
  getDeepActiveElement,
  getFocusableElements,
  isElementFocused,
  isKeyboardActive
} from "./chunk-CXDC5LNX.js";
import {
  DirMixin
} from "./chunk-QBLL3FQM.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import {
  LitElement
} from "./chunk-2VJ6XAW7.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";
import {
  html
} from "./chunk-4QYCOPDF.js";

// node_modules/@vaadin/popover/src/vaadin-popover-overlay.js
var PopoverOverlay = class extends PopoverOverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LitElement)))) {
  static get is() {
    return "vaadin-popover-overlay";
  }
  static get styles() {
    return [
      overlayStyles,
      css`
        :host {
          --_vaadin-popover-content-width: auto;
          --_vaadin-popover-content-height: auto;
        }

        :host([modeless][with-backdrop]) [part='backdrop'] {
          pointer-events: none;
        }

        :host([position^='top'][top-aligned]) [part='overlay'],
        :host([position^='bottom'][top-aligned]) [part='overlay'] {
          margin-top: var(--vaadin-popover-offset-top, 0);
        }

        [part='overlay'] {
          position: relative;
          overflow: visible;
          max-height: 100%;
        }

        [part='content'] {
          overflow: auto;
          box-sizing: border-box;
          max-height: 100%;
          width: var(--_vaadin-popover-content-width);
          height: var(--_vaadin-popover-content-height);
        }

        /* Increase the area of the popover so the pointer can go from the target directly to it. */
        [part='overlay']::before {
          position: absolute;
          content: '';
          inset-block: calc(var(--vaadin-popover-offset-top, 0) * -1) calc(var(--vaadin-popover-offset-bottom, 0) * -1);
          inset-inline: calc(var(--vaadin-popover-offset-start, 0) * -1) calc(var(--vaadin-popover-offset-end, 0) * -1);
          z-index: -1;
          pointer-events: auto;
        }

        :host([position^='top'][bottom-aligned]) [part='overlay'],
        :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
          margin-bottom: var(--vaadin-popover-offset-bottom, 0);
        }

        :host([position^='start'][start-aligned]) [part='overlay'],
        :host([position^='end'][start-aligned]) [part='overlay'] {
          margin-inline-start: var(--vaadin-popover-offset-start, 0);
        }

        :host([position^='start'][end-aligned]) [part='overlay'],
        :host([position^='end'][end-aligned]) [part='overlay'] {
          margin-inline-end: var(--vaadin-popover-offset-end, 0);
        }

        [part='arrow'] {
          display: none;
          position: absolute;
          height: 0;
          width: 0;
        }

        :host([theme~='arrow']) [part='arrow'] {
          display: block;
        }
      `
    ];
  }
  /** @protected */
  render() {
    return html`
      <div id="backdrop" part="backdrop" hidden ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="arrow"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
};
defineCustomElement(PopoverOverlay);

// node_modules/@vaadin/popover/src/vaadin-popover.js
var DEFAULT_DELAY = 500;
var defaultFocusDelay = DEFAULT_DELAY;
var defaultHoverDelay = DEFAULT_DELAY;
var defaultHideDelay = DEFAULT_DELAY;
var PopoverOpenedStateController = class {
  constructor(host) {
    this.host = host;
  }
  /**
   * Whether closing is currently in progress.
   * @return {boolean}
   */
  get isClosing() {
    return this.__closeTimeout != null;
  }
  /** @private */
  get __focusDelay() {
    const popover = this.host;
    return popover.focusDelay != null && popover.focusDelay >= 0 ? popover.focusDelay : defaultFocusDelay;
  }
  /** @private */
  get __hoverDelay() {
    const popover = this.host;
    return popover.hoverDelay != null && popover.hoverDelay >= 0 ? popover.hoverDelay : defaultHoverDelay;
  }
  /** @private */
  get __hideDelay() {
    const popover = this.host;
    return popover.hideDelay != null && popover.hideDelay >= 0 ? popover.hideDelay : defaultHideDelay;
  }
  /**
   * Schedule opening the popover.
   * @param {Object} options
   */
  open(options = { immediate: false }) {
    if (this.isClosing) {
      this.__abortClose();
      return;
    }
    const { immediate, trigger } = options;
    const shouldDelayHover = trigger === "hover" && this.__hoverDelay > 0;
    const shouldDelayFocus = trigger === "focus" && this.__focusDelay > 0;
    if (!immediate && (shouldDelayHover || shouldDelayFocus)) {
      this.__scheduleOpen(trigger);
    } else {
      this.__showPopover();
    }
  }
  /**
   * Schedule closing the popover.
   * @param {boolean} immediate
   */
  close(immediate) {
    if (this.__openTimeout != null) {
      this.__abortOpen();
    } else if (immediate || this.__hideDelay === 0) {
      this.__abortClose();
      this.__setOpened(false);
    } else {
      this.__scheduleClose();
    }
  }
  /** @private */
  __setOpened(opened) {
    this.host.opened = opened;
  }
  /** @private */
  __showPopover() {
    this.__abortClose();
    this.__setOpened(true);
  }
  /** @private */
  __abortClose() {
    if (this.__closeTimeout) {
      clearTimeout(this.__closeTimeout);
      this.__closeTimeout = null;
    }
  }
  /** @private */
  __abortOpen() {
    if (this.__openTimeout) {
      clearTimeout(this.__openTimeout);
      this.__openTimeout = null;
    }
  }
  /** @private */
  __scheduleClose() {
    this.__closeTimeout = setTimeout(() => {
      this.__closeTimeout = null;
      this.__setOpened(false);
    }, this.__hideDelay);
  }
  /** @private */
  __scheduleOpen(trigger) {
    this.__abortOpen();
    const delay = trigger === "focus" ? this.__focusDelay : this.__hoverDelay;
    this.__openTimeout = setTimeout(() => {
      this.__openTimeout = null;
      this.__showPopover();
    }, delay);
  }
};
var Popover = class extends PopoverPositionMixin(
  PopoverTargetMixin(OverlayClassMixin(ThemePropertyMixin(ElementMixin(PolylitMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-popover";
  }
  static get styles() {
    return css`
      :host {
        display: none !important;
      }
    `;
  }
  static get properties() {
    return {
      /**
       * String used to label the overlay to screen reader users.
       *
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String
      },
      /**
       * Id of the element used as label of the overlay to screen reader users.
       *
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String
      },
      /**
       * When true, the popover content automatically receives focus after
       * it is opened. Modal popovers use this behavior by default.
       */
      autofocus: {
        type: Boolean
      },
      /**
       * Height to be set on the overlay content.
       *
       * @attr {string} content-height
       */
      contentHeight: {
        type: String
      },
      /**
       * Width to be set on the overlay content.
       *
       * @attr {string} content-width
       */
      contentWidth: {
        type: String
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on focus when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} focus-delay
       */
      focusDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is closed
       * on losing hover, when the corresponding trigger is used.
       * On blur, the popover is closed immediately.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hide-delay
       */
      hideDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on hover when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hover-delay
       */
      hoverDelay: {
        type: Number
      },
      /**
       * True if the popover overlay is opened, false otherwise.
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        observer: "__openedChanged"
      },
      /**
       * The `role` attribute value to be set on the overlay.
       *
       * @attr {string} overlay-role
       */
      overlayRole: {
        type: String,
        value: "dialog"
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `popover` The reference to the `vaadin-popover` element (overlay host).
       */
      renderer: {
        type: Object
      },
      /**
       * When true, the popover prevents interacting with background elements
       * by setting `pointer-events` style on the document body to `none`.
       * This also enables trapping focus inside the overlay.
       */
      modal: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover overlay on outside click.
       *
       * @attr {boolean} no-close-on-outside-click
       */
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover overlay on Escape press.
       * When the popover is modal, pressing Escape anywhere in the
       * document closes the overlay. Otherwise, only Escape press
       * from the popover itself or its target closes the overlay.
       *
       * @attr {boolean} no-close-on-esc
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Popover trigger mode, used to configure how the overlay is opened or closed.
       * Could be set to multiple by providing an array, e.g. `trigger = ['hover', 'focus']`.
       *
       * Supported values:
       * - `click` (default) - opens and closes on target click.
       * - `hover` - opens on target mouseenter, closes on target mouseleave. Moving mouse
       * to the popover overlay content keeps the overlay opened.
       * - `focus` - opens on target focus, closes on target blur. Moving focus to the
       * popover overlay content keeps the overlay opened.
       *
       * In addition to the behavior specified by `trigger`, the popover can be closed by:
       * - pressing Escape key (unless `noCloseOnEsc` property is true)
       * - outside click (unless `noCloseOnOutsideClick` property is true)
       *
       * When setting `trigger` property to `null`, `undefined` or empty array, the popover
       * can be only opened programmatically by changing `opened` property. Note, closing
       * on Escape press or outside click is still allowed unless explicitly disabled.
       */
      trigger: {
        type: Array,
        value: () => ["click"]
      },
      /**
       * When true, the overlay has a backdrop (modality curtain) on top of the
       * underlying page content, covering the whole viewport.
       *
       * @attr {boolean} with-backdrop
       */
      withBackdrop: {
        type: Boolean,
        value: false
      },
      /** @private */
      __shouldRestoreFocus: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @private */
      __overlayId: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__updateContentHeight(contentHeight, _overlayElement)",
      "__updateContentWidth(contentWidth, _overlayElement)",
      "__updateAriaAttributes(opened, overlayRole, target)"
    ];
  }
  /**
   * Sets the default focus delay to be used by all popover instances,
   * except for those that have focus delay configured using property.
   *
   * @param {number} focusDelay
   */
  static setDefaultFocusDelay(focusDelay) {
    defaultFocusDelay = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hide delay to be used by all popover instances,
   * except for those that have hide delay configured using property.
   *
   * @param {number} hideDelay
   */
  static setDefaultHideDelay(hideDelay) {
    defaultHideDelay = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hover delay to be used by all popover instances,
   * except for those that have hover delay configured using property.
   *
   * @param {number} hoverDelay
   */
  static setDefaultHoverDelay(hoverDelay) {
    defaultHoverDelay = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY;
  }
  constructor() {
    super();
    this.__overlayId = `vaadin-popover-${generateUniqueId()}`;
    this.__onGlobalClick = this.__onGlobalClick.bind(this);
    this.__onGlobalKeyDown = this.__onGlobalKeyDown.bind(this);
    this.__onTargetClick = this.__onTargetClick.bind(this);
    this.__onTargetFocusIn = this.__onTargetFocusIn.bind(this);
    this.__onTargetFocusOut = this.__onTargetFocusOut.bind(this);
    this.__onTargetMouseEnter = this.__onTargetMouseEnter.bind(this);
    this.__onTargetMouseLeave = this.__onTargetMouseLeave.bind(this);
    this._openedStateController = new PopoverOpenedStateController(this);
  }
  /** @protected */
  render() {
    const effectivePosition = this.__effectivePosition;
    return html`
      <vaadin-popover-overlay
        id="${this.__overlayId}"
        role="${this.overlayRole}"
        aria-label="${ifDefined(this.accessibleName)}"
        aria-labelledby="${ifDefined(this.accessibleNameRef)}"
        .renderer="${this.renderer}"
        .owner="${this}"
        theme="${ifDefined(this._theme)}"
        .positionTarget="${this.target}"
        .position="${effectivePosition}"
        .opened="${this.opened}"
        .modeless="${!this.modal}"
        .focusTrap="${this.modal}"
        .withBackdrop="${this.withBackdrop}"
        ?no-horizontal-overlap="${this.__computeNoHorizontalOverlap(effectivePosition)}"
        ?no-vertical-overlap="${this.__computeNoVerticalOverlap(effectivePosition)}"
        .horizontalAlign="${this.__computeHorizontalAlign(effectivePosition)}"
        .verticalAlign="${this.__computeVerticalAlign(effectivePosition)}"
        @mousedown="${this.__onOverlayMouseDown}"
        @mouseenter="${this.__onOverlayMouseEnter}"
        @mouseleave="${this.__onOverlayMouseLeave}"
        @focusin="${this.__onOverlayFocusIn}"
        @focusout="${this.__onOverlayFocusOut}"
        @opened-changed="${this.__onOpenedChanged}"
        .restoreFocusOnClose="${this.__shouldRestoreFocus}"
        .restoreFocusNode="${this.target}"
        @vaadin-overlay-escape-press="${this.__onEscapePress}"
        @vaadin-overlay-outside-click="${this.__onOutsideClick}"
        @vaadin-overlay-open="${this.__onOverlayOpened}"
        @vaadin-overlay-closed="${this.__onOverlayClosed}"
      ></vaadin-popover-overlay>
    `;
  }
  /**
   * Requests an update for the content of the popover.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || !this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.$[this.__overlayId];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__onGlobalClick, true);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__onGlobalClick, true);
    queueMicrotask(() => {
      if (!this.isConnected) {
        this._openedStateController.close(true);
      }
    });
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _addTargetListeners(target) {
    target.addEventListener("click", this.__onTargetClick);
    target.addEventListener("mouseenter", this.__onTargetMouseEnter);
    target.addEventListener("mouseleave", this.__onTargetMouseLeave);
    target.addEventListener("focusin", this.__onTargetFocusIn);
    target.addEventListener("focusout", this.__onTargetFocusOut);
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _removeTargetListeners(target) {
    target.removeEventListener("click", this.__onTargetClick);
    target.removeEventListener("mouseenter", this.__onTargetMouseEnter);
    target.removeEventListener("mouseleave", this.__onTargetMouseLeave);
    target.removeEventListener("focusin", this.__onTargetFocusIn);
    target.removeEventListener("focusout", this.__onTargetFocusOut);
  }
  /** @private */
  __openedChanged(opened, oldOpened) {
    if (opened) {
      document.addEventListener("keydown", this.__onGlobalKeyDown, true);
    } else if (oldOpened) {
      document.removeEventListener("keydown", this.__onGlobalKeyDown, true);
    }
  }
  /** @private */
  __updateAriaAttributes(opened, overlayRole, target) {
    if (this.__oldTarget) {
      const oldEffectiveTarget = this.__oldTarget.ariaTarget || this.__oldTarget;
      oldEffectiveTarget.removeAttribute("aria-haspopup");
      oldEffectiveTarget.removeAttribute("aria-expanded");
      oldEffectiveTarget.removeAttribute("aria-controls");
    }
    if (target) {
      const effectiveTarget = target.ariaTarget || target;
      const isDialog = overlayRole === "dialog" || overlayRole === "alertdialog";
      effectiveTarget.setAttribute("aria-haspopup", isDialog ? "dialog" : "true");
      effectiveTarget.setAttribute("aria-expanded", opened ? "true" : "false");
      if (opened) {
        effectiveTarget.setAttribute("aria-controls", this.__overlayId);
      } else {
        effectiveTarget.removeAttribute("aria-controls");
      }
      this.__oldTarget = target;
    }
  }
  /**
   * Overlay's global outside click listener doesn't work when
   * the overlay is modeless, so we use a separate listener.
   * @private
   */
  __onGlobalClick(event) {
    if (this.opened && !this.modal && !event.composedPath().some((el) => el === this._overlayElement || el === this.target) && !this.noCloseOnOutsideClick && isLastOverlay(this._overlayElement)) {
      this._openedStateController.close(true);
    }
  }
  /** @private */
  __onTargetClick() {
    if (this.__hasTrigger("click")) {
      if (!this.opened) {
        this.__shouldRestoreFocus = true;
      }
      if (this.opened) {
        this._openedStateController.close(true);
      } else {
        this._openedStateController.open({ immediate: true });
      }
    }
  }
  /**
   * Overlay's global Escape press listener doesn't work when
   * the overlay is modeless, so we use a separate listener.
   * @private
   */
  __onGlobalKeyDown(event) {
    if (this.modal) {
      return;
    }
    if (event.key === "Escape" && !this.noCloseOnEsc && this.opened && isLastOverlay(this._overlayElement)) {
      event.stopPropagation();
      this._openedStateController.close(true);
    }
    if (event.key === "Tab") {
      if (event.shiftKey) {
        this.__onGlobalShiftTab(event);
      } else {
        this.__onGlobalTab(event);
      }
    }
  }
  /** @private */
  __onGlobalTab(event) {
    const overlayPart = this._overlayElement.$.overlay;
    if (this.target && isElementFocused(this.__getTargetFocusable())) {
      event.preventDefault();
      overlayPart.focus();
      return;
    }
    const lastFocusable = this.__getLastFocusable(overlayPart);
    if (lastFocusable && isElementFocused(lastFocusable)) {
      const focusable = this.__getNextBodyFocusable(this.__getTargetFocusable());
      if (focusable && focusable !== overlayPart) {
        event.preventDefault();
        focusable.focus();
        return;
      }
    }
    const activeElement = getDeepActiveElement();
    const nextFocusable = this.__getNextBodyFocusable(activeElement);
    if (nextFocusable === overlayPart && lastFocusable) {
      lastFocusable.focus();
    }
  }
  /** @private */
  __onGlobalShiftTab(event) {
    const overlayPart = this._overlayElement.$.overlay;
    if (this.target && isElementFocused(this.__getTargetFocusable()) && this.__shouldRestoreFocus) {
      this.__shouldRestoreFocus = false;
      return;
    }
    if (this.target && isElementFocused(overlayPart)) {
      event.preventDefault();
      this.__getTargetFocusable().focus();
      return;
    }
    const nextFocusable = this.__getNextBodyFocusable(this.__getTargetFocusable());
    if (nextFocusable && isElementFocused(nextFocusable)) {
      const lastFocusable = this.__getLastFocusable(overlayPart);
      if (lastFocusable) {
        event.preventDefault();
        lastFocusable.focus();
      }
    }
  }
  /** @private */
  __getNextBodyFocusable(target) {
    const focusables = getFocusableElements(document.body);
    const idx = focusables.findIndex((el) => el === target);
    return focusables[idx + 1];
  }
  /** @private */
  __getLastFocusable(container) {
    const focusables = getFocusableElements(container);
    return focusables.pop();
  }
  /** @private */
  __getTargetFocusable() {
    if (!this.target) {
      return null;
    }
    return this.target.focusElement || this.target;
  }
  /** @private */
  __onTargetFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus")) {
      if (this.__hasTrigger("click") && !isKeyboardActive()) {
        return;
      }
      if (!this.__shouldRestoreFocus) {
        this.__shouldRestoreFocus = true;
        this._openedStateController.open({ trigger: "focus" });
      }
    }
  }
  /** @private */
  __onTargetFocusOut(event) {
    if (this._overlayElement.opened && !isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onTargetMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && !this.opened) {
      if (this.modal) {
        this.target.style.pointerEvents = "auto";
      }
      this._openedStateController.open({ trigger: "hover" });
    }
  }
  /** @private */
  __onTargetMouseLeave(event) {
    if (this._overlayElement.opened && !isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __onOverlayFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus") || this.__hasTrigger("click")) {
      this.__shouldRestoreFocus = true;
    }
  }
  /** @private */
  __onOverlayFocusOut(event) {
    if (!isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || event.relatedTarget === this.target || this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onOverlayMouseDown() {
    if (this.__hasTrigger("focus")) {
      this.__mouseDownInside = true;
      document.addEventListener(
        "mouseup",
        () => {
          this.__mouseDownInside = false;
        },
        { once: true }
      );
    }
  }
  /** @private */
  __onOverlayMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && this._openedStateController.isClosing) {
      this._openedStateController.open({ immediate: true });
    }
  }
  /** @private */
  __onOverlayMouseLeave(event) {
    if (!isLastOverlay(this._overlayElement)) {
      return;
    }
    if (event.relatedTarget === this.target) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __handleFocusout() {
    this.__focusInside = false;
    if (this.__hasTrigger("hover") && this.__hoverInside) {
      return;
    }
    if (this.__hasTrigger("focus")) {
      this._openedStateController.close(true);
    }
  }
  /** @private */
  __handleMouseLeave() {
    this.__hoverInside = false;
    if (this.__hasTrigger("focus") && this.__focusInside) {
      return;
    }
    if (this.__hasTrigger("hover")) {
      this._openedStateController.close();
    }
  }
  /** @private */
  __onOpenedChanged(event) {
    this.opened = event.detail.value;
  }
  /** @private */
  __onOverlayOpened() {
    if (this.autofocus && !this.modal) {
      this._overlayElement.$.overlay.focus();
    }
  }
  /** @private */
  __onOverlayClosed() {
    if (this.__shouldRestoreFocus) {
      setTimeout(() => {
        this.__shouldRestoreFocus = false;
      });
    }
    if (this.modal && this.target.style.pointerEvents) {
      this.target.style.pointerEvents = "";
    }
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /**
   * Close the popover if `noCloseOnEsc` isn't set to true.
   * @private
   */
  __onEscapePress(e) {
    if (this.noCloseOnEsc) {
      e.preventDefault();
    }
  }
  /**
   * Close the popover if `noCloseOnOutsideClick` isn't set to true.
   * @private
   */
  __onOutsideClick(e) {
    if (this.noCloseOnOutsideClick) {
      e.preventDefault();
    }
  }
  /** @private */
  __hasTrigger(trigger) {
    return Array.isArray(this.trigger) && this.trigger.includes(trigger);
  }
  /** @private */
  __updateDimension(overlay, dimension, value) {
    const prop = `--_vaadin-popover-content-${dimension}`;
    if (value) {
      overlay.style.setProperty(prop, value);
    } else {
      overlay.style.removeProperty(prop);
    }
  }
  /** @private */
  __updateContentHeight(height, overlay) {
    if (overlay) {
      this.__updateDimension(overlay, "height", height);
    }
  }
  /** @private */
  __updateContentWidth(width, overlay) {
    if (overlay) {
      this.__updateDimension(overlay, "width", width);
    }
  }
  /**
   * Fired when the popover is closed.
   *
   * @event closed
   */
};
defineCustomElement(Popover);

export {
  Popover
};
/*! Bundled license information:

@vaadin/popover/src/vaadin-popover-overlay.js:
  (**
   * @license
   * Copyright (c) 2024 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/popover/src/vaadin-popover.js:
  (**
   * @license
   * Copyright (c) 2024 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-RXVTKCGQ.js.map
