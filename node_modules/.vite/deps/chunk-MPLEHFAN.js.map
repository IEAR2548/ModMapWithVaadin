{
  "version": 3,
  "sources": ["../../ol/src/layer/Property.js", "../../ol/src/layer/Base.js", "../../ol/src/render/EventType.js", "../../ol/src/layer/Layer.js", "../../ol/src/renderer/Layer.js", "../../ol/src/render/Event.js", "../../ol/src/renderer/canvas/Layer.js"],
  "sourcesContent": ["/**\r\n * @module ol/layer/Property\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  OPACITY: 'opacity',\r\n  VISIBLE: 'visible',\r\n  EXTENT: 'extent',\r\n  Z_INDEX: 'zIndex',\r\n  MAX_RESOLUTION: 'maxResolution',\r\n  MIN_RESOLUTION: 'minResolution',\r\n  MAX_ZOOM: 'maxZoom',\r\n  MIN_ZOOM: 'minZoom',\r\n  SOURCE: 'source',\r\n  MAP: 'map',\r\n};\r\n", "/**\r\n * @module ol/layer/Base\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport LayerProperty from './Property.js';\r\nimport {abstract} from '../util.js';\r\nimport {assert} from '../asserts.js';\r\nimport {assign} from '../obj.js';\r\nimport {clamp} from '../math.js';\r\n\r\n/**\r\n * A css color, or a function called with a view resolution returning a css color.\r\n *\r\n * @typedef {string|function(number):string} BackgroundColor\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\r\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\r\n * will be rendered.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\r\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\r\n * is observable, and has get/set accessors.\r\n *\r\n * @api\r\n */\r\nclass BaseLayer extends BaseObject {\r\n  /**\r\n   * @param {Options} options Layer options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {BackgroundColor|false}\r\n     * @private\r\n     */\r\n    this.background_ = options.background;\r\n\r\n    /**\r\n     * @type {Object<string, *>}\r\n     */\r\n    const properties = assign({}, options);\r\n    if (typeof options.properties === 'object') {\r\n      delete properties.properties;\r\n      assign(properties, options.properties);\r\n    }\r\n\r\n    properties[LayerProperty.OPACITY] =\r\n      options.opacity !== undefined ? options.opacity : 1;\r\n    assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number\r\n\r\n    properties[LayerProperty.VISIBLE] =\r\n      options.visible !== undefined ? options.visible : true;\r\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\r\n    properties[LayerProperty.MAX_RESOLUTION] =\r\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\r\n    properties[LayerProperty.MIN_RESOLUTION] =\r\n      options.minResolution !== undefined ? options.minResolution : 0;\r\n    properties[LayerProperty.MIN_ZOOM] =\r\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\r\n    properties[LayerProperty.MAX_ZOOM] =\r\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\r\n\r\n    /**\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.className_ =\r\n      properties.className !== undefined ? properties.className : 'ol-layer';\r\n    delete properties.className;\r\n\r\n    this.setProperties(properties);\r\n\r\n    /**\r\n     * @type {import(\"./Layer.js\").State}\r\n     * @private\r\n     */\r\n    this.state_ = null;\r\n  }\r\n\r\n  /**\r\n   * Get the background for this layer.\r\n   * @return {BackgroundColor|false} Layer background.\r\n   */\r\n  getBackground() {\r\n    return this.background_;\r\n  }\r\n\r\n  /**\r\n   * @return {string} CSS class name.\r\n   */\r\n  getClassName() {\r\n    return this.className_;\r\n  }\r\n\r\n  /**\r\n   * This method is not meant to be called by layers or layer renderers because the state\r\n   * is incorrect if the layer is included in a layer group.\r\n   *\r\n   * @param {boolean} [opt_managed] Layer is managed.\r\n   * @return {import(\"./Layer.js\").State} Layer state.\r\n   */\r\n  getLayerState(opt_managed) {\r\n    /** @type {import(\"./Layer.js\").State} */\r\n    const state =\r\n      this.state_ ||\r\n      /** @type {?} */ ({\r\n        layer: this,\r\n        managed: opt_managed === undefined ? true : opt_managed,\r\n      });\r\n    const zIndex = this.getZIndex();\r\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\r\n    state.visible = this.getVisible();\r\n    state.extent = this.getExtent();\r\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\r\n    state.maxResolution = this.getMaxResolution();\r\n    state.minResolution = Math.max(this.getMinResolution(), 0);\r\n    state.minZoom = this.getMinZoom();\r\n    state.maxZoom = this.getMaxZoom();\r\n    this.state_ = state;\r\n\r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Array<import(\"./Layer.js\").default>} [opt_array] Array of layers (to be\r\n   *     modified in place).\r\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\r\n   */\r\n  getLayersArray(opt_array) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Array<import(\"./Layer.js\").State>} [opt_states] Optional list of layer\r\n   *     states (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\r\n   */\r\n  getLayerStatesArray(opt_states) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\r\n   * will be visible regardless of extent.\r\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\r\n      this.get(LayerProperty.EXTENT)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the maximum resolution of the layer.\r\n   * @return {number} The maximum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMaxResolution() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Return the minimum resolution of the layer.\r\n   * @return {number} The minimum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMinResolution() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Return the minimum zoom level of the layer.\r\n   * @return {number} The minimum zoom level of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\r\n  }\r\n\r\n  /**\r\n   * Return the maximum zoom level of the layer.\r\n   * @return {number} The maximum zoom level of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\r\n  }\r\n\r\n  /**\r\n   * Return the opacity of the layer (between 0 and 1).\r\n   * @return {number} The opacity of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getOpacity() {\r\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @return {import(\"../source/State.js\").default} Source state.\r\n   */\r\n  getSourceState() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the visibility of the layer (`true` or `false`).\r\n   * @return {boolean} The visibility of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getVisible() {\r\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\r\n  }\r\n\r\n  /**\r\n   * Return the Z-index of the layer, which is used to order layers before\r\n   * rendering. The default Z-index is 0.\r\n   * @return {number} The Z-index of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getZIndex() {\r\n    return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));\r\n  }\r\n\r\n  /**\r\n   * Sets the background color.\r\n   * @param {BackgroundColor} [opt_background] Background color.\r\n   */\r\n  setBackground(opt_background) {\r\n    this.background_ = opt_background;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\r\n   * will be visible at all extents.\r\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setExtent(extent) {\r\n    this.set(LayerProperty.EXTENT, extent);\r\n  }\r\n\r\n  /**\r\n   * Set the maximum resolution at which the layer is visible.\r\n   * @param {number} maxResolution The maximum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMaxResolution(maxResolution) {\r\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\r\n  }\r\n\r\n  /**\r\n   * Set the minimum resolution at which the layer is visible.\r\n   * @param {number} minResolution The minimum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMinResolution(minResolution) {\r\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\r\n  }\r\n\r\n  /**\r\n   * Set the maximum zoom (exclusive) at which the layer is visible.\r\n   * Note that the zoom levels for layer visibility are based on the\r\n   * view zoom level, which may be different from a tile source zoom level.\r\n   * @param {number} maxZoom The maximum zoom of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMaxZoom(maxZoom) {\r\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\r\n  }\r\n\r\n  /**\r\n   * Set the minimum zoom (inclusive) at which the layer is visible.\r\n   * Note that the zoom levels for layer visibility are based on the\r\n   * view zoom level, which may be different from a tile source zoom level.\r\n   * @param {number} minZoom The minimum zoom of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMinZoom(minZoom) {\r\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\r\n  }\r\n\r\n  /**\r\n   * Set the opacity of the layer, allowed values range from 0 to 1.\r\n   * @param {number} opacity The opacity of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setOpacity(opacity) {\r\n    assert(typeof opacity === 'number', 64); // Layer opacity must be a number\r\n    this.set(LayerProperty.OPACITY, opacity);\r\n  }\r\n\r\n  /**\r\n   * Set the visibility of the layer (`true` or `false`).\r\n   * @param {boolean} visible The visibility of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setVisible(visible) {\r\n    this.set(LayerProperty.VISIBLE, visible);\r\n  }\r\n\r\n  /**\r\n   * Set Z-index of the layer, which is used to order layers before rendering.\r\n   * The default Z-index is 0.\r\n   * @param {number} zindex The z-index of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setZIndex(zindex) {\r\n    this.set(LayerProperty.Z_INDEX, zindex);\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  disposeInternal() {\r\n    if (this.state_) {\r\n      this.state_.layer = null;\r\n      this.state_ = null;\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default BaseLayer;\r\n", "/**\r\n * @module ol/render/EventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered before a layer is rendered.\r\n   * @event module:ol/render/Event~RenderEvent#prerender\r\n   * @api\r\n   */\r\n  PRERENDER: 'prerender',\r\n\r\n  /**\r\n   * Triggered after a layer is rendered.\r\n   * @event module:ol/render/Event~RenderEvent#postrender\r\n   * @api\r\n   */\r\n  POSTRENDER: 'postrender',\r\n\r\n  /**\r\n   * Triggered before layers are composed.  When dispatched by the map, the event object will not have\r\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\r\n   * WebGL layers currently dispatch this event.\r\n   * @event module:ol/render/Event~RenderEvent#precompose\r\n   * @api\r\n   */\r\n  PRECOMPOSE: 'precompose',\r\n\r\n  /**\r\n   * Triggered after layers are composed.  When dispatched by the map, the event object will not have\r\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\r\n   * WebGL layers currently dispatch this event.\r\n   * @event module:ol/render/Event~RenderEvent#postcompose\r\n   * @api\r\n   */\r\n  POSTCOMPOSE: 'postcompose',\r\n\r\n  /**\r\n   * Triggered when rendering is complete, i.e. all sources and tiles have\r\n   * finished loading for the current viewport, and all tiles are faded in.\r\n   * The event object will not have a `context` set.\r\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\r\n   * @api\r\n   */\r\n  RENDERCOMPLETE: 'rendercomplete',\r\n};\r\n\r\n/**\r\n * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes\r\n */\r\n\r\n/**\r\n * @typedef {'postrender'|'prerender'} LayerRenderEventTypes\r\n */\r\n", "/**\r\n * @module ol/layer/Layer\r\n */\r\nimport BaseLayer from './Base.js';\r\nimport EventType from '../events/EventType.js';\r\nimport LayerProperty from './Property.js';\r\nimport RenderEventType from '../render/EventType.js';\r\nimport SourceState from '../source/State.js';\r\nimport {assert} from '../asserts.js';\r\nimport {assign} from '../obj.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(import(\"../PluggableMap.js\").FrameState):HTMLElement} RenderFunction\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     'change:source', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|'change:source'|\r\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\r\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\r\n * construction.\r\n * @property {import(\"../PluggableMap.js\").default|null} [map] Map.\r\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\r\n * HTML element. Will overwrite the default rendering for the layer.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} State\r\n * @property {import(\"./Layer.js\").default} layer Layer.\r\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\r\n * @property {import(\"../source/Source.js\").default|undefined} source Source being rendered (only for multi-source layers).\r\n * @property {boolean} visible Visible.\r\n * @property {boolean} managed Managed.\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\r\n * @property {number} zIndex ZIndex.\r\n * @property {number} maxResolution Maximum resolution.\r\n * @property {number} minResolution Minimum resolution.\r\n * @property {number} minZoom Minimum zoom.\r\n * @property {number} maxZoom Maximum zoom.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class from which all layer types are derived. This should only be instantiated\r\n * in the case where a custom layer is added to the map with a custom `render` function.\r\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\r\n *\r\n * A visual representation of raster or vector map data.\r\n * Layers group together those properties that pertain to how the data is to be\r\n * displayed, irrespective of the source of that data.\r\n *\r\n * Layers are usually added to a map with {@link import(\"../PluggableMap.js\").default#addLayer map.addLayer()}. Components\r\n * like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\r\n * internally. These unmanaged layers are associated with the map using\r\n * {@link module:ol/layer/Layer~Layer#setMap} instead.\r\n *\r\n * A generic `change` event is fired when the state of the source changes.\r\n *\r\n * Please note that for performance reasons several layers might get rendered to\r\n * the same HTML element, which will cause {@link import(\"../PluggableMap.js\").default#forEachLayerAtPixel map.forEachLayerAtPixel()} to\r\n * give false positives. To avoid this, apply different `className` properties to the\r\n * layers at creation time.\r\n *\r\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\r\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\r\n *\r\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\r\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\r\n * @api\r\n */\r\nclass Layer extends BaseLayer {\r\n  /**\r\n   * @param {Options<SourceType>} options Layer options.\r\n   */\r\n  constructor(options) {\r\n    const baseOptions = assign({}, options);\r\n    delete baseOptions.source;\r\n\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {LayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.mapPrecomposeKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.mapRenderKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.sourceChangeKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {RendererType}\r\n     */\r\n    this.renderer_ = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.rendered = false;\r\n\r\n    // Overwrite default render method with a custom one\r\n    if (options.render) {\r\n      this.render = options.render;\r\n    }\r\n\r\n    if (options.map) {\r\n      this.setMap(options.map);\r\n    }\r\n\r\n    this.addChangeListener(\r\n      LayerProperty.SOURCE,\r\n      this.handleSourcePropertyChange_\r\n    );\r\n\r\n    const source = options.source\r\n      ? /** @type {SourceType} */ (options.source)\r\n      : null;\r\n    this.setSource(source);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"./Layer.js\").default>} [opt_array] Array of layers (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\r\n   */\r\n  getLayersArray(opt_array) {\r\n    const array = opt_array ? opt_array : [];\r\n    array.push(this);\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"./Layer.js\").State>} [opt_states] Optional list of layer states (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\r\n   */\r\n  getLayerStatesArray(opt_states) {\r\n    const states = opt_states ? opt_states : [];\r\n    states.push(this.getLayerState());\r\n    return states;\r\n  }\r\n\r\n  /**\r\n   * Get the layer source.\r\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\r\n   * @observable\r\n   * @api\r\n   */\r\n  getSource() {\r\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\r\n  }\r\n\r\n  /**\r\n   * @return {SourceType|null} The source being rendered.\r\n   */\r\n  getRenderSource() {\r\n    return this.getSource();\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../source/State.js\").default} Source state.\r\n   */\r\n  getSourceState() {\r\n    const source = this.getSource();\r\n    return !source ? SourceState.UNDEFINED : source.getState();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourceChange_() {\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourcePropertyChange_() {\r\n    if (this.sourceChangeKey_) {\r\n      unlistenByKey(this.sourceChangeKey_);\r\n      this.sourceChangeKey_ = null;\r\n    }\r\n    const source = this.getSource();\r\n    if (source) {\r\n      this.sourceChangeKey_ = listen(\r\n        source,\r\n        EventType.CHANGE,\r\n        this.handleSourceChange_,\r\n        this\r\n      );\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\r\n   * an array of features.\r\n   */\r\n  getFeatures(pixel) {\r\n    if (!this.renderer_) {\r\n      return new Promise((resolve) => resolve([]));\r\n    }\r\n    return this.renderer_.getFeatures(pixel);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\r\n  getData(pixel) {\r\n    if (!this.renderer_ || !this.rendered) {\r\n      return null;\r\n    }\r\n    return this.renderer_.getData(pixel);\r\n  }\r\n\r\n  /**\r\n   * In charge to manage the rendering of the layer. One layer type is\r\n   * bounded with one layer renderer.\r\n   * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\r\n   * for rendering its content.\r\n   * @return {HTMLElement} The rendered element.\r\n   */\r\n  render(frameState, target) {\r\n    const layerRenderer = this.getRenderer();\r\n\r\n    if (layerRenderer.prepareFrame(frameState)) {\r\n      this.rendered = true;\r\n      return layerRenderer.renderFrame(frameState, target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when a layer is not visible during a map render.\r\n   */\r\n  unrender() {\r\n    this.rendered = false;\r\n  }\r\n\r\n  /**\r\n   * For use inside the library only.\r\n   * @param {import(\"../PluggableMap.js\").default|null} map Map.\r\n   */\r\n  setMapInternal(map) {\r\n    if (!map) {\r\n      this.unrender();\r\n    }\r\n    this.set(LayerProperty.MAP, map);\r\n  }\r\n\r\n  /**\r\n   * For use inside the library only.\r\n   * @return {import(\"../PluggableMap.js\").default|null} Map.\r\n   */\r\n  getMapInternal() {\r\n    return this.get(LayerProperty.MAP);\r\n  }\r\n\r\n  /**\r\n   * Sets the layer to be rendered on top of other layers on a map. The map will\r\n   * not manage this layer in its layers collection, and the callback in\r\n   * {@link module:ol/Map~Map#forEachLayerAtPixel} will receive `null` as layer. This\r\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\r\n   * use `#setMap(null)`.\r\n   *\r\n   * To add the layer to a map and have it managed by the map, use\r\n   * {@link module:ol/Map~Map#addLayer} instead.\r\n   * @param {import(\"../PluggableMap.js\").default|null} map Map.\r\n   * @api\r\n   */\r\n  setMap(map) {\r\n    if (this.mapPrecomposeKey_) {\r\n      unlistenByKey(this.mapPrecomposeKey_);\r\n      this.mapPrecomposeKey_ = null;\r\n    }\r\n    if (!map) {\r\n      this.changed();\r\n    }\r\n    if (this.mapRenderKey_) {\r\n      unlistenByKey(this.mapRenderKey_);\r\n      this.mapRenderKey_ = null;\r\n    }\r\n    if (map) {\r\n      this.mapPrecomposeKey_ = listen(\r\n        map,\r\n        RenderEventType.PRECOMPOSE,\r\n        function (evt) {\r\n          const renderEvent =\r\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\r\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\r\n          const layerState = this.getLayerState(false);\r\n          // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.\r\n          assert(\r\n            !layerStatesArray.some(function (arrayLayerState) {\r\n              return arrayLayerState.layer === layerState.layer;\r\n            }),\r\n            67\r\n          );\r\n          layerStatesArray.push(layerState);\r\n        },\r\n        this\r\n      );\r\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the layer source.\r\n   * @param {SourceType|null} source The layer source.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setSource(source) {\r\n    this.set(LayerProperty.SOURCE, source);\r\n  }\r\n\r\n  /**\r\n   * Get the renderer for this layer.\r\n   * @return {RendererType} The layer renderer.\r\n   */\r\n  getRenderer() {\r\n    if (!this.renderer_) {\r\n      this.renderer_ = this.createRenderer();\r\n    }\r\n    return this.renderer_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The layer has a renderer.\r\n   */\r\n  hasRenderer() {\r\n    return !!this.renderer_;\r\n  }\r\n\r\n  /**\r\n   * Create a renderer for this layer.\r\n   * @return {RendererType} A layer renderer.\r\n   * @protected\r\n   */\r\n  createRenderer() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  disposeInternal() {\r\n    if (this.renderer_) {\r\n      this.renderer_.dispose();\r\n      delete this.renderer_;\r\n    }\r\n\r\n    this.setSource(null);\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\n/**\r\n * Return `true` if the layer is visible and if the provided view state\r\n * has resolution and zoom levels that are in range of the layer's min/max.\r\n * @param {State} layerState Layer state.\r\n * @param {import(\"../View.js\").State} viewState View state.\r\n * @return {boolean} The layer is visible at the given view state.\r\n */\r\nexport function inView(layerState, viewState) {\r\n  if (!layerState.visible) {\r\n    return false;\r\n  }\r\n  const resolution = viewState.resolution;\r\n  if (\r\n    resolution < layerState.minResolution ||\r\n    resolution >= layerState.maxResolution\r\n  ) {\r\n    return false;\r\n  }\r\n  const zoom = viewState.zoom;\r\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\r\n}\r\n\r\nexport default Layer;\r\n", "/**\r\n * @module ol/renderer/Layer\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport Observable from '../Observable.js';\r\nimport SourceState from '../source/State.js';\r\nimport {abstract} from '../util.js';\r\n\r\n/**\r\n * @template {import(\"../layer/Layer.js\").default} LayerType\r\n */\r\nclass LayerRenderer extends Observable {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\r\n  constructor(layer) {\r\n    super();\r\n\r\n    /**\r\n     * The renderer is initialized and ready to render.\r\n     * @type {boolean}\r\n     */\r\n    this.ready = true;\r\n\r\n    /** @private */\r\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {LayerType}\r\n     */\r\n    this.layer_ = layer;\r\n\r\n    /**\r\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\r\n     */\r\n    this.declutterExecutorGroup = null;\r\n  }\r\n\r\n  /**\r\n   * Asynchronous layer level hit detection.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\r\n   * an array of features.\r\n   */\r\n  getFeatures(pixel) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\r\n  getData(pixel) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @abstract\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\r\n  prepareFrame(frameState) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @abstract\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   */\r\n  renderFrame(frameState, target) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @param {import(\"../Tile.js\").default} tile Tile.\r\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\r\n   */\r\n  loadedTileCallback(tiles, zoom, tile) {\r\n    if (!tiles[zoom]) {\r\n      tiles[zoom] = {};\r\n    }\r\n    tiles[zoom][tile.tileCoord.toString()] = tile;\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Create a function that adds loaded tiles to the tile lookup.\r\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\r\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\r\n   * @protected\r\n   */\r\n  createLoadedTileFinder(source, projection, tiles) {\r\n    return (\r\n      /**\r\n       * @param {number} zoom Zoom level.\r\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n       * @return {boolean} The tile range is fully loaded.\r\n       * @this {LayerRenderer}\r\n       */\r\n      function (zoom, tileRange) {\r\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\r\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\r\n      }.bind(this)\r\n    );\r\n  }\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\r\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\r\n  forEachFeatureAtCoordinate(\r\n    coordinate,\r\n    frameState,\r\n    hitTolerance,\r\n    callback,\r\n    matches\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\r\n   *    location, null will be returned.  If there is data, but pixel values cannot be\r\n   *    returned, and empty array will be returned.\r\n   */\r\n  getDataAtPixel(pixel, frameState, hitTolerance) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @return {LayerType} Layer.\r\n   */\r\n  getLayer() {\r\n    return this.layer_;\r\n  }\r\n\r\n  /**\r\n   * Perform action necessary to get the layer rendered after new fonts have loaded\r\n   * @abstract\r\n   */\r\n  handleFontsChanged() {}\r\n\r\n  /**\r\n   * Handle changes in image state.\r\n   * @param {import(\"../events/Event.js\").default} event Image change event.\r\n   * @private\r\n   */\r\n  handleImageChange_(event) {\r\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\r\n    if (image.getState() === ImageState.LOADED) {\r\n      this.renderIfReadyAndVisible();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load the image if not already loaded, and register the image change\r\n   * listener if needed.\r\n   * @param {import(\"../ImageBase.js\").default} image Image.\r\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\r\n   * @protected\r\n   */\r\n  loadImage(image) {\r\n    let imageState = image.getState();\r\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\r\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\r\n    }\r\n    if (imageState == ImageState.IDLE) {\r\n      image.load();\r\n      imageState = image.getState();\r\n    }\r\n    return imageState == ImageState.LOADED;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  renderIfReadyAndVisible() {\r\n    const layer = this.getLayer();\r\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\r\n      layer.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  disposeInternal() {\r\n    delete this.layer_;\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default LayerRenderer;\r\n", "/**\r\n * @module ol/render/Event\r\n */\r\n\r\nimport Event from '../events/Event.js';\r\n\r\nclass RenderEvent extends Event {\r\n  /**\r\n   * @param {import(\"./EventType.js\").default} type Type.\r\n   * @param {import(\"../transform.js\").Transform} [opt_inversePixelTransform] Transform for\r\n   *     CSS pixels to rendered pixels.\r\n   * @param {import(\"../PluggableMap.js\").FrameState} [opt_frameState] Frame state.\r\n   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [opt_context] Context.\r\n   */\r\n  constructor(type, opt_inversePixelTransform, opt_frameState, opt_context) {\r\n    super(type);\r\n\r\n    /**\r\n     * Transform from CSS pixels (relative to the top-left corner of the map viewport)\r\n     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.\r\n     * @type {import(\"../transform.js\").Transform|undefined}\r\n     * @api\r\n     */\r\n    this.inversePixelTransform = opt_inversePixelTransform;\r\n\r\n    /**\r\n     * An object representing the current render frame state.\r\n     * @type {import(\"../PluggableMap.js\").FrameState|undefined}\r\n     * @api\r\n     */\r\n    this.frameState = opt_frameState;\r\n\r\n    /**\r\n     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,\r\n     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL\r\n     * context.\r\n     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}\r\n     * @api\r\n     */\r\n    this.context = opt_context;\r\n  }\r\n}\r\n\r\nexport default RenderEvent;\r\n", "/**\r\n * @module ol/renderer/canvas/Layer\r\n */\r\nimport LayerRenderer from '../Layer.js';\r\nimport RenderEvent from '../../render/Event.js';\r\nimport RenderEventType from '../../render/EventType.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../../transform.js';\r\nimport {asArray} from '../../color.js';\r\nimport {\r\n  containsCoordinate,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n} from '../../extent.js';\r\nimport {createCanvasContext2D} from '../../dom.js';\r\nimport {equals} from '../../array.js';\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D}\r\n */\r\nlet pixelContext = null;\r\n\r\nfunction createPixelContext() {\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = 1;\r\n  canvas.height = 1;\r\n  pixelContext = canvas.getContext('2d');\r\n}\r\n\r\n/**\r\n * @abstract\r\n * @template {import(\"../../layer/Layer.js\").default} LayerType\r\n * @extends {LayerRenderer<LayerType>}\r\n */\r\nclass CanvasLayerRenderer extends LayerRenderer {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\r\n  constructor(layer) {\r\n    super(layer);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {HTMLElement}\r\n     */\r\n    this.container = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedResolution;\r\n\r\n    /**\r\n     * A temporary transform.  The values in this transform should only be used in a\r\n     * function that sets the values.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.tempTransform = createTransform();\r\n\r\n    /**\r\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\r\n     * be set when rendering a frame and may be used by other functions after rendering.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.pixelTransform = createTransform();\r\n\r\n    /**\r\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\r\n     * be set when rendering a frame and may be used by other functions after rendering.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.inversePixelTransform = createTransform();\r\n\r\n    /**\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.context = null;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.containerReused = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.pixelContext_ = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../PluggableMap.js\").FrameState|null}\r\n     */\r\n    this.frameState = null;\r\n  }\r\n\r\n  /**\r\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\r\n   * @param {number} col The column index.\r\n   * @param {number} row The row index.\r\n   * @return {Uint8ClampedArray|null} The image data.\r\n   */\r\n  getImageData(image, col, row) {\r\n    if (!pixelContext) {\r\n      createPixelContext();\r\n    }\r\n    pixelContext.clearRect(0, 0, 1, 1);\r\n\r\n    let data;\r\n    try {\r\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\r\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\r\n    } catch (err) {\r\n      return null;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.\r\n   * @return {string} Background color.\r\n   */\r\n  getBackground(frameState) {\r\n    const layer = this.getLayer();\r\n    let background = layer.getBackground();\r\n    if (typeof background === 'function') {\r\n      background = background(frameState.viewState.resolution);\r\n    }\r\n    return background || undefined;\r\n  }\r\n\r\n  /**\r\n   * Get a rendering container from an existing target, if compatible.\r\n   * @param {HTMLElement} target Potential render target.\r\n   * @param {string} transform CSS Transform.\r\n   * @param {number} opacity Opacity.\r\n   * @param {string} [opt_backgroundColor] Background color.\r\n   */\r\n  useContainer(target, transform, opacity, opt_backgroundColor) {\r\n    const layerClassName = this.getLayer().getClassName();\r\n    let container, context;\r\n    if (\r\n      target &&\r\n      target.className === layerClassName &&\r\n      target.style.opacity === '' &&\r\n      opacity === 1 &&\r\n      (!opt_backgroundColor ||\r\n        (target.style.backgroundColor &&\r\n          equals(\r\n            asArray(target.style.backgroundColor),\r\n            asArray(opt_backgroundColor)\r\n          )))\r\n    ) {\r\n      const canvas = target.firstElementChild;\r\n      if (canvas instanceof HTMLCanvasElement) {\r\n        context = canvas.getContext('2d');\r\n      }\r\n    }\r\n    if (context && context.canvas.style.transform === transform) {\r\n      // Container of the previous layer renderer can be used.\r\n      this.container = target;\r\n      this.context = context;\r\n      this.containerReused = true;\r\n    } else if (this.containerReused) {\r\n      // Previously reused container cannot be used any more.\r\n      this.container = null;\r\n      this.context = null;\r\n      this.containerReused = false;\r\n    }\r\n    if (!this.container) {\r\n      container = document.createElement('div');\r\n      container.className = layerClassName;\r\n      let style = container.style;\r\n      style.position = 'absolute';\r\n      style.width = '100%';\r\n      style.height = '100%';\r\n      if (opt_backgroundColor) {\r\n        style.backgroundColor = opt_backgroundColor;\r\n      }\r\n      context = createCanvasContext2D();\r\n      const canvas = context.canvas;\r\n      container.appendChild(canvas);\r\n      style = canvas.style;\r\n      style.position = 'absolute';\r\n      style.left = '0';\r\n      style.transformOrigin = 'top left';\r\n      this.container = container;\r\n      this.context = context;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\r\n   * @protected\r\n   */\r\n  clipUnrotated(context, frameState, extent) {\r\n    const topLeft = getTopLeft(extent);\r\n    const topRight = getTopRight(extent);\r\n    const bottomRight = getBottomRight(extent);\r\n    const bottomLeft = getBottomLeft(extent);\r\n\r\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\r\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\r\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\r\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\r\n\r\n    const inverted = this.inversePixelTransform;\r\n    applyTransform(inverted, topLeft);\r\n    applyTransform(inverted, topRight);\r\n    applyTransform(inverted, bottomRight);\r\n    applyTransform(inverted, bottomLeft);\r\n\r\n    context.save();\r\n    context.beginPath();\r\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\r\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\r\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\r\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\r\n    context.clip();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @private\r\n   */\r\n  dispatchRenderEvent_(type, context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(type)) {\r\n      const event = new RenderEvent(\r\n        type,\r\n        this.inversePixelTransform,\r\n        frameState,\r\n        context\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  preRender(context, frameState) {\r\n    this.frameState = frameState;\r\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  postRender(context, frameState) {\r\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * Creates a transform for rendering to an element that will be rotated after rendering.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} rotation Rotation.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} width Width of the rendered element (in pixels).\r\n   * @param {number} height Height of the rendered element (in pixels).\r\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\r\n   * @protected\r\n   * @return {!import(\"../../transform.js\").Transform} Transform.\r\n   */\r\n  getRenderTransform(\r\n    center,\r\n    resolution,\r\n    rotation,\r\n    pixelRatio,\r\n    width,\r\n    height,\r\n    offsetX\r\n  ) {\r\n    const dx1 = width / 2;\r\n    const dy1 = height / 2;\r\n    const sx = pixelRatio / resolution;\r\n    const sy = -sx;\r\n    const dx2 = -center[0] + offsetX;\r\n    const dy2 = -center[1];\r\n    return composeTransform(\r\n      this.tempTransform,\r\n      dx1,\r\n      dy1,\r\n      sx,\r\n      sy,\r\n      -rotation,\r\n      dx2,\r\n      dy2\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\r\n   *    location, null will be returned.  If there is data, but pixel values cannot be\r\n   *    returned, and empty array will be returned.\r\n   */\r\n  getDataAtPixel(pixel, frameState, hitTolerance) {\r\n    const renderPixel = applyTransform(\r\n      this.inversePixelTransform,\r\n      pixel.slice()\r\n    );\r\n    const context = this.context;\r\n\r\n    const layer = this.getLayer();\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      const renderCoordinate = applyTransform(\r\n        frameState.pixelToCoordinateTransform,\r\n        pixel.slice()\r\n      );\r\n\r\n      /** get only data inside of the layer extent */\r\n      if (!containsCoordinate(layerExtent, renderCoordinate)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const x = Math.round(renderPixel[0]);\r\n    const y = Math.round(renderPixel[1]);\r\n    let pixelContext = this.pixelContext_;\r\n    if (!pixelContext) {\r\n      const pixelCanvas = document.createElement('canvas');\r\n      pixelCanvas.width = 1;\r\n      pixelCanvas.height = 1;\r\n      pixelContext = pixelCanvas.getContext('2d');\r\n      this.pixelContext_ = pixelContext;\r\n    }\r\n    pixelContext.clearRect(0, 0, 1, 1);\r\n    let data;\r\n    try {\r\n      pixelContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);\r\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\r\n    } catch (err) {\r\n      if (err.name === 'SecurityError') {\r\n        // tainted canvas, we assume there is data at the given pixel (although there might not be)\r\n        this.pixelContext_ = null;\r\n        return new Uint8Array();\r\n      }\r\n      return data;\r\n    }\r\n\r\n    if (data[3] === 0) {\r\n      return null;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  disposeInternal() {\r\n    delete this.frameState;\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default CanvasLayerRenderer;\r\n"],
  "mappings": "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",
  "names": ["BaseLayer", "EventType_default", "__extends", "Layer", "EventType_default", "__extends", "LayerRenderer", "Layer_default", "__extends", "RenderEvent", "Event_default", "__extends", "CanvasLayerRenderer", "Event_default", "EventType_default", "pixelContext", "Layer_default"]
}
