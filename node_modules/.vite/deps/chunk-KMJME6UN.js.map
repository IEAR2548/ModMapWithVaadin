{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/gestures.js"],
  "sourcesContent": ["/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/* eslint-disable @typescript-eslint/no-use-before-define */\r\n\r\n/**\r\n * @fileoverview\r\n *\r\n * Module for adding listeners to a node for the following normalized\r\n * cross-platform \"gesture\" events:\r\n * - `down` - mouse or touch went down\r\n * - `up` - mouse or touch went up\r\n * - `tap` - mouse click or finger tap\r\n * - `track` - mouse drag or touch move\r\n *\r\n * @summary Module for adding cross-platform gesture event listeners.\r\n */\r\n\r\nimport { microTask } from './async.js';\r\n\r\nconst passiveTouchGestures = false;\r\nconst wrap = (node) => node;\r\n\r\n// Detect native touch action support\r\nconst HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\r\nconst GESTURE_KEY = '__polymerGestures';\r\nconst HANDLED_OBJ = '__polymerGesturesHandled';\r\nconst TOUCH_ACTION = '__polymerGesturesTouchAction';\r\n// Radius for tap and track\r\nconst TAP_DISTANCE = 25;\r\nconst TRACK_DISTANCE = 5;\r\n// Number of last N track positions to keep\r\nconst TRACK_LENGTH = 2;\r\n\r\nconst MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\r\n// An array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\r\nconst MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\r\nconst MOUSE_HAS_BUTTONS = (function () {\r\n  try {\r\n    return new MouseEvent('test', { buttons: 1 }).buttons === 1;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n})();\r\n\r\n/**\r\n * @param {string} name Possible mouse event name\r\n * @return {boolean} true if mouse event, false if not\r\n */\r\nfunction isMouseEvent(name) {\r\n  return MOUSE_EVENTS.indexOf(name) > -1;\r\n}\r\n\r\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\r\n// check for passive event listeners\r\nlet supportsPassive = false;\r\n(function () {\r\n  try {\r\n    const opts = Object.defineProperty({}, 'passive', {\r\n      // eslint-disable-next-line getter-return\r\n      get() {\r\n        supportsPassive = true;\r\n      },\r\n    });\r\n    window.addEventListener('test', null, opts);\r\n    window.removeEventListener('test', null, opts);\r\n  } catch (_) {}\r\n})();\r\n\r\n/**\r\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\r\n *\r\n * @param {string} eventName Event name to determine if `{passive}` option is\r\n *   needed\r\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\r\n *   and removeEventListener\r\n */\r\nfunction PASSIVE_TOUCH(eventName) {\r\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\r\n    return;\r\n  }\r\n  if (HAS_NATIVE_TA && supportsPassive && passiveTouchGestures) {\r\n    return { passive: true };\r\n  }\r\n}\r\n\r\n// Check for touch-only devices\r\nconst IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u);\r\n\r\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\r\n/** @type {!Object<boolean>} */\r\nconst canBeDisabled = {\r\n  button: true,\r\n  command: true,\r\n  fieldset: true,\r\n  input: true,\r\n  keygen: true,\r\n  optgroup: true,\r\n  option: true,\r\n  select: true,\r\n  textarea: true,\r\n};\r\n\r\n/**\r\n * @param {MouseEvent} ev event to test for left mouse button down\r\n * @return {boolean} has left mouse button down\r\n */\r\nfunction hasLeftMouseButton(ev) {\r\n  const type = ev.type;\r\n  // Exit early if the event is not a mouse event\r\n  if (!isMouseEvent(type)) {\r\n    return false;\r\n  }\r\n  // Ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\r\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\r\n  if (type === 'mousemove') {\r\n    // Allow undefined for testing events\r\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\r\n    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\r\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\r\n    }\r\n    // Buttons is a bitmask, check that the left button bit is set (1)\r\n    return Boolean(buttons & 1);\r\n  }\r\n  // Allow undefined for testing events\r\n  const button = ev.button === undefined ? 0 : ev.button;\r\n  // Ev.button is 0 in mousedown/mouseup/click for left button activation\r\n  return button === 0;\r\n}\r\n\r\nfunction isSyntheticClick(ev) {\r\n  if (ev.type === 'click') {\r\n    // Ev.detail is 0 for HTMLElement.click in most browsers\r\n    if (ev.detail === 0) {\r\n      return true;\r\n    }\r\n    // In the worst case, check that the x/y position of the click is within\r\n    // the bounding box of the target of the event\r\n    // Thanks IE 10 >:(\r\n    const t = _findOriginalTarget(ev);\r\n    // Make sure the target of the event is an element so we can use getBoundingClientRect,\r\n    // if not, just assume it is a synthetic click\r\n    if (!t.nodeType || /** @type {Element} */ (t).nodeType !== Node.ELEMENT_NODE) {\r\n      return true;\r\n    }\r\n    const bcr = /** @type {Element} */ (t).getBoundingClientRect();\r\n    // Use page x/y to account for scrolling\r\n    const x = ev.pageX,\r\n      y = ev.pageY;\r\n    // Ev is a synthetic click if the position is outside the bounding box of the target\r\n    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);\r\n  }\r\n  return false;\r\n}\r\n\r\nconst POINTERSTATE = {\r\n  mouse: {\r\n    target: null,\r\n    mouseIgnoreJob: null,\r\n  },\r\n  touch: {\r\n    x: 0,\r\n    y: 0,\r\n    id: -1,\r\n    scrollDecided: false,\r\n  },\r\n};\r\n\r\nfunction firstTouchAction(ev) {\r\n  let ta = 'auto';\r\n  const path = getComposedPath(ev);\r\n  for (let i = 0, n; i < path.length; i++) {\r\n    n = path[i];\r\n    if (n[TOUCH_ACTION]) {\r\n      ta = n[TOUCH_ACTION];\r\n      break;\r\n    }\r\n  }\r\n  return ta;\r\n}\r\n\r\nfunction trackDocument(stateObj, movefn, upfn) {\r\n  stateObj.movefn = movefn;\r\n  stateObj.upfn = upfn;\r\n  document.addEventListener('mousemove', movefn);\r\n  document.addEventListener('mouseup', upfn);\r\n}\r\n\r\nfunction untrackDocument(stateObj) {\r\n  document.removeEventListener('mousemove', stateObj.movefn);\r\n  document.removeEventListener('mouseup', stateObj.upfn);\r\n  stateObj.movefn = null;\r\n  stateObj.upfn = null;\r\n}\r\n\r\n/**\r\n * Returns the composedPath for the given event.\r\n * @param {Event} event to process\r\n * @return {!Array<!EventTarget>} Path of the event\r\n */\r\nconst getComposedPath =\r\n  window.ShadyDOM && window.ShadyDOM.noPatch\r\n    ? window.ShadyDOM.composedPath\r\n    : (event) => (event.composedPath && event.composedPath()) || [];\r\n\r\n/** @type {!Object<string, !GestureRecognizer>} */\r\nexport const gestures = {};\r\n\r\n/** @type {!Array<!GestureRecognizer>} */\r\nexport const recognizers = [];\r\n\r\n/**\r\n * Finds the element rendered on the screen at the provided coordinates.\r\n *\r\n * Similar to `document.elementFromPoint`, but pierces through\r\n * shadow roots.\r\n *\r\n * @param {number} x Horizontal pixel coordinate\r\n * @param {number} y Vertical pixel coordinate\r\n * @return {Element} Returns the deepest shadowRoot inclusive element\r\n * found at the screen position given.\r\n */\r\nexport function deepTargetFind(x, y) {\r\n  let node = document.elementFromPoint(x, y);\r\n  let next = node;\r\n  // This code path is only taken when native ShadowDOM is used\r\n  // if there is a shadowroot, it may have a node at x/y\r\n  // if there is not a shadowroot, exit the loop\r\n  while (next && next.shadowRoot && !window.ShadyDOM) {\r\n    // If there is a node at x/y in the shadowroot, look deeper\r\n    const oldNext = next;\r\n    next = next.shadowRoot.elementFromPoint(x, y);\r\n    // On Safari, elementFromPoint may return the shadowRoot host\r\n    if (oldNext === next) {\r\n      break;\r\n    }\r\n    if (next) {\r\n      node = next;\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\n/**\r\n * A cheaper check than ev.composedPath()[0];\r\n *\r\n * @private\r\n * @param {Event|Touch} ev Event.\r\n * @return {EventTarget} Returns the event target.\r\n */\r\nfunction _findOriginalTarget(ev) {\r\n  const path = getComposedPath(/** @type {?Event} */ (ev));\r\n  // It shouldn't be, but sometimes path is empty (window on Safari).\r\n  return path.length > 0 ? path[0] : ev.target;\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {Event} ev Event.\r\n * @return {void}\r\n */\r\nfunction _handleNative(ev) {\r\n  const type = ev.type;\r\n  const node = ev.currentTarget;\r\n  const gobj = node[GESTURE_KEY];\r\n  if (!gobj) {\r\n    return;\r\n  }\r\n  const gs = gobj[type];\r\n  if (!gs) {\r\n    return;\r\n  }\r\n  if (!ev[HANDLED_OBJ]) {\r\n    ev[HANDLED_OBJ] = {};\r\n    if (type.startsWith('touch')) {\r\n      const t = ev.changedTouches[0];\r\n      if (type === 'touchstart') {\r\n        // Only handle the first finger\r\n        if (ev.touches.length === 1) {\r\n          POINTERSTATE.touch.id = t.identifier;\r\n        }\r\n      }\r\n      if (POINTERSTATE.touch.id !== t.identifier) {\r\n        return;\r\n      }\r\n      if (!HAS_NATIVE_TA) {\r\n        if (type === 'touchstart' || type === 'touchmove') {\r\n          _handleTouchAction(ev);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  const handled = ev[HANDLED_OBJ];\r\n  // Used to ignore synthetic mouse events\r\n  if (handled.skip) {\r\n    return;\r\n  }\r\n  // Reset recognizer state\r\n  for (let i = 0, r; i < recognizers.length; i++) {\r\n    r = recognizers[i];\r\n    if (gs[r.name] && !handled[r.name]) {\r\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\r\n        r.reset();\r\n      }\r\n    }\r\n  }\r\n  // Enforce gesture recognizer order\r\n  for (let i = 0, r; i < recognizers.length; i++) {\r\n    r = recognizers[i];\r\n    if (gs[r.name] && !handled[r.name]) {\r\n      handled[r.name] = true;\r\n      r[type](ev);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {TouchEvent} ev Event.\r\n * @return {void}\r\n */\r\nfunction _handleTouchAction(ev) {\r\n  const t = ev.changedTouches[0];\r\n  const type = ev.type;\r\n  if (type === 'touchstart') {\r\n    POINTERSTATE.touch.x = t.clientX;\r\n    POINTERSTATE.touch.y = t.clientY;\r\n    POINTERSTATE.touch.scrollDecided = false;\r\n  } else if (type === 'touchmove') {\r\n    if (POINTERSTATE.touch.scrollDecided) {\r\n      return;\r\n    }\r\n    POINTERSTATE.touch.scrollDecided = true;\r\n    const ta = firstTouchAction(ev);\r\n    let shouldPrevent = false;\r\n    const dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\r\n    const dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\r\n    if (!ev.cancelable) {\r\n      // Scrolling is happening\r\n    } else if (ta === 'none') {\r\n      shouldPrevent = true;\r\n    } else if (ta === 'pan-x') {\r\n      shouldPrevent = dy > dx;\r\n    } else if (ta === 'pan-y') {\r\n      shouldPrevent = dx > dy;\r\n    }\r\n    if (shouldPrevent) {\r\n      ev.preventDefault();\r\n    } else {\r\n      prevent('track');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Adds an event listener to a node for the given gesture type.\r\n *\r\n * @param {!EventTarget} node Node to add listener on\r\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\r\n * @param {!function(!Event):void} handler Event listener function to call\r\n * @return {boolean} Returns true if a gesture event listener was added.\r\n */\r\nexport function addListener(node, evType, handler) {\r\n  if (gestures[evType]) {\r\n    _add(node, evType, handler);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Removes an event listener from a node for the given gesture type.\r\n *\r\n * @param {!EventTarget} node Node to remove listener from\r\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\r\n * @param {!function(!Event):void} handler Event listener function previously passed to\r\n *  `addListener`.\r\n * @return {boolean} Returns true if a gesture event listener was removed.\r\n */\r\nexport function removeListener(node, evType, handler) {\r\n  if (gestures[evType]) {\r\n    _remove(node, evType, handler);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Automate the event listeners for the native events\r\n *\r\n * @private\r\n * @param {!EventTarget} node Node on which to add the event.\r\n * @param {string} evType Event type to add.\r\n * @param {function(!Event)} handler Event handler function.\r\n * @return {void}\r\n */\r\nfunction _add(node, evType, handler) {\r\n  const recognizer = gestures[evType];\r\n  const deps = recognizer.deps;\r\n  const name = recognizer.name;\r\n  let gobj = node[GESTURE_KEY];\r\n  if (!gobj) {\r\n    node[GESTURE_KEY] = gobj = {};\r\n  }\r\n  for (let i = 0, dep, gd; i < deps.length; i++) {\r\n    dep = deps[i];\r\n    // Don't add mouse handlers on iOS because they cause gray selection overlays\r\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\r\n      continue;\r\n    }\r\n    gd = gobj[dep];\r\n    if (!gd) {\r\n      gobj[dep] = gd = { _count: 0 };\r\n    }\r\n    if (gd._count === 0) {\r\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\r\n    }\r\n    gd[name] = (gd[name] || 0) + 1;\r\n    gd._count = (gd._count || 0) + 1;\r\n  }\r\n  node.addEventListener(evType, handler);\r\n  if (recognizer.touchAction) {\r\n    setTouchAction(node, recognizer.touchAction);\r\n  }\r\n}\r\n\r\n/**\r\n * Automate event listener removal for native events\r\n *\r\n * @private\r\n * @param {!EventTarget} node Node on which to remove the event.\r\n * @param {string} evType Event type to remove.\r\n * @param {function(!Event): void} handler Event handler function.\r\n * @return {void}\r\n */\r\nfunction _remove(node, evType, handler) {\r\n  const recognizer = gestures[evType];\r\n  const deps = recognizer.deps;\r\n  const name = recognizer.name;\r\n  const gobj = node[GESTURE_KEY];\r\n  if (gobj) {\r\n    for (let i = 0, dep, gd; i < deps.length; i++) {\r\n      dep = deps[i];\r\n      gd = gobj[dep];\r\n      if (gd && gd[name]) {\r\n        gd[name] = (gd[name] || 1) - 1;\r\n        gd._count = (gd._count || 1) - 1;\r\n        if (gd._count === 0) {\r\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  node.removeEventListener(evType, handler);\r\n}\r\n\r\n/**\r\n * Registers a new gesture event recognizer for adding new custom\r\n * gesture event types.\r\n *\r\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\r\n * @return {void}\r\n */\r\nexport function register(recog) {\r\n  recognizers.push(recog);\r\n  recog.emits.forEach((emit) => {\r\n    gestures[emit] = recog;\r\n  });\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {string} evName Event name.\r\n * @return {Object} Returns the gesture for the given event name.\r\n */\r\nfunction _findRecognizerByEvent(evName) {\r\n  for (let i = 0, r; i < recognizers.length; i++) {\r\n    r = recognizers[i];\r\n    for (let j = 0, n; j < r.emits.length; j++) {\r\n      n = r.emits[j];\r\n      if (n === evName) {\r\n        return r;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Sets scrolling direction on node.\r\n *\r\n * This value is checked on first move, thus it should be called prior to\r\n * adding event listeners.\r\n *\r\n * @param {!EventTarget} node Node to set touch action setting on\r\n * @param {string} value Touch action value\r\n * @return {void}\r\n */\r\nexport function setTouchAction(node, value) {\r\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\r\n    // NOTE: add touchAction async so that events can be added in\r\n    // custom element constructors. Otherwise we run afoul of custom\r\n    // elements restriction against settings attributes (style) in the\r\n    // constructor.\r\n    microTask.run(() => {\r\n      node.style.touchAction = value;\r\n    });\r\n  }\r\n  node[TOUCH_ACTION] = value;\r\n}\r\n\r\n/**\r\n * Dispatches an event on the `target` element of `type` with the given\r\n * `detail`.\r\n * @private\r\n * @param {!EventTarget} target The element on which to fire an event.\r\n * @param {string} type The type of event to fire.\r\n * @param {!Object=} detail The detail object to populate on the event.\r\n * @return {void}\r\n */\r\nfunction _fire(target, type, detail) {\r\n  const ev = new Event(type, { bubbles: true, cancelable: true, composed: true });\r\n  ev.detail = detail;\r\n  wrap(/** @type {!Node} */ (target)).dispatchEvent(ev);\r\n  // Forward `preventDefault` in a clean way\r\n  if (ev.defaultPrevented) {\r\n    const preventer = detail.preventer || detail.sourceEvent;\r\n    if (preventer && preventer.preventDefault) {\r\n      preventer.preventDefault();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Prevents the dispatch and default action of the given event name.\r\n *\r\n * @param {string} evName Event name.\r\n * @return {void}\r\n */\r\nexport function prevent(evName) {\r\n  const recognizer = _findRecognizerByEvent(evName);\r\n  if (recognizer.info) {\r\n    recognizer.info.prevent = true;\r\n  }\r\n}\r\n\r\nregister({\r\n  name: 'downup',\r\n  deps: ['mousedown', 'touchstart', 'touchend'],\r\n  flow: {\r\n    start: ['mousedown', 'touchstart'],\r\n    end: ['mouseup', 'touchend'],\r\n  },\r\n  emits: ['down', 'up'],\r\n\r\n  info: {\r\n    movefn: null,\r\n    upfn: null,\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @return {void}\r\n   */\r\n  reset() {\r\n    untrackDocument(this.info);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  mousedown(e) {\r\n    if (!hasLeftMouseButton(e)) {\r\n      return;\r\n    }\r\n    const t = _findOriginalTarget(e);\r\n    const self = this;\r\n    const movefn = (e) => {\r\n      if (!hasLeftMouseButton(e)) {\r\n        downupFire('up', t, e);\r\n        untrackDocument(self.info);\r\n      }\r\n    };\r\n    const upfn = (e) => {\r\n      if (hasLeftMouseButton(e)) {\r\n        downupFire('up', t, e);\r\n      }\r\n      untrackDocument(self.info);\r\n    };\r\n    trackDocument(this.info, movefn, upfn);\r\n    downupFire('down', t, e);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchstart(e) {\r\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchend(e) {\r\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\r\n  },\r\n});\r\n\r\n/**\r\n * @param {string} type\r\n * @param {EventTarget} target\r\n * @param {Event|Touch} event\r\n * @param {Event=} preventer\r\n * @return {void}\r\n */\r\nfunction downupFire(type, target, event, preventer) {\r\n  if (!target) {\r\n    return;\r\n  }\r\n  _fire(target, type, {\r\n    x: event.clientX,\r\n    y: event.clientY,\r\n    sourceEvent: event,\r\n    preventer,\r\n    prevent(e) {\r\n      return prevent(e);\r\n    },\r\n  });\r\n}\r\n\r\nregister({\r\n  name: 'track',\r\n  touchAction: 'none',\r\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\r\n  flow: {\r\n    start: ['mousedown', 'touchstart'],\r\n    end: ['mouseup', 'touchend'],\r\n  },\r\n  emits: ['track'],\r\n\r\n  info: {\r\n    x: 0,\r\n    y: 0,\r\n    state: 'start',\r\n    started: false,\r\n    moves: [],\r\n    /** @this {GestureInfo} */\r\n    addMove(move) {\r\n      if (this.moves.length > TRACK_LENGTH) {\r\n        this.moves.shift();\r\n      }\r\n      this.moves.push(move);\r\n    },\r\n    movefn: null,\r\n    upfn: null,\r\n    prevent: false,\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @return {void}\r\n   */\r\n  reset() {\r\n    this.info.state = 'start';\r\n    this.info.started = false;\r\n    this.info.moves = [];\r\n    this.info.x = 0;\r\n    this.info.y = 0;\r\n    this.info.prevent = false;\r\n    untrackDocument(this.info);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  mousedown(e) {\r\n    if (!hasLeftMouseButton(e)) {\r\n      return;\r\n    }\r\n    const t = _findOriginalTarget(e);\r\n    const self = this;\r\n    const movefn = (e) => {\r\n      const x = e.clientX,\r\n        y = e.clientY;\r\n      if (trackHasMovedEnough(self.info, x, y)) {\r\n        // First move is 'start', subsequent moves are 'move', mouseup is 'end'\r\n        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';\r\n        if (self.info.state === 'start') {\r\n          // If and only if tracking, always prevent tap\r\n          prevent('tap');\r\n        }\r\n        self.info.addMove({ x, y });\r\n        if (!hasLeftMouseButton(e)) {\r\n          // Always fire \"end\"\r\n          self.info.state = 'end';\r\n          untrackDocument(self.info);\r\n        }\r\n        if (t) {\r\n          trackFire(self.info, t, e);\r\n        }\r\n        self.info.started = true;\r\n      }\r\n    };\r\n    const upfn = (e) => {\r\n      if (self.info.started) {\r\n        movefn(e);\r\n      }\r\n\r\n      // Remove the temporary listeners\r\n      untrackDocument(self.info);\r\n    };\r\n    // Add temporary document listeners as mouse retargets\r\n    trackDocument(this.info, movefn, upfn);\r\n    this.info.x = e.clientX;\r\n    this.info.y = e.clientY;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchstart(e) {\r\n    const ct = e.changedTouches[0];\r\n    this.info.x = ct.clientX;\r\n    this.info.y = ct.clientY;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchmove(e) {\r\n    const t = _findOriginalTarget(e);\r\n    const ct = e.changedTouches[0];\r\n    const x = ct.clientX,\r\n      y = ct.clientY;\r\n    if (trackHasMovedEnough(this.info, x, y)) {\r\n      if (this.info.state === 'start') {\r\n        // If and only if tracking, always prevent tap\r\n        prevent('tap');\r\n      }\r\n      this.info.addMove({ x, y });\r\n      trackFire(this.info, t, ct);\r\n      this.info.state = 'track';\r\n      this.info.started = true;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchend(e) {\r\n    const t = _findOriginalTarget(e);\r\n    const ct = e.changedTouches[0];\r\n    // Only trackend if track was started and not aborted\r\n    if (this.info.started) {\r\n      // Reset started state on up\r\n      this.info.state = 'end';\r\n      this.info.addMove({ x: ct.clientX, y: ct.clientY });\r\n      trackFire(this.info, t, ct);\r\n    }\r\n  },\r\n});\r\n\r\n/**\r\n * @param {!GestureInfo} info\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction trackHasMovedEnough(info, x, y) {\r\n  if (info.prevent) {\r\n    return false;\r\n  }\r\n  if (info.started) {\r\n    return true;\r\n  }\r\n  const dx = Math.abs(info.x - x);\r\n  const dy = Math.abs(info.y - y);\r\n  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\r\n}\r\n\r\n/**\r\n * @param {!GestureInfo} info\r\n * @param {?EventTarget} target\r\n * @param {Touch} touch\r\n * @return {void}\r\n */\r\nfunction trackFire(info, target, touch) {\r\n  if (!target) {\r\n    return;\r\n  }\r\n  const secondlast = info.moves[info.moves.length - 2];\r\n  const lastmove = info.moves[info.moves.length - 1];\r\n  const dx = lastmove.x - info.x;\r\n  const dy = lastmove.y - info.y;\r\n  let ddx,\r\n    ddy = 0;\r\n  if (secondlast) {\r\n    ddx = lastmove.x - secondlast.x;\r\n    ddy = lastmove.y - secondlast.y;\r\n  }\r\n  _fire(target, 'track', {\r\n    state: info.state,\r\n    x: touch.clientX,\r\n    y: touch.clientY,\r\n    dx,\r\n    dy,\r\n    ddx,\r\n    ddy,\r\n    sourceEvent: touch,\r\n    hover() {\r\n      return deepTargetFind(touch.clientX, touch.clientY);\r\n    },\r\n  });\r\n}\r\n\r\nregister({\r\n  name: 'tap',\r\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\r\n  flow: {\r\n    start: ['mousedown', 'touchstart'],\r\n    end: ['click', 'touchend'],\r\n  },\r\n  emits: ['tap'],\r\n  info: {\r\n    x: NaN,\r\n    y: NaN,\r\n    prevent: false,\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @return {void}\r\n   */\r\n  reset() {\r\n    this.info.x = NaN;\r\n    this.info.y = NaN;\r\n    this.info.prevent = false;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  mousedown(e) {\r\n    if (hasLeftMouseButton(e)) {\r\n      this.info.x = e.clientX;\r\n      this.info.y = e.clientY;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  click(e) {\r\n    if (hasLeftMouseButton(e)) {\r\n      trackForward(this.info, e);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchstart(e) {\r\n    const touch = e.changedTouches[0];\r\n    this.info.x = touch.clientX;\r\n    this.info.y = touch.clientY;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchend(e) {\r\n    trackForward(this.info, e.changedTouches[0], e);\r\n  },\r\n});\r\n\r\n/**\r\n * @param {!GestureInfo} info\r\n * @param {Event | Touch} e\r\n * @param {Event=} preventer\r\n * @return {void}\r\n */\r\nfunction trackForward(info, e, preventer) {\r\n  const dx = Math.abs(e.clientX - info.x);\r\n  const dy = Math.abs(e.clientY - info.y);\r\n  // Find original target from `preventer` for TouchEvents, or `e` for MouseEvents\r\n  const t = _findOriginalTarget(preventer || e);\r\n  if (!t || (canBeDisabled[/** @type {!HTMLElement} */ (t).localName] && t.hasAttribute('disabled'))) {\r\n    return;\r\n  }\r\n  // Dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\r\n  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {\r\n    // Prevent taps from being generated if an event has canceled them\r\n    if (!info.prevent) {\r\n      _fire(t, 'tap', {\r\n        x: e.clientX,\r\n        y: e.clientY,\r\n        sourceEvent: e,\r\n        preventer,\r\n      });\r\n    }\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["e"]
}
