{
  "version": 3,
  "sources": ["../../@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js", "../../@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\n/**\r\n * @polymerMixin\r\n */\r\nexport const ThemePropertyMixin = (superClass) =>\r\n  class VaadinThemePropertyMixin extends superClass {\r\n    static get properties() {\r\n      return {\r\n        /**\r\n         * Helper property with theme attribute value facilitating propagation\r\n         * in shadow DOM.\r\n         *\r\n         * Enables the component implementation to propagate the `theme`\r\n         * attribute value to the sub-components in Shadow DOM by binding\r\n         * the sub-component's \"theme\" attribute to the `theme` property of\r\n         * the host.\r\n         *\r\n         * **NOTE:** Extending the mixin only provides the property for binding,\r\n         * and does not make the propagation alone.\r\n         *\r\n         * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/styling-components/#sub-components).\r\n         * page for more information.\r\n         *\r\n         * @protected\r\n         */\r\n        _theme: {\r\n          type: String,\r\n          readOnly: true,\r\n        },\r\n      };\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      return [...super.observedAttributes, 'theme'];\r\n    }\r\n\r\n    /** @protected */\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      super.attributeChangedCallback(name, oldValue, newValue);\r\n\r\n      if (name === 'theme') {\r\n        this._set_theme(newValue);\r\n      }\r\n    }\r\n  };\r\n", "/**\r\n * @license\r\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { adoptStyles, css, CSSResult, LitElement, unsafeCSS } from 'lit';\r\nimport { ThemePropertyMixin } from './vaadin-theme-property-mixin.js';\r\n\r\nexport { css, unsafeCSS };\r\n\r\n/**\r\n * @typedef {Object} Theme\r\n * @property {string} themeFor\r\n * @property {CSSResult[]} styles\r\n * @property {string | string[]} [include]\r\n * @property {string} [moduleId]\r\n *\r\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\r\n */\r\n\r\n/**\r\n * @type {Theme[]}\r\n */\r\nconst themeRegistry = [];\r\n\r\n/**\r\n * @type {WeakRef<HTMLElement>[]}\r\n */\r\nconst themableInstances = new Set();\r\n\r\n/**\r\n * @type {string[]}\r\n */\r\nconst themableTagNames = new Set();\r\n\r\n/**\r\n * Check if the custom element type has themes applied.\r\n * @param {Function} elementClass\r\n * @returns {boolean}\r\n */\r\nfunction classHasThemes(elementClass) {\r\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\r\n}\r\n\r\n/**\r\n * Check if the custom element type has themes applied.\r\n * @param {string} tagName\r\n * @returns {boolean}\r\n */\r\nfunction hasThemes(tagName) {\r\n  return classHasThemes(customElements.get(tagName));\r\n}\r\n\r\n/**\r\n * Flattens the styles into a single array of styles.\r\n * @param {CSSResultGroup} styles\r\n * @param {CSSResult[]} result\r\n * @returns {CSSResult[]}\r\n */\r\nfunction flattenStyles(styles = []) {\r\n  return [styles].flat(Infinity).filter((style) => {\r\n    if (style instanceof CSSResult) {\r\n      return true;\r\n    }\r\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\r\n    return false;\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the themeFor string matches the tag name\r\n * @param {string} themeFor\r\n * @param {string} tagName\r\n * @returns {boolean}\r\n */\r\nfunction matchesThemeFor(themeFor, tagName) {\r\n  return (themeFor || '').split(' ').some((themeForToken) => {\r\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`, 'u').test(tagName);\r\n  });\r\n}\r\n\r\n/**\r\n * Returns the CSS text content from an array of CSSResults\r\n * @param {CSSResult[]} styles\r\n * @returns {string}\r\n */\r\nfunction getCssText(styles) {\r\n  return styles.map((style) => style.cssText).join('\\n');\r\n}\r\n\r\nconst STYLE_ID = 'vaadin-themable-mixin-style';\r\n\r\n/**\r\n * Includes the styles to the template.\r\n * @param {CSSResult[]} styles\r\n * @param {HTMLTemplateElement} template\r\n */\r\nfunction addStylesToTemplate(styles, template) {\r\n  const styleEl = document.createElement('style');\r\n  styleEl.id = STYLE_ID;\r\n  styleEl.textContent = getCssText(styles);\r\n  template.content.appendChild(styleEl);\r\n}\r\n\r\n/**\r\n * Dynamically updates the styles of the given component instance.\r\n * @param {HTMLElement} instance\r\n */\r\nfunction updateInstanceStyles(instance) {\r\n  if (!instance.shadowRoot) {\r\n    return;\r\n  }\r\n\r\n  const componentClass = instance.constructor;\r\n\r\n  if (instance instanceof LitElement) {\r\n    // LitElement\r\n\r\n    // The adoptStyles function may fall back to appending style elements to shadow root.\r\n    // Remove them first to avoid duplicates.\r\n    [...instance.shadowRoot.querySelectorAll('style')].forEach((style) => style.remove());\r\n\r\n    // Adopt the updated styles\r\n    adoptStyles(instance.shadowRoot, componentClass.elementStyles);\r\n  } else {\r\n    // PolymerElement\r\n\r\n    // Update style element content in the shadow root\r\n    const style = instance.shadowRoot.getElementById(STYLE_ID);\r\n    const template = componentClass.prototype._template;\r\n    style.textContent = template.content.getElementById(STYLE_ID).textContent;\r\n  }\r\n}\r\n\r\n/**\r\n * Dynamically updates the styles of the instances matching the given component type.\r\n * @param {Function} componentClass\r\n */\r\nfunction updateInstanceStylesOfType(componentClass) {\r\n  // Iterate over component instances and update their styles if needed\r\n  themableInstances.forEach((ref) => {\r\n    const instance = ref.deref();\r\n    if (instance instanceof componentClass) {\r\n      updateInstanceStyles(instance);\r\n    } else if (!instance) {\r\n      // Clean up the weak reference to a GC'd instance\r\n      themableInstances.delete(ref);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Dynamically updates the styles of the given component type.\r\n * @param {Function} componentClass\r\n */\r\nfunction updateComponentStyles(componentClass) {\r\n  if (componentClass.prototype instanceof LitElement) {\r\n    // Update LitElement-based component's elementStyles\r\n    componentClass.elementStyles = componentClass.finalizeStyles(componentClass.styles);\r\n  } else {\r\n    // Update Polymer-based component's template\r\n    const template = componentClass.prototype._template;\r\n    template.content.getElementById(STYLE_ID).textContent = getCssText(componentClass.getStylesForThis());\r\n  }\r\n\r\n  // Update the styles of inheriting types\r\n  themableTagNames.forEach((inheritingTagName) => {\r\n    const inheritingClass = customElements.get(inheritingTagName);\r\n    if (inheritingClass !== componentClass && inheritingClass.prototype instanceof componentClass) {\r\n      updateComponentStyles(inheritingClass);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Check if the component type already has a style matching the given styles.\r\n *\r\n * @param {Function} componentClass\r\n * @param {CSSResultGroup} styles\r\n * @returns {boolean}\r\n */\r\nfunction hasMatchingStyle(componentClass, styles) {\r\n  const themes = componentClass.__themes;\r\n  if (!themes || !styles) {\r\n    return false;\r\n  }\r\n\r\n  return themes.some((theme) =>\r\n    theme.styles.some((themeStyle) => styles.some((style) => style.cssText === themeStyle.cssText)),\r\n  );\r\n}\r\n\r\n/**\r\n * Registers CSS styles for a component type. Make sure to register the styles before\r\n * the first instance of a component of the type is attached to DOM.\r\n *\r\n * @param {string} themeFor The local/tag name of the component type to register the styles for\r\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\r\n * matching themeFor and included in the local scope of each component instance\r\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\r\n * @return {void}\r\n */\r\nexport function registerStyles(themeFor, styles, options = {}) {\r\n  styles = flattenStyles(styles);\r\n\r\n  if (window.Vaadin && window.Vaadin.styleModules) {\r\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\r\n  } else {\r\n    themeRegistry.push({\r\n      themeFor,\r\n      styles,\r\n      include: options.include,\r\n      moduleId: options.moduleId,\r\n    });\r\n  }\r\n\r\n  if (themeFor) {\r\n    // Update styles of the component types that match themeFor and have already been finalized\r\n    themableTagNames.forEach((tagName) => {\r\n      if (matchesThemeFor(themeFor, tagName) && hasThemes(tagName)) {\r\n        const componentClass = customElements.get(tagName);\r\n\r\n        if (hasMatchingStyle(componentClass, styles)) {\r\n          // Show a warning if the component type already has some of the given styles\r\n          console.warn(`Registering styles that already exist for ${tagName}`);\r\n        } else if (!window.Vaadin || !window.Vaadin.suppressPostFinalizeStylesWarning) {\r\n          // Show a warning if the component type has already been finalized\r\n          console.warn(\r\n            `The custom element definition for \"${tagName}\" ` +\r\n              `was finalized before a style module was registered. ` +\r\n              `Ideally, import component specific style modules before ` +\r\n              `importing the corresponding custom element. ` +\r\n              `This warning can be suppressed by setting \"window.Vaadin.suppressPostFinalizeStylesWarning = true\".`,\r\n          );\r\n        }\r\n\r\n        // Update the styles of the component type\r\n        updateComponentStyles(componentClass);\r\n        // Update the styles of the component instances matching the component type\r\n        updateInstanceStylesOfType(componentClass);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Returns all registered themes. By default the themeRegistry is returned as is.\r\n * In case the style-modules adapter is imported, the themes are obtained from there instead\r\n * @returns {Theme[]}\r\n */\r\nfunction getAllThemes() {\r\n  if (window.Vaadin && window.Vaadin.styleModules) {\r\n    return window.Vaadin.styleModules.getAllThemes();\r\n  }\r\n  return themeRegistry;\r\n}\r\n\r\n/**\r\n * Maps the moduleName to an include priority number which is used for\r\n * determining the order in which styles are applied.\r\n * @param {string} moduleName\r\n * @returns {number}\r\n */\r\nfunction getIncludePriority(moduleName = '') {\r\n  let includePriority = 0;\r\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\r\n    includePriority = 1;\r\n  } else if (moduleName.startsWith('vaadin-')) {\r\n    includePriority = 2;\r\n  }\r\n  return includePriority;\r\n}\r\n\r\n/**\r\n * Gets an array of CSSResults matching the include property of the theme.\r\n * @param {Theme} theme\r\n * @returns {CSSResult[]}\r\n */\r\nfunction getIncludedStyles(theme) {\r\n  const includedStyles = [];\r\n  if (theme.include) {\r\n    [].concat(theme.include).forEach((includeModuleId) => {\r\n      const includedTheme = getAllThemes().find((s) => s.moduleId === includeModuleId);\r\n      if (includedTheme) {\r\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\r\n      } else {\r\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\r\n      }\r\n    }, theme.styles);\r\n  }\r\n  return includedStyles;\r\n}\r\n\r\n/**\r\n * Returns an array of themes that should be used for styling a component matching\r\n * the tag name. The array is sorted by the include order.\r\n * @param {string} tagName\r\n * @returns {Theme[]}\r\n */\r\nfunction getThemes(tagName) {\r\n  const defaultModuleName = `${tagName}-default-theme`;\r\n\r\n  const themes = getAllThemes()\r\n    // Filter by matching themeFor properties\r\n    .filter((theme) => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName))\r\n    .map((theme) => ({\r\n      ...theme,\r\n      // Prepend styles from included themes\r\n      styles: [...getIncludedStyles(theme), ...theme.styles],\r\n      // Map moduleId to includePriority\r\n      includePriority: getIncludePriority(theme.moduleId),\r\n    }))\r\n    // Sort by includePriority\r\n    .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\r\n\r\n  if (themes.length > 0) {\r\n    return themes;\r\n  }\r\n  // No theme modules found, return the default module if it exists\r\n  return getAllThemes().filter((theme) => theme.moduleId === defaultModuleName);\r\n}\r\n\r\n/**\r\n * @polymerMixin\r\n * @mixes ThemePropertyMixin\r\n */\r\nexport const ThemableMixin = (superClass) =>\r\n  class VaadinThemableMixin extends ThemePropertyMixin(superClass) {\r\n    constructor() {\r\n      super();\r\n      // Store a weak reference to the instance\r\n      themableInstances.add(new WeakRef(this));\r\n    }\r\n\r\n    /**\r\n     * Covers PolymerElement based component styling\r\n     * @protected\r\n     */\r\n    static finalize() {\r\n      super.finalize();\r\n\r\n      if (this.is) {\r\n        themableTagNames.add(this.is);\r\n      }\r\n\r\n      // Make sure not to run the logic intended for PolymerElement when LitElement is used.\r\n      if (this.elementStyles) {\r\n        return;\r\n      }\r\n\r\n      const template = this.prototype._template;\r\n      if (!template || classHasThemes(this)) {\r\n        return;\r\n      }\r\n\r\n      addStylesToTemplate(this.getStylesForThis(), template);\r\n    }\r\n\r\n    /**\r\n     * Covers LitElement based component styling\r\n     *\r\n     * @protected\r\n     */\r\n    static finalizeStyles(styles) {\r\n      // The \"styles\" object originates from the \"static get styles()\" function of\r\n      // a LitElement based component. The theme styles are added after it\r\n      // so that they can override the component styles.\r\n      const themeStyles = this.getStylesForThis();\r\n      return styles ? [...[styles].flat(Infinity), ...themeStyles] : themeStyles;\r\n    }\r\n\r\n    /**\r\n     * Get styles for the component type\r\n     *\r\n     * @private\r\n     */\r\n    static getStylesForThis() {\r\n      const superClassThemes = superClass.__themes || [];\r\n      const parent = Object.getPrototypeOf(this.prototype);\r\n      const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\r\n      this.__themes = [...superClassThemes, ...inheritedThemes, ...getThemes(this.is)];\r\n      const themeStyles = this.__themes.flatMap((theme) => theme.styles);\r\n      // Remove duplicates\r\n      return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\r\n    }\r\n  };\r\n\r\nexport { themeRegistry as __themeRegistry };\r\n"],
  "mappings": "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",
  "names": []
}
