{
  "version": 3,
  "sources": ["../../ol/src/ImageState.js", "../../ol/src/dom.js"],
  "sourcesContent": ["/**\r\n * @module ol/ImageState\r\n */\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nexport default {\r\n  IDLE: 0,\r\n  LOADING: 1,\r\n  LOADED: 2,\r\n  ERROR: 3,\r\n  EMPTY: 4,\r\n};\r\n", "import {WORKER_OFFSCREEN_CANVAS} from './has.js';\r\n\r\n/**\r\n * @module ol/dom\r\n */\r\n\r\n//FIXME Move this function to the canvas module\r\n/**\r\n * Create an html canvas element and returns its 2d context.\r\n * @param {number} [opt_width] Canvas width.\r\n * @param {number} [opt_height] Canvas height.\r\n * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.\r\n * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings\r\n * @return {CanvasRenderingContext2D} The context.\r\n */\r\nexport function createCanvasContext2D(\r\n  opt_width,\r\n  opt_height,\r\n  opt_canvasPool,\r\n  opt_Context2DSettings\r\n) {\r\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\r\n  let canvas;\r\n  if (opt_canvasPool && opt_canvasPool.length) {\r\n    canvas = opt_canvasPool.shift();\r\n  } else if (WORKER_OFFSCREEN_CANVAS) {\r\n    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\r\n  } else {\r\n    canvas = document.createElement('canvas');\r\n  }\r\n  if (opt_width) {\r\n    canvas.width = opt_width;\r\n  }\r\n  if (opt_height) {\r\n    canvas.height = opt_height;\r\n  }\r\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\r\n  return /** @type {CanvasRenderingContext2D} */ (\r\n    canvas.getContext('2d', opt_Context2DSettings)\r\n  );\r\n}\r\n\r\n/**\r\n * Get the current computed width for the given element including margin,\r\n * padding and border.\r\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\r\n * @param {!HTMLElement} element Element.\r\n * @return {number} The width.\r\n */\r\nexport function outerWidth(element) {\r\n  let width = element.offsetWidth;\r\n  const style = getComputedStyle(element);\r\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\r\n\r\n  return width;\r\n}\r\n\r\n/**\r\n * Get the current computed height for the given element including margin,\r\n * padding and border.\r\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\r\n * @param {!HTMLElement} element Element.\r\n * @return {number} The height.\r\n */\r\nexport function outerHeight(element) {\r\n  let height = element.offsetHeight;\r\n  const style = getComputedStyle(element);\r\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\r\n\r\n  return height;\r\n}\r\n\r\n/**\r\n * @param {Node} newNode Node to replace old node\r\n * @param {Node} oldNode The node to be replaced\r\n */\r\nexport function replaceNode(newNode, oldNode) {\r\n  const parent = oldNode.parentNode;\r\n  if (parent) {\r\n    parent.replaceChild(newNode, oldNode);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node The node to remove.\r\n * @return {Node|null} The node that was removed or null.\r\n */\r\nexport function removeNode(node) {\r\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\r\n}\r\n\r\n/**\r\n * @param {Node} node The node to remove the children from.\r\n */\r\nexport function removeChildren(node) {\r\n  while (node.lastChild) {\r\n    node.removeChild(node.lastChild);\r\n  }\r\n}\r\n\r\n/**\r\n * Transform the children of a parent node so they match the\r\n * provided list of children.  This function aims to efficiently\r\n * remove, add, and reorder child nodes while maintaining a simple\r\n * implementation (it is not guaranteed to minimize DOM operations).\r\n * @param {Node} node The parent node whose children need reworking.\r\n * @param {Array<Node>} children The desired children.\r\n */\r\nexport function replaceChildren(node, children) {\r\n  const oldChildren = node.childNodes;\r\n\r\n  for (let i = 0; true; ++i) {\r\n    const oldChild = oldChildren[i];\r\n    const newChild = children[i];\r\n\r\n    // check if our work is done\r\n    if (!oldChild && !newChild) {\r\n      break;\r\n    }\r\n\r\n    // check if children match\r\n    if (oldChild === newChild) {\r\n      continue;\r\n    }\r\n\r\n    // check if a new child needs to be added\r\n    if (!oldChild) {\r\n      node.appendChild(newChild);\r\n      continue;\r\n    }\r\n\r\n    // check if an old child needs to be removed\r\n    if (!newChild) {\r\n      node.removeChild(oldChild);\r\n      --i;\r\n      continue;\r\n    }\r\n\r\n    // reorder\r\n    node.insertBefore(newChild, oldChild);\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;AAOA,IAAA,qBAAe;EACb,MAAM;EACN,SAAS;EACT,QAAQ;EACR,OAAO;EACP,OAAO;;;;ACGH,SAAU,sBACd,WACA,YACA,gBACA,uBAAqB;AAGrB,MAAI;AACJ,MAAI,kBAAkB,eAAe,QAAQ;AAC3C,aAAS,eAAe,MAAK;aACpB,yBAAyB;AAClC,aAAS,IAAI,gBAAgB,aAAa,KAAK,cAAc,GAAG;SAC3D;AACL,aAAS,SAAS,cAAc,QAAQ;;AAE1C,MAAI,WAAW;AACb,WAAO,QAAQ;;AAEjB,MAAI,YAAY;AACd,WAAO,SAAS;;AAGlB;;IACE,OAAO,WAAW,MAAM,qBAAqB;;AAEjD;AASM,SAAU,WAAW,SAAO;AAChC,MAAI,QAAQ,QAAQ;AACpB,MAAM,QAAQ,iBAAiB,OAAO;AACtC,WAAS,SAAS,MAAM,YAAY,EAAE,IAAI,SAAS,MAAM,aAAa,EAAE;AAExE,SAAO;AACT;AASM,SAAU,YAAY,SAAO;AACjC,MAAI,SAAS,QAAQ;AACrB,MAAM,QAAQ,iBAAiB,OAAO;AACtC,YAAU,SAAS,MAAM,WAAW,EAAE,IAAI,SAAS,MAAM,cAAc,EAAE;AAEzE,SAAO;AACT;AAMM,SAAU,YAAY,SAAS,SAAO;AAC1C,MAAM,SAAS,QAAQ;AACvB,MAAI,QAAQ;AACV,WAAO,aAAa,SAAS,OAAO;;AAExC;AAMM,SAAU,WAAW,MAAI;AAC7B,SAAO,QAAQ,KAAK,aAAa,KAAK,WAAW,YAAY,IAAI,IAAI;AACvE;AAKM,SAAU,eAAe,MAAI;AACjC,SAAO,KAAK,WAAW;AACrB,SAAK,YAAY,KAAK,SAAS;;AAEnC;AAUM,SAAU,gBAAgB,MAAM,UAAQ;AAC5C,MAAM,cAAc,KAAK;AAEzB,WAAS,IAAI,GAAG,MAAM,EAAE,GAAG;AACzB,QAAM,WAAW,YAAY,CAAC;AAC9B,QAAM,WAAW,SAAS,CAAC;AAG3B,QAAI,CAAC,YAAY,CAAC,UAAU;AAC1B;;AAIF,QAAI,aAAa,UAAU;AACzB;;AAIF,QAAI,CAAC,UAAU;AACb,WAAK,YAAY,QAAQ;AACzB;;AAIF,QAAI,CAAC,UAAU;AACb,WAAK,YAAY,QAAQ;AACzB,QAAE;AACF;;AAIF,SAAK,aAAa,UAAU,QAAQ;;AAExC;",
  "names": []
}
