{
  "version": 3,
  "sources": ["../../@polymer/polymer/lib/elements/dom-if.js"],
  "sourcesContent": ["/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\nimport { PolymerElement } from '../../polymer-element.js';\r\n\r\nimport { Debouncer } from '../utils/debounce.js';\r\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\r\nimport { microTask } from '../utils/async.js';\r\nimport { root } from '../utils/path.js';\r\nimport { wrap } from '../utils/wrap.js';\r\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\r\nimport { fastDomIf, strictTemplatePolicy, suppressTemplateNotifications } from '../utils/settings.js';\r\nimport { showHideChildren, templatize } from '../utils/templatize.js';\r\n\r\n/**\r\n * @customElement\r\n * @polymer\r\n * @extends PolymerElement\r\n * @summary Base class for dom-if element; subclassed into concrete\r\n *   implementation.\r\n */\r\nclass DomIfBase extends PolymerElement {\r\n\r\n  // Not needed to find template; can be removed once the analyzer\r\n  // can find the tag name from customElements.define call\r\n  static get is() { return 'dom-if'; }\r\n\r\n  static get template() { return null; }\r\n\r\n  static get properties() {\r\n\r\n    return {\r\n\r\n      /**\r\n       * Fired whenever DOM is added or removed/hidden by this template (by\r\n       * default, rendering occurs lazily).  To force immediate rendering, call\r\n       * `render`.\r\n       *\r\n       * @event dom-change\r\n       */\r\n\r\n      /**\r\n       * A boolean indicating whether this template should stamp.\r\n       */\r\n      if: {\r\n        type: Boolean,\r\n        observer: '__debounceRender'\r\n      },\r\n\r\n      /**\r\n       * When true, elements will be removed from DOM and discarded when `if`\r\n       * becomes false and re-created and added back to the DOM when `if`\r\n       * becomes true.  By default, stamped elements will be hidden but left\r\n       * in the DOM when `if` becomes false, which is generally results\r\n       * in better performance.\r\n       */\r\n      restamp: {\r\n        type: Boolean,\r\n        observer: '__debounceRender'\r\n      },\r\n\r\n      /**\r\n       * When the global `suppressTemplateNotifications` setting is used, setting\r\n       * `notifyDomChange: true` will enable firing `dom-change` events on this\r\n       * element.\r\n       */\r\n      notifyDomChange: {\r\n        type: Boolean\r\n      }\r\n    };\r\n\r\n  }\r\n\r\n  constructor() {\r\n    super();\r\n    this.__renderDebouncer = null;\r\n    this._lastIf = false;\r\n    this.__hideTemplateChildren__ = false;\r\n    /** @type {!HTMLTemplateElement|undefined} */\r\n    this.__template;\r\n    /** @type {!TemplateInfo|undefined} */\r\n    this._templateInfo;\r\n  }\r\n\r\n  __debounceRender() {\r\n    // Render is async for 2 reasons:\r\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\r\n    //    same turn. This was more common in 1.x where a compound computed\r\n    //    property could result in the result changing multiple times, but is\r\n    //    mitigated to a large extent by batched property processing in 2.x.\r\n    // 2. To avoid double object propagation when a bag including values bound\r\n    //    to the `if` property as well as one or more hostProps could enqueue\r\n    //    the <dom-if> to flush before the <template>'s host property\r\n    //    forwarding. In that scenario creating an instance would result in\r\n    //    the host props being set once, and then the enqueued changes on the\r\n    //    template would set properties a second time, potentially causing an\r\n    //    object to be set to an instance more than once.  Creating the\r\n    //    instance async from flushing data ensures this doesn't happen. If\r\n    //    we wanted a sync option in the future, simply having <dom-if> flush\r\n    //    (or clear) its template's pending host properties before creating\r\n    //    the instance would also avoid the problem.\r\n    this.__renderDebouncer = Debouncer.debounce(\r\n          this.__renderDebouncer\r\n        , microTask\r\n        , () => this.__render());\r\n    enqueueDebouncer(this.__renderDebouncer);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @return {void}\r\n   */\r\n  disconnectedCallback() {\r\n    super.disconnectedCallback();\r\n    const parent = wrap(this).parentNode;\r\n    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&\r\n        !wrap(parent).host)) {\r\n      this.__teardownInstance();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @return {void}\r\n   */\r\n  connectedCallback() {\r\n    super.connectedCallback();\r\n    if (!hideElementsGlobally()) {\r\n      this.style.display = 'none';\r\n    }\r\n    if (this.if) {\r\n      this.__debounceRender();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensures a template has been assigned to `this.__template`.  If it has not\r\n   * yet been, it querySelectors for it in its children and if it does not yet\r\n   * exist (e.g. in parser-generated case), opens a mutation observer and\r\n   * waits for it to appear (returns false if it has not yet been found,\r\n   * otherwise true).  In the `removeNestedTemplates` case, the \"template\" will\r\n   * be the `dom-if` element itself.\r\n   *\r\n   * @return {boolean} True when a template has been found, false otherwise\r\n   */\r\n  __ensureTemplate() {\r\n    if (!this.__template) {\r\n      // When `removeNestedTemplates` is true, the \"template\" is the element\r\n      // itself, which has been given a `_templateInfo` property\r\n      const thisAsTemplate = /** @type {!HTMLTemplateElement} */ (\r\n          /** @type {!HTMLElement} */ (this));\r\n      let template = thisAsTemplate._templateInfo ?\r\n          thisAsTemplate :\r\n          /** @type {!HTMLTemplateElement} */\r\n          (wrap(thisAsTemplate).querySelector('template'));\r\n      if (!template) {\r\n        // Wait until childList changes and template should be there by then\r\n        let observer = new MutationObserver(() => {\r\n          if (wrap(this).querySelector('template')) {\r\n            observer.disconnect();\r\n            this.__render();\r\n          } else {\r\n            throw new Error('dom-if requires a <template> child');\r\n          }\r\n        });\r\n        observer.observe(this, {childList: true});\r\n        return false;\r\n      }\r\n      this.__template = template;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Ensures a an instance of the template has been created and inserted. This\r\n   * method may return false if the template has not yet been found or if\r\n   * there is no `parentNode` to insert the template into (in either case,\r\n   * connection or the template-finding mutation observer firing will queue\r\n   * another render, causing this method to be called again at a more\r\n   * appropriate time).\r\n   *\r\n   * Subclasses should implement the following methods called here:\r\n   * - `__hasInstance`\r\n   * - `__createAndInsertInstance`\r\n   * - `__getInstanceNodes`\r\n   *\r\n   * @return {boolean} True if the instance was created, false otherwise.\r\n   */\r\n  __ensureInstance() {\r\n    let parentNode = wrap(this).parentNode;\r\n    if (!this.__hasInstance()) {\r\n      // Guard against element being detached while render was queued\r\n      if (!parentNode) {\r\n        return false;\r\n      }\r\n      // Find the template (when false, there was no template yet)\r\n      if (!this.__ensureTemplate()) {\r\n        return false;\r\n      }\r\n      this.__createAndInsertInstance(parentNode);\r\n    } else {\r\n      // Move instance children if necessary\r\n      let children = this.__getInstanceNodes();\r\n      if (children && children.length) {\r\n        // Detect case where dom-if was re-attached in new position\r\n        let lastChild = wrap(this).previousSibling;\r\n        if (lastChild !== children[children.length-1]) {\r\n          for (let i=0, n; (i<children.length) && (n=children[i]); i++) {\r\n            wrap(parentNode).insertBefore(n, this);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Forces the element to render its content. Normally rendering is\r\n   * asynchronous to a provoking change. This is done for efficiency so\r\n   * that multiple changes trigger only a single render. The render method\r\n   * should be called if, for example, template rendering is required to\r\n   * validate application state.\r\n   *\r\n   * @return {void}\r\n   */\r\n  render() {\r\n    flush();\r\n  }\r\n\r\n  /**\r\n   * Performs the key rendering steps:\r\n   * 1. Ensure a template instance has been stamped (when true)\r\n   * 2. Remove the template instance (when false and restamp:true)\r\n   * 3. Sync the hidden state of the instance nodes with the if/restamp state\r\n   * 4. Fires the `dom-change` event when necessary\r\n   *\r\n   * @return {void}\r\n   */\r\n  __render() {\r\n    if (this.if) {\r\n      if (!this.__ensureInstance()) {\r\n        // No template found yet\r\n        return;\r\n      }\r\n    } else if (this.restamp) {\r\n      this.__teardownInstance();\r\n    }\r\n    this._showHideChildren();\r\n    if ((!suppressTemplateNotifications || this.notifyDomChange)\r\n        && this.if != this._lastIf) {\r\n      this.dispatchEvent(new CustomEvent('dom-change', {\r\n        bubbles: true,\r\n        composed: true\r\n      }));\r\n      this._lastIf = this.if;\r\n    }\r\n  }\r\n\r\n  // Ideally these would be annotated as abstract methods in an abstract class,\r\n  // but closure compiler is finnicky\r\n  /* eslint-disable valid-jsdoc */\r\n  /**\r\n   * Abstract API to be implemented by subclass: Returns true if a template\r\n   * instance has been created and inserted.\r\n   *\r\n   * @protected\r\n   * @return {boolean} True when an instance has been created.\r\n   */\r\n  __hasInstance() { }\r\n\r\n  /**\r\n   * Abstract API to be implemented by subclass: Returns the child nodes stamped\r\n   * from a template instance.\r\n   *\r\n   * @protected\r\n   * @return {Array<Node>} Array of child nodes stamped from the template\r\n   * instance.\r\n   */\r\n  __getInstanceNodes() { }\r\n\r\n  /**\r\n   * Abstract API to be implemented by subclass: Creates an instance of the\r\n   * template and inserts it into the given parent node.\r\n   *\r\n   * @protected\r\n   * @param {Node} parentNode The parent node to insert the instance into\r\n   * @return {void}\r\n   */\r\n  __createAndInsertInstance(parentNode) { } // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n   * Abstract API to be implemented by subclass: Removes nodes created by an\r\n   * instance of a template and any associated cleanup.\r\n   *\r\n   * @protected\r\n   * @return {void}\r\n   */\r\n  __teardownInstance() { }\r\n\r\n  /**\r\n   * Abstract API to be implemented by subclass: Shows or hides any template\r\n   * instance childNodes based on the `if` state of the element and its\r\n   * `__hideTemplateChildren__` property.\r\n   *\r\n   * @protected\r\n   * @return {void}\r\n   */\r\n  _showHideChildren() { }\r\n  /* eslint-enable valid-jsdoc */\r\n}\r\n\r\n/**\r\n * The version of DomIf used when `fastDomIf` setting is in use, which is\r\n * optimized for first-render (but adds a tax to all subsequent property updates\r\n * on the host, whether they were used in a given `dom-if` or not).\r\n *\r\n * This implementation avoids use of `Templatizer`, which introduces a new scope\r\n * (a non-element PropertyEffects instance), which is not strictly necessary\r\n * since `dom-if` never introduces new properties to its scope (unlike\r\n * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its\r\n * `__dataHost` and stamps the template directly from the host using the host's\r\n * runtime `_stampTemplate` API, which binds the property effects of the\r\n * template directly to the host. This both avoids the intermediary\r\n * `Templatizer` instance, but also avoids the need to bind host properties to\r\n * the `<template>` element and forward those into the template instance.\r\n *\r\n * In this version of `dom-if`, the `this.__instance` method is the\r\n * `DocumentFragment` returned from `_stampTemplate`, which also serves as the\r\n * handle for later removing it using the `_removeBoundDom` method.\r\n */\r\nclass DomIfFast extends DomIfBase {\r\n\r\n  constructor() {\r\n    super();\r\n    this.__instance = null;\r\n    this.__syncInfo = null;\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * @override\r\n   * @return {boolean} True when an instance has been created.\r\n   */\r\n  __hasInstance() {\r\n    return Boolean(this.__instance);\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * @override\r\n   * @return {Array<Node>} Array of child nodes stamped from the template\r\n   * instance.\r\n   */\r\n  __getInstanceNodes() {\r\n    return this.__instance.templateInfo.childNodes;\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this\r\n   * element and then inserts the resulting nodes into the given `parentNode`.\r\n   *\r\n   * @override\r\n   * @param {Node} parentNode The parent node to insert the instance into\r\n   * @return {void}\r\n   */\r\n  __createAndInsertInstance(parentNode) {\r\n    const host = this.__dataHost || this;\r\n    if (strictTemplatePolicy) {\r\n      if (!this.__dataHost) {\r\n        throw new Error('strictTemplatePolicy: template owner not trusted');\r\n      }\r\n    }\r\n    // Pre-bind and link the template into the effects system\r\n    const templateInfo = host._bindTemplate(\r\n        /** @type {!HTMLTemplateElement} */ (this.__template), true);\r\n    // Install runEffects hook that prevents running property effects\r\n    // (and any nested template effects) when the `if` is false\r\n    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {\r\n      let syncInfo = this.__syncInfo;\r\n      if (this.if) {\r\n        // Mix any props that changed while the `if` was false into `changedProps`\r\n        if (syncInfo) {\r\n          // If there were properties received while the `if` was false, it is\r\n          // important to sync the hidden state with the element _first_, so that\r\n          // new bindings to e.g. `textContent` do not get stomped on by\r\n          // pre-hidden values if `_showHideChildren` were to be called later at\r\n          // the next render. Clearing `__invalidProps` here ensures\r\n          // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so\r\n          // that we don't call `runEffects` more often than necessary.\r\n          this.__syncInfo = null;\r\n          this._showHideChildren();\r\n          changedProps = Object.assign(syncInfo.changedProps, changedProps);\r\n        }\r\n        runEffects(changedProps, hasPaths);\r\n      } else {\r\n        // Accumulate any values changed while `if` was false, along with the\r\n        // runEffects method to sync them, so that we can replay them once `if`\r\n        // becomes true\r\n        if (this.__instance) {\r\n          if (!syncInfo) {\r\n            syncInfo = this.__syncInfo = { runEffects, changedProps: {} };\r\n          }\r\n          if (hasPaths) {\r\n            // Store root object of any paths; this will ensure direct bindings\r\n            // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but\r\n            // note that path notifications like `set('obj.foo.bar', v)` will\r\n            // not propagate. Since batched path notifications are not\r\n            // supported, we cannot simply accumulate path notifications. This\r\n            // is equivalent to the non-fastDomIf case, which stores root(p) in\r\n            // __invalidProps.\r\n            for (const p in changedProps) {\r\n              const rootProp = root(p);\r\n              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];\r\n            }\r\n          } else {\r\n            Object.assign(syncInfo.changedProps, changedProps);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    // Stamp the template, and set its DocumentFragment to the \"instance\"\r\n    this.__instance = host._stampTemplate(\r\n        /** @type {!HTMLTemplateElement} */ (this.__template), templateInfo);\r\n    wrap(parentNode).insertBefore(this.__instance, this);\r\n  }\r\n\r\n  /**\r\n   * Run effects for any properties that changed while the `if` was false.\r\n   *\r\n   * @return {void}\r\n   */\r\n  __syncHostProperties() {\r\n    const syncInfo = this.__syncInfo;\r\n    if (syncInfo) {\r\n      this.__syncInfo = null;\r\n      syncInfo.runEffects(syncInfo.changedProps, false);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s\r\n   * runtime `_removeBoundDom` method.\r\n   *\r\n   * @override\r\n   * @return {void}\r\n   */\r\n  __teardownInstance() {\r\n    const host = this.__dataHost || this;\r\n    if (this.__instance) {\r\n      host._removeBoundDom(this.__instance);\r\n      this.__instance = null;\r\n      this.__syncInfo = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * Shows or hides the template instance top level child nodes. For\r\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\r\n   * \"shown.\"\r\n   *\r\n   * @override\r\n   * @return {void}\r\n   * @protected\r\n   * @suppress {visibility}\r\n   */\r\n  _showHideChildren() {\r\n    const hidden = this.__hideTemplateChildren__ || !this.if;\r\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\r\n      this.__instance.__hidden = hidden;\r\n      showHideChildren(hidden, this.__instance.templateInfo.childNodes);\r\n    }\r\n    if (!hidden) {\r\n      this.__syncHostProperties();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * The \"legacy\" implementation of `dom-if`, implemented using `Templatizer`.\r\n *\r\n * In this version, `this.__instance` is the `TemplateInstance` returned\r\n * from the templatized constructor.\r\n */\r\nclass DomIfLegacy extends DomIfBase {\r\n\r\n  constructor() {\r\n    super();\r\n    this.__ctor = null;\r\n    this.__instance = null;\r\n    this.__invalidProps = null;\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * @override\r\n   * @return {boolean} True when an instance has been created.\r\n   */\r\n  __hasInstance() {\r\n    return Boolean(this.__instance);\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * @override\r\n   * @return {Array<Node>} Array of child nodes stamped from the template\r\n   * instance.\r\n   */\r\n  __getInstanceNodes() {\r\n    return this.__instance.children;\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * Stamps the template by creating a new instance of the templatized\r\n   * constructor (which is created lazily if it does not yet exist), and then\r\n   * inserts its resulting `root` doc fragment into the given `parentNode`.\r\n   *\r\n   * @override\r\n   * @param {Node} parentNode The parent node to insert the instance into\r\n   * @return {void}\r\n   */\r\n  __createAndInsertInstance(parentNode) {\r\n    // Ensure we have an instance constructor\r\n    if (!this.__ctor) {\r\n      this.__ctor = templatize(\r\n          /** @type {!HTMLTemplateElement} */ (this.__template), this, {\r\n            // dom-if templatizer instances require `mutable: true`, as\r\n            // `__syncHostProperties` relies on that behavior to sync objects\r\n            mutableData: true,\r\n            /**\r\n             * @param {string} prop Property to forward\r\n             * @param {*} value Value of property\r\n             * @this {DomIfLegacy}\r\n             */\r\n            forwardHostProp: function(prop, value) {\r\n              if (this.__instance) {\r\n                if (this.if) {\r\n                  this.__instance.forwardHostProp(prop, value);\r\n                } else {\r\n                  // If we have an instance but are squelching host property\r\n                  // forwarding due to if being false, note the invalidated\r\n                  // properties so `__syncHostProperties` can sync them the next\r\n                  // time `if` becomes true\r\n                  this.__invalidProps =\r\n                      this.__invalidProps || Object.create(null);\r\n                  this.__invalidProps[root(prop)] = true;\r\n                }\r\n              }\r\n            }\r\n          });\r\n    }\r\n    // Create and insert the instance\r\n    this.__instance = new this.__ctor();\r\n    wrap(parentNode).insertBefore(this.__instance.root, this);\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * Removes the instance and any nodes it created.\r\n   *\r\n   * @override\r\n   * @return {void}\r\n   */\r\n  __teardownInstance() {\r\n    if (this.__instance) {\r\n      let c$ = this.__instance.children;\r\n      if (c$ && c$.length) {\r\n        // use first child parent, for case when dom-if may have been detached\r\n        let parent = wrap(c$[0]).parentNode;\r\n        // Instance children may be disconnected from parents when dom-if\r\n        // detaches if a tree was innerHTML'ed\r\n        if (parent) {\r\n          parent = wrap(parent);\r\n          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\r\n            parent.removeChild(n);\r\n          }\r\n        }\r\n      }\r\n      this.__invalidProps = null;\r\n      this.__instance = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Forwards any properties that changed while the `if` was false into the\r\n   * template instance and flushes it.\r\n   *\r\n   * @return {void}\r\n   */\r\n  __syncHostProperties() {\r\n    let props = this.__invalidProps;\r\n    if (props) {\r\n      this.__invalidProps = null;\r\n      for (let prop in props) {\r\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\r\n      }\r\n      this.__instance._flushProperties();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implementation of abstract API needed by DomIfBase.\r\n   *\r\n   * Shows or hides the template instance top level child elements. For\r\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\r\n   * \"shown.\"\r\n   *\r\n   * @override\r\n   * @protected\r\n   * @return {void}\r\n   * @suppress {visibility}\r\n   */\r\n  _showHideChildren() {\r\n    const hidden = this.__hideTemplateChildren__ || !this.if;\r\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\r\n      this.__instance.__hidden = hidden;\r\n      this.__instance._showHideChildren(hidden);\r\n    }\r\n    if (!hidden) {\r\n      this.__syncHostProperties();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\r\n * the `if` property becomes truthy, and the template can use Polymer\r\n * data-binding and declarative event features when used in the context of\r\n * a Polymer element's template.\r\n *\r\n * When `if` becomes falsy, the stamped content is hidden but not\r\n * removed from dom. When `if` subsequently becomes truthy again, the content\r\n * is simply re-shown. This approach is used due to its favorable performance\r\n * characteristics: the expense of creating template content is paid only\r\n * once and lazily.\r\n *\r\n * Set the `restamp` property to true to force the stamped content to be\r\n * created / destroyed when the `if` condition changes.\r\n *\r\n * @customElement\r\n * @polymer\r\n * @extends DomIfBase\r\n * @constructor\r\n * @summary Custom element that conditionally stamps and hides or removes\r\n *   template content based on a boolean flag.\r\n */\r\nexport const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;\r\n\r\ncustomElements.define(DomIf.is, DomIf);\r\n"],
  "mappings": "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",
  "names": []
}
