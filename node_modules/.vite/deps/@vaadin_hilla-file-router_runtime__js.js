import {
  d,
  u,
  w
} from "./chunk-4TUAQC2A.js";
import "./chunk-KENGNEMB.js";
import {
  Navigate,
  createBrowserRouter,
  useLocation,
  useMatches
} from "./chunk-QY7ZD3G6.js";
import "./chunk-5KP7IUG2.js";
import "./chunk-45UBYGLO.js";
import "./chunk-GU4IKNHC.js";
import "./chunk-2VJ6XAW7.js";
import "./chunk-WFI4KZJ4.js";
import {
  require_jsx_runtime
} from "./chunk-6DLQ2ODA.js";
import {
  require_react
} from "./chunk-6DWUXV6T.js";
import "./chunk-4QYCOPDF.js";
import "./chunk-RMSEGTBR.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-DWA4UIM3.js";

// node_modules/@vaadin/hilla-file-router/runtime/createRoute.js
function extendModule(module, config) {
  return {
    ...module,
    config: {
      ...config,
      ...module == null ? void 0 : module.config
    }
  };
}
function createRoute(path, moduleOrChildren, children) {
  let module;
  if (Array.isArray(moduleOrChildren)) {
    children = moduleOrChildren;
  } else {
    module = moduleOrChildren;
  }
  return {
    path,
    module,
    children
  };
}

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-auth/useAuth.js
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var initialState = {
  initializing: true,
  loading: false
};
var AuthContext = (0, import_react.createContext)({
  state: initialState,
  login() {
    throw new Error("AuthContext not initialized");
  },
  logout() {
    throw new Error("AuthContext not initialized");
  },
  hasAccess() {
    throw new Error("AuthContext not initialized");
  }
});

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function ProtectedRoute({ redirectPath, access, element }) {
  const { state: { initializing, loading }, hasAccess } = (0, import_react2.useContext)(AuthContext);
  const location = useLocation();
  if (initializing || loading) {
    return (0, import_jsx_runtime2.jsx)(
      "div",
      // This is for copilot to recognize this
      {}
    );
  }
  if (!hasAccess(access)) {
    return (0, import_jsx_runtime2.jsx)(Navigate, {
      to: redirectPath,
      state: { from: location },
      replace: true
    });
  }
  return element;
}
ProtectedRoute.type = "ProtectedRoute";
function protectRoute(route, redirectPath = "/login") {
  var _a2;
  const { handle } = route;
  const requiresAuth = (handle == null ? void 0 : handle.loginRequired) ?? (handle == null ? void 0 : handle.requiresLogin) ?? ((_a2 = handle == null ? void 0 : handle.rolesAllowed) == null ? void 0 : _a2.length);
  if (requiresAuth) {
    route.element = (0, import_jsx_runtime2.jsx)(ProtectedRoute, {
      redirectPath,
      access: handle,
      element: route.element
    });
  }
  return route;
}

// node_modules/@vaadin/hilla-react-auth/index.js
((feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `@vaadin/hilla-react-auth/${feature}` : "@vaadin/hilla-react-auth",
    version: "24.7.2"
  });
})();

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-file-router/shared/convertComponentNameToTitle.js
var viewPattern = /view/giu;
var upperCaseSplitPattern = /(?=[A-Z])/gu;
function convertComponentNameToTitle(component) {
  let name;
  if (component && (typeof component === "object" || typeof component === "function") && "name" in component && typeof component.name === "string") {
    ({ name } = component);
  } else {
    name = String(component);
  }
  return name.replace(viewPattern, "").split(upperCaseSplitPattern).join(" ");
}

// node_modules/@vaadin/hilla-file-router/shared/transformTree.js
function transformTree(nodes, context, transformer) {
  return transformer(nodes, (n2, ctx = context) => transformTree(n2, ctx, transformer), context);
}

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
function isReactRouteModule(module) {
  return "default" in module && typeof module.default === "function" || "config" in module && typeof module.config === "object";
}
function createRouteKey(route) {
  return `${route.path ?? ""}-${route.children ? "n" : "i"}`;
}
var RouteHandleFlags = function(RouteHandleFlags2) {
  RouteHandleFlags2["FLOW_LAYOUT"] = "flowLayout";
  RouteHandleFlags2["IGNORE_FALLBACK"] = "ignoreFallback";
  RouteHandleFlags2["SKIP_LAYOUTS"] = "skipLayouts";
  return RouteHandleFlags2;
}(RouteHandleFlags || {});
function getRouteHandleFlag(route, flag) {
  if (typeof route.handle === "object" && flag in route.handle) {
    return route.handle[flag];
  }
  return void 0;
}
var _modifiers, _RouterConfigurationBuilder_instances, withLayoutSkipping_fn;
var RouterConfigurationBuilder = class {
  constructor() {
    __privateAdd(this, _RouterConfigurationBuilder_instances);
    __privateAdd(this, _modifiers, []);
  }
  /**
  * Adds the given routes to the current list of routes. All the routes are
  * deeply merged to preserve the path uniqueness.
  *
  * @param routes - A list of routes to add to the current list.
  */
  withReactRoutes(routes) {
    return this.update(routes);
  }
  /**
  * Adds the given file routes to the current list of routes. All the routes
  * are transformed to React RouterObjects and deeply merged to preserve the
  * path uniqueness.
  *
  * @param routes - A list of routes to add to the current list.
  */
  withFileRoutes(routes) {
    return this.update(routes, ({ original, overriding: added, children }) => {
      var _a2, _b, _c;
      if (added) {
        const { module, path, flowLayout } = added;
        if (module && !isReactRouteModule(module)) {
          throw new Error(`The module for the "${path}" section doesn't have the React component exported by default or a ViewConfig object exported as "config"`);
        }
        const element = (module == null ? void 0 : module.default) ? (0, import_react3.createElement)(module.default) : void 0;
        const handle = {
          ...module == null ? void 0 : module.config,
          title: ((_a2 = module == null ? void 0 : module.config) == null ? void 0 : _a2.title) ?? convertComponentNameToTitle(module == null ? void 0 : module.default),
          flowLayout: ((_b = module == null ? void 0 : module.config) == null ? void 0 : _b.flowLayout) ?? flowLayout
        };
        if (path === "" && !children) {
          return {
            ...original,
            element,
            handle,
            index: true
          };
        }
        return {
          ...original,
          path: ((_c = module == null ? void 0 : module.config) == null ? void 0 : _c.route) ?? path,
          element,
          children,
          handle
        };
      }
      return original;
    });
  }
  /**
  * Adds the given server route element to each branch of the current list of
  * routes.
  *
  * @param component - The React component to add to each branch of the
  * current list of routes.
  * @param config - An optional configuration that will be applied to
  * each fallback component.
  */
  withFallback(component, config) {
    this.withLayout(component);
    const fallbackRoutes = [{
      path: "*",
      element: (0, import_react3.createElement)(component),
      handle: config
    }, {
      index: true,
      element: (0, import_react3.createElement)(component),
      handle: config
    }];
    this.update(fallbackRoutes, ({ original, overriding: added, children, dupe }) => {
      if (original && !getRouteHandleFlag(original, RouteHandleFlags.IGNORE_FALLBACK) && !dupe) {
        if (!children) {
          return original;
        }
        const _fallback = [...fallbackRoutes];
        if (children.some(({ path }) => path === "*")) {
          _fallback.shift();
        }
        if (children.some(({ index: i, path }) => i ?? (path == null ? void 0 : path.includes("?")))) {
          _fallback.pop();
        }
        return {
          ...original,
          children: [...children, ..._fallback]
        };
      }
      return added;
    });
    return this;
  }
  /**
  * Adds the layoutComponent as the parent layout to views with the flowLayouts ViewConfiguration set.
  *
  * @param layoutComponent - layout component to use, usually Flow
  */
  withLayout(layoutComponent) {
    __privateGet(this, _modifiers).push((originalRoutes) => {
      if (!originalRoutes) {
        return originalRoutes;
      }
      const result = transformTree(originalRoutes, null, (routes, next) => routes.reduce((lists, route) => {
        const { server, client, ambivalent } = next(route.children ?? []);
        const flag = getRouteHandleFlag(route, RouteHandleFlags.FLOW_LAYOUT);
        if (flag === true) {
          lists.server.push({
            ...route,
            children: route.children ? [...server, ...ambivalent] : void 0
          });
        } else if (server.length > 0) {
          lists.server.push({
            ...route,
            children: route.children ? server : void 0
          });
        }
        if (flag === false || client.length > 0) {
          lists.client.push({
            ...route,
            children: route.children ? client : void 0
          });
        }
        if (flag === void 0 && (lists.server.every(({ path }) => path !== route.path) || ambivalent.length > 0)) {
          lists.ambivalent.push({
            ...route,
            children: route.children ? ambivalent : void 0
          });
        }
        return lists;
      }, {
        server: [],
        client: [],
        ambivalent: []
      }));
      return [
        ...result.server.length ? [{
          element: (0, import_react3.createElement)(layoutComponent),
          children: result.server,
          handle: { [RouteHandleFlags.IGNORE_FALLBACK]: true }
        }] : [],
        ...result.client,
        ...result.ambivalent
      ];
    });
    return this;
  }
  /**
  * Protects all the routes that require authentication. For more details see
  * {@link @vaadin/hilla-react-auth#protectRoutes} function.
  *
  * @param redirectPath - the path to redirect to if the route is protected
  * and the user is not authenticated.
  */
  protect(redirectPath) {
    this.update(void 0, ({ original: route, children }) => {
      const finalRoute = protectRoute(route, redirectPath);
      finalRoute.children = children;
      return finalRoute;
    });
    return this;
  }
  update(routes, callback = ({ original, overriding, children }) => ({
    ...original,
    ...overriding,
    children
  })) {
    __privateGet(this, _modifiers).push((existingRoutes) => transformTree([existingRoutes, routes], null, ([original, added], next) => {
      if (original && added) {
        const final = [];
        const pathKeys = /* @__PURE__ */ new Set([...original.map(createRouteKey), ...added.map(createRouteKey)]);
        for (const pathKey of pathKeys) {
          const originalRoutes = original.filter((r2) => createRouteKey(r2) === pathKey);
          const addedRoutes = added.filter((r2) => createRouteKey(r2) === pathKey);
          if (addedRoutes.length > 1) {
            throw new Error("Adding multiple routes with the same path is not allowed");
          }
          const addedRoute = addedRoutes[0];
          if (originalRoutes.length > 0 && addedRoute) {
            for (let i = 0; i < originalRoutes.length; i++) {
              final.push(callback({
                original: originalRoutes[i],
                overriding: addedRoute,
                children: next([originalRoutes[i].children, addedRoute.children]),
                dupe: i < originalRoutes.length - 1
              }) ?? originalRoutes[i]);
            }
          } else if (originalRoutes.length > 0) {
            for (let i = 0; i < originalRoutes.length; i++) {
              final.push(callback({
                original: originalRoutes[i],
                children: next([originalRoutes[i].children, void 0]),
                dupe: i < originalRoutes.length - 1
              }) ?? originalRoutes[i]);
            }
          } else {
            const result = callback({
              overriding: addedRoute,
              children: next([void 0, addedRoute.children]),
              dupe: false
            });
            if (result) {
              final.push(result);
            }
          }
        }
        return final.filter((r2) => r2 != null);
      } else if (original) {
        return original.map((route) => callback({
          original: route,
          children: next([route.children, void 0]),
          dupe: false
        })).filter((r2) => r2 != null);
      } else if (added) {
        return added.map((route) => callback({
          overriding: route,
          children: next([void 0, route.children]),
          dupe: false
        })).filter((r2) => r2 != null);
      }
      return void 0;
    }));
    return this;
  }
  /**
  * Builds the router with the current list of routes.
  */
  build(options) {
    __privateMethod(this, _RouterConfigurationBuilder_instances, withLayoutSkipping_fn).call(this);
    const routes = __privateGet(this, _modifiers).reduce((acc, mod) => mod(acc) ?? acc, void 0) ?? [];
    return {
      routes,
      router: createBrowserRouter([...routes], {
        basename: new URL(document.baseURI).pathname,
        ...options
      })
    };
  }
};
_modifiers = new WeakMap();
_RouterConfigurationBuilder_instances = new WeakSet();
withLayoutSkipping_fn = function() {
  __privateGet(this, _modifiers).push((originalRoutes) => {
    if (!originalRoutes) {
      return originalRoutes;
    }
    const result = transformTree(originalRoutes, null, (routes, next) => routes.reduce((lists, route) => {
      var _a2;
      if (getRouteHandleFlag(route, RouteHandleFlags.SKIP_LAYOUTS)) {
        lists.skipped.push(route);
        return lists;
      }
      if (!((_a2 = route.children) == null ? void 0 : _a2.length)) {
        lists.regular.push(route);
        return lists;
      }
      const { skipped, regular } = next(route.children ?? []);
      if (skipped.length > 0) {
        const { element, ...rest } = route;
        lists.skipped.push({
          ...rest,
          children: skipped
        });
      }
      if (regular.length > 0) {
        lists.regular.push({
          ...route,
          children: regular
        });
      }
      return lists;
    }, {
      skipped: [],
      regular: []
    }));
    return [...result.skipped.length ? [{
      children: result.skipped,
      handle: { [RouteHandleFlags.IGNORE_FALLBACK]: true }
    }] : [], ...result.regular];
  });
  return this;
};

// node_modules/@vaadin/hilla-file-router/runtime/useViewConfig.js
function useViewConfig() {
  var _a2;
  const matches = useMatches();
  return (_a2 = matches[matches.length - 1]) == null ? void 0 : _a2.handle;
}

// node_modules/@vaadin/hilla-react-signals/polyfills.js
if (!("withResolvers" in Promise)) {
  Object.defineProperty(Promise, "withResolvers", {
    configurable: true,
    value() {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      return { resolve, reject, promise };
    }
  });
}

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// node_modules/@vaadin/hilla-react-signals/events.js
function createSetStateEvent(value, signalId, parentSignalId) {
  return {
    id: signalId ?? nanoid(),
    type: "set",
    value,
    accepted: false,
    ...parentSignalId !== void 0 ? { parentSignalId } : {}
  };
}
function createReplaceStateEvent(expected, value, signalId, parentSignalId) {
  return {
    id: signalId ?? nanoid(),
    type: "replace",
    value,
    expected,
    accepted: false,
    ...parentSignalId !== void 0 ? { parentSignalId } : {}
  };
}
function createIncrementStateEvent(delta) {
  return {
    id: nanoid(),
    type: "increment",
    value: delta,
    accepted: false
  };
}
function createInsertLastStateEvent(value) {
  return {
    id: nanoid(),
    type: "insert",
    value,
    position: "last",
    accepted: false
  };
}
function createRemoveStateEvent(entryId) {
  return {
    id: nanoid(),
    type: "remove",
    entryId,
    value: void 0,
    accepted: false
  };
}
function isStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && typeof event.type === "string" && typeof event.value !== "undefined" && typeof event.accepted === "boolean";
}
function isSnapshotStateEvent(event) {
  return isStateEvent(event) && event.type === "snapshot";
}
function isSetStateEvent(event) {
  return isStateEvent(event) && event.type === "set";
}
function isReplaceStateEvent(event) {
  return isStateEvent(event) && typeof event.expected !== "undefined" && event.type === "replace";
}
function isIncrementStateEvent(event) {
  return isStateEvent(event) && event.type === "increment";
}
function isListSnapshotStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && event.type === "snapshot" && event.entries instanceof Array && typeof event.accepted !== "undefined";
}
function isInsertLastStateEvent(event) {
  return isStateEvent(event) && event.type === "insert" && event.position === "last";
}
function isRemoveStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && event.type === "remove" && typeof event.entryId === "string" && typeof event.value === "undefined";
}

// node_modules/@vaadin/hilla-react-signals/FullStackSignal.js
var ENDPOINT = "SignalsHandler";
var _onFirstSubscribe, _onLastUnsubscribe, _subscribeCount;
var DependencyTrackingSignal = class extends u {
  constructor(value, onFirstSubscribe, onLastUnsubscribe) {
    super(value);
    __privateAdd(this, _onFirstSubscribe);
    __privateAdd(this, _onLastUnsubscribe);
    __privateAdd(this, _subscribeCount, -1);
    __privateSet(this, _onFirstSubscribe, onFirstSubscribe);
    __privateSet(this, _onLastUnsubscribe, onLastUnsubscribe);
  }
  S(node) {
    super.S(node);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onFirstSubscribe).call(this);
    }
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) + 1);
  }
  U(node) {
    super.U(node);
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) - 1);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onLastUnsubscribe).call(this);
    }
  }
};
_onFirstSubscribe = new WeakMap();
_onLastUnsubscribe = new WeakMap();
_subscribeCount = new WeakMap();
var _id, _subscription;
var ServerConnection = class {
  constructor(id, config) {
    __privateAdd(this, _id);
    __publicField(this, "config");
    __privateAdd(this, _subscription);
    this.config = config;
    __privateSet(this, _id, id);
  }
  get subscription() {
    return __privateGet(this, _subscription);
  }
  connect() {
    const { client, endpoint, method, params, parentClientSignalId } = this.config;
    __privateGet(this, _subscription) ?? __privateSet(this, _subscription, client.subscribe(ENDPOINT, "subscribe", {
      providerEndpoint: endpoint,
      providerMethod: method,
      clientSignalId: __privateGet(this, _id),
      params,
      parentClientSignalId
    }));
    return __privateGet(this, _subscription);
  }
  async update(event) {
    const onTheFly = !__privateGet(this, _subscription);
    if (onTheFly) {
      this.connect();
    }
    await this.config.client.call(ENDPOINT, "update", {
      clientSignalId: __privateGet(this, _id),
      event
    });
    if (onTheFly) {
      this.disconnect();
    }
  }
  disconnect() {
    var _a2;
    (_a2 = __privateGet(this, _subscription)) == null ? void 0 : _a2.cancel();
    __privateSet(this, _subscription, void 0);
  }
};
_id = new WeakMap();
_subscription = new WeakMap();
var $update = Symbol("update");
var $processServerResponse = Symbol("processServerResponse");
var $setValueQuietly = Symbol("setValueQuietly");
var $resolveOperation = Symbol("resolveOperation");
var $createOperation = Symbol("createOperation");
var _pending, _error, _paused, _operationPromises, _FullStackSignal_instances, connect_fn, disconnect_fn;
var FullStackSignal = class extends DependencyTrackingSignal {
  constructor(value, config, id) {
    super(value, () => __privateMethod(this, _FullStackSignal_instances, connect_fn).call(this), () => __privateMethod(this, _FullStackSignal_instances, disconnect_fn).call(this));
    __privateAdd(this, _FullStackSignal_instances);
    __publicField(this, "id");
    __publicField(this, "server");
    __publicField(this, "pending", w(() => __privateGet(this, _pending).value));
    __publicField(this, "error", w(() => __privateGet(this, _error).value));
    __privateAdd(this, _pending, d(false));
    __privateAdd(this, _error, d(void 0));
    __privateAdd(this, _paused, true);
    __privateAdd(this, _operationPromises, /* @__PURE__ */ new Map());
    this.id = id ?? nanoid();
    this.server = new ServerConnection(this.id, config);
    this.subscribe((v) => {
      if (!__privateGet(this, _paused)) {
        __privateGet(this, _pending).value = true;
        __privateGet(this, _error).value = void 0;
        const signalId = config.parentClientSignalId !== void 0 ? this.id : void 0;
        this[$update](createSetStateEvent(v, signalId, config.parentClientSignalId));
      }
    });
    __privateSet(this, _paused, false);
  }
  [$createOperation]({ id, promise }) {
    const thens = __privateGet(this, _operationPromises);
    const promises = [];
    if (promise) {
      promises.push(promise);
    }
    if (id) {
      promises.push(new Promise((resolve, reject) => {
        thens.set(id, { resolve, reject });
      }));
    }
    if (promises.length === 0) {
      promises.push(Promise.resolve());
    }
    return {
      result: Promise.allSettled(promises).then((results) => {
        const lastResult = results[results.length - 1];
        if (lastResult.status === "fulfilled") {
          return void 0;
        }
        throw lastResult.reason;
      })
    };
  }
  [$setValueQuietly](value) {
    __privateSet(this, _paused, true);
    super.value = value;
    __privateSet(this, _paused, false);
  }
  async [$update](event) {
    return this.server.update(event).catch((error) => {
      __privateGet(this, _error).value = error instanceof Error ? error : new Error(String(error));
    }).finally(() => {
      __privateGet(this, _pending).value = false;
    });
  }
  [$resolveOperation](eventId, reason) {
    const operationPromise = __privateGet(this, _operationPromises).get(eventId);
    if (operationPromise) {
      __privateGet(this, _operationPromises).delete(eventId);
      if (reason) {
        operationPromise.reject(reason);
      } else {
        operationPromise.resolve();
      }
    }
  }
};
_pending = new WeakMap();
_error = new WeakMap();
_paused = new WeakMap();
_operationPromises = new WeakMap();
_FullStackSignal_instances = new WeakSet();
connect_fn = function() {
  this.server.connect().onSubscriptionLost(() => "resubscribe").onNext((event) => {
    __privateSet(this, _paused, true);
    this[$processServerResponse](event);
    __privateSet(this, _paused, false);
  });
};
disconnect_fn = function() {
  if (this.server.subscription === void 0) {
    return;
  }
  this.server.disconnect();
};

// node_modules/@vaadin/hilla-react-signals/ValueSignal.js
var _pendingRequests, _ValueSignal_instances, applyAcceptedEvent_fn;
var ValueSignal = class extends FullStackSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _ValueSignal_instances);
    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());
  }
  set(value) {
    const { parentClientSignalId } = this.server.config;
    const signalId = parentClientSignalId !== void 0 ? this.id : void 0;
    const event = createSetStateEvent(value, signalId, parentClientSignalId);
    const promise = this[$update](event);
    this[$setValueQuietly](value);
    return this[$createOperation]({ id: event.id, promise });
  }
  replace(expected, newValue) {
    const { parentClientSignalId } = this.server.config;
    const signalId = parentClientSignalId !== void 0 ? this.id : void 0;
    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  update(callback) {
    const newValue = callback(this.value);
    const event = createReplaceStateEvent(this.value, newValue);
    const promise = this[$update](event);
    const pendingRequest = { id: nanoid(), callback, canceled: false };
    __privateGet(this, _pendingRequests).set(event.id, pendingRequest);
    return {
      ...this[$createOperation]({ id: pendingRequest.id, promise }),
      cancel: () => {
        pendingRequest.canceled = true;
      }
    };
  }
  [$processServerResponse](event) {
    const record = __privateGet(this, _pendingRequests).get(event.id);
    if (record) {
      __privateGet(this, _pendingRequests).delete(event.id);
      if (!(event.accepted || record.canceled)) {
        this.update(record.callback);
      }
    }
    let reason;
    if (event.accepted || isSnapshotStateEvent(event)) {
      __privateMethod(this, _ValueSignal_instances, applyAcceptedEvent_fn).call(this, event);
    } else {
      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;
    }
    [record == null ? void 0 : record.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id, reason));
  }
};
_pendingRequests = new WeakMap();
_ValueSignal_instances = new WeakSet();
applyAcceptedEvent_fn = function(event) {
  if (isSetStateEvent(event) || isSnapshotStateEvent(event)) {
    this.value = event.value;
  } else if (isReplaceStateEvent(event)) {
    if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {
      this.value = event.value;
    }
  }
};

// node_modules/@vaadin/hilla-react-signals/NumberSignal.js
var _sentIncrementEvents;
var NumberSignal = class extends ValueSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _sentIncrementEvents, /* @__PURE__ */ new Map());
  }
  incrementBy(delta) {
    if (delta === 0) {
      return { result: Promise.resolve() };
    }
    this[$setValueQuietly](this.value + delta);
    const event = createIncrementStateEvent(delta);
    __privateGet(this, _sentIncrementEvents).set(event.id, event);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  [$processServerResponse](event) {
    if (event.accepted && isIncrementStateEvent(event)) {
      const sentEvent = __privateGet(this, _sentIncrementEvents).get(event.id);
      if (sentEvent) {
        __privateGet(this, _sentIncrementEvents).delete(event.id);
      } else {
        this[$setValueQuietly](this.value + event.value);
      }
      this[$resolveOperation](event.id);
    } else {
      super[$processServerResponse](event);
    }
  }
};
_sentIncrementEvents = new WeakMap();

// node_modules/@vaadin/hilla-react-signals/CollectionSignal.js
var CollectionSignal = class extends FullStackSignal {
  get value() {
    return super.value;
  }
  set value(_) {
    throw new Error("Value of the collection signals cannot be set.");
  }
};

// node_modules/@vaadin/hilla-react-signals/ListSignal.js
var _head, _tail, _values, _ListSignal_instances, computeItems_fn, handleInsertLastUpdate_fn, handleRemoveUpdate_fn, handleSnapshotEvent_fn;
var ListSignal = class extends CollectionSignal {
  constructor(config) {
    const initialValue = [];
    super(initialValue, config);
    __privateAdd(this, _ListSignal_instances);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _values, /* @__PURE__ */ new Map());
  }
  [$processServerResponse](event) {
    if (!event.accepted) {
      this[$resolveOperation](event.id, `Server rejected the operation with id '${event.id}'. See the server log for more details.`);
      return;
    }
    if (isListSnapshotStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleSnapshotEvent_fn).call(this, event);
    } else if (isInsertLastStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleInsertLastUpdate_fn).call(this, event);
    } else if (isRemoveStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleRemoveUpdate_fn).call(this, event);
    }
    this[$resolveOperation](event.id);
  }
  insertLast(value) {
    const event = createInsertLastStateEvent(value);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  remove(item) {
    const entryToRemove = __privateGet(this, _values).get(item.id);
    if (entryToRemove === void 0) {
      return { result: Promise.resolve() };
    }
    const removeEvent = createRemoveStateEvent(entryToRemove.value.id);
    const promise = this[$update](removeEvent);
    return this[$createOperation]({ id: removeEvent.id, promise });
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_values = new WeakMap();
_ListSignal_instances = new WeakSet();
computeItems_fn = function() {
  let current = __privateGet(this, _head);
  const result = [];
  while (current !== void 0) {
    const entry = __privateGet(this, _values).get(current);
    result.push(entry.value);
    current = entry.next;
  }
  return result;
};
handleInsertLastUpdate_fn = function(event) {
  if (event.entryId === void 0) {
    throw new Error("Unexpected state: Entry id should be defined when insert last event is accepted");
  }
  const valueSignal = new ValueSignal(event.value, { ...this.server.config, parentClientSignalId: this.id }, event.entryId);
  const newEntry = { id: valueSignal.id, value: valueSignal };
  if (__privateGet(this, _head) === void 0) {
    __privateSet(this, _head, newEntry.id);
    __privateSet(this, _tail, __privateGet(this, _head));
  } else {
    const tailEntry = __privateGet(this, _values).get(__privateGet(this, _tail));
    tailEntry.next = newEntry.id;
    newEntry.prev = __privateGet(this, _tail);
    __privateSet(this, _tail, newEntry.id);
  }
  __privateGet(this, _values).set(valueSignal.id, newEntry);
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};
handleRemoveUpdate_fn = function(event) {
  const entryToRemove = __privateGet(this, _values).get(event.entryId);
  if (entryToRemove === void 0) {
    return;
  }
  __privateGet(this, _values).delete(event.id);
  if (__privateGet(this, _head) === entryToRemove.id) {
    if (entryToRemove.next === void 0) {
      __privateSet(this, _head, void 0);
      __privateSet(this, _tail, void 0);
    } else {
      const newHead = __privateGet(this, _values).get(entryToRemove.next);
      __privateSet(this, _head, newHead.id);
      newHead.prev = void 0;
    }
  } else {
    const prevEntry = __privateGet(this, _values).get(entryToRemove.prev);
    const nextEntry = entryToRemove.next !== void 0 ? __privateGet(this, _values).get(entryToRemove.next) : void 0;
    if (nextEntry === void 0) {
      __privateSet(this, _tail, prevEntry.id);
      prevEntry.next = void 0;
    } else {
      prevEntry.next = nextEntry.id;
      nextEntry.prev = prevEntry.id;
    }
  }
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};
handleSnapshotEvent_fn = function(event) {
  event.entries.forEach((entry) => {
    __privateGet(this, _values).set(entry.id, {
      id: entry.id,
      prev: entry.prev,
      next: entry.next,
      value: new ValueSignal(entry.value, { ...this.server.config, parentClientSignalId: this.id }, entry.id)
    });
    if (entry.prev === void 0) {
      __privateSet(this, _head, entry.id);
    }
    if (entry.next === void 0) {
      __privateSet(this, _tail, entry.id);
    }
  });
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};

// node_modules/@vaadin/hilla-file-router/runtime/createMenuItems.js
var _a;
var viewsSignal = d((_a = window.Vaadin) == null ? void 0 : _a.views);
function isExcluded(value) {
  var _a2;
  return !!((_a2 = value.menu) == null ? void 0 : _a2.exclude);
}
function hasVariablePathSegment(path) {
  return path.split("/").some((segment) => segment.startsWith(":"));
}
function createMenuItems() {
  ((feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
    vaadinObj.registrations ?? (vaadinObj.registrations = []);
    vaadinObj.registrations.push({
      is: feature ? `@vaadin/hilla-file-router/${feature}` : "@vaadin/hilla-file-router",
      version: "24.7.2"
    });
  })("createMenuItems", window.Vaadin);
  const collator = new Intl.Collator("en-US");
  if (!viewsSignal.value) {
    return [];
  }
  const views = Object.entries(viewsSignal.value);
  return views.filter(([path, value]) => !isExcluded(value) && !hasVariablePathSegment(path)).map(([path, config]) => {
    var _a2, _b, _c;
    return {
      to: path,
      icon: (_a2 = config.menu) == null ? void 0 : _a2.icon,
      title: ((_b = config.menu) == null ? void 0 : _b.title) ?? config.title,
      order: (_c = config.menu) == null ? void 0 : _c.order
    };
  }).sort((menuA, menuB) => {
    const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);
    return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);
  });
}
if (import.meta.hot) {
  import.meta.hot.on("fs-route-update", () => {
    fetch("?v-r=routeinfo").then(async (resp) => resp.json()).then((json) => {
      viewsSignal.value = json;
    }).catch((e) => {
      console.error("Failed to fetch route info", e);
    });
  });
}
export {
  RouterConfigurationBuilder,
  createMenuItems,
  createRoute,
  extendModule,
  useViewConfig,
  viewsSignal
};
//# sourceMappingURL=@vaadin_hilla-file-router_runtime__js.js.map
