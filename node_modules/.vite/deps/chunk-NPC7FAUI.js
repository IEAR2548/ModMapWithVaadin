// node_modules/@vaadin/overlay/src/vaadin-overlay-stack-mixin.js
var getAttachedInstances = () => Array.from(document.body.children).filter((el) => el instanceof HTMLElement && el._hasOverlayStackMixin && !el.hasAttribute("closing")).sort((a, b) => a.__zIndex - b.__zIndex || 0);
var getOverlayInstances = () => getAttachedInstances().filter((el) => el.$.overlay);
var isLastOverlay = (overlay) => overlay === getOverlayInstances().pop();
var overlayMap = /* @__PURE__ */ new WeakMap();
var setNestedOverlay = (parent, nested) => {
  if (nested != null) {
    overlayMap.set(parent, nested);
  } else {
    overlayMap.delete(parent);
  }
};
var OverlayStackMixin = (superClass) => class OverlayStackMixin extends superClass {
  constructor() {
    super();
    this._hasOverlayStackMixin = true;
  }
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return isLastOverlay(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    let zIndex = "";
    const frontmost = getAttachedInstances().filter((o) => o !== this).pop();
    if (frontmost) {
      const frontmostZIndex = frontmost.__zIndex;
      zIndex = frontmostZIndex + 1;
    }
    this.style.zIndex = zIndex;
    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);
    if (overlayMap.has(this)) {
      overlayMap.get(this).bringToFront();
    }
  }
  /** @protected */
  _enterModalState() {
    if (document.body.style.pointerEvents !== "none") {
      this._previousDocumentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = "none";
    }
    getOverlayInstances().forEach((el) => {
      if (el !== this) {
        el.$.overlay.style.pointerEvents = "none";
      }
    });
  }
  /** @protected */
  _exitModalState() {
    if (this._previousDocumentPointerEvents !== void 0) {
      document.body.style.pointerEvents = this._previousDocumentPointerEvents;
      delete this._previousDocumentPointerEvents;
    }
    const instances = getOverlayInstances();
    let el;
    while (el = instances.pop()) {
      if (el === this) {
        continue;
      }
      el.$.overlay.style.removeProperty("pointer-events");
      if (!el.modeless) {
        break;
      }
    }
  }
};

export {
  isLastOverlay,
  setNestedOverlay,
  OverlayStackMixin
};
/*! Bundled license information:

@vaadin/overlay/src/vaadin-overlay-stack-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-NPC7FAUI.js.map
