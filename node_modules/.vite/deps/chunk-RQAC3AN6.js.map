{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/debounce.js"],
  "sourcesContent": ["/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\nconst debouncerQueue = new Set();\r\n\r\n/**\r\n * @summary Collapse multiple callbacks into one invocation after a timer.\r\n */\r\nexport class Debouncer {\r\n  /**\r\n   * Creates a debouncer if no debouncer is passed as a parameter\r\n   * or it cancels an active debouncer otherwise. The following\r\n   * example shows how a debouncer can be called multiple times within a\r\n   * microtask and \"debounced\" such that the provided callback function is\r\n   * called once. Add this method to a custom element:\r\n   *\r\n   * ```js\r\n   * import {microTask} from '@vaadin/component-base/src/async.js';\r\n   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';\r\n   * // ...\r\n   *\r\n   * _debounceWork() {\r\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\r\n   *       microTask, () => this._doWork());\r\n   * }\r\n   * ```\r\n   *\r\n   * If the `_debounceWork` method is called multiple times within the same\r\n   * microtask, the `_doWork` function will be called only once at the next\r\n   * microtask checkpoint.\r\n   *\r\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\r\n   * this with a debouncer, you can use `enqueueDebouncer` and\r\n   * `flush`. For example, extend the above example by adding\r\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\r\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\r\n   * the debouncer has completed.\r\n   *\r\n   * @param {Debouncer?} debouncer Debouncer object.\r\n   * @param {!AsyncInterface} asyncModule Object with Async interface\r\n   * @param {function()} callback Callback to run.\r\n   * @return {!Debouncer} Returns a debouncer object.\r\n   */\r\n  static debounce(debouncer, asyncModule, callback) {\r\n    if (debouncer instanceof Debouncer) {\r\n      // Cancel the async callback, but leave in debouncerQueue if it was\r\n      // enqueued, to maintain 1.x flush order\r\n      debouncer._cancelAsync();\r\n    } else {\r\n      debouncer = new Debouncer();\r\n    }\r\n    debouncer.setConfig(asyncModule, callback);\r\n    return debouncer;\r\n  }\r\n\r\n  constructor() {\r\n    this._asyncModule = null;\r\n    this._callback = null;\r\n    this._timer = null;\r\n  }\r\n\r\n  /**\r\n   * Sets the scheduler; that is, a module with the Async interface,\r\n   * a callback and optional arguments to be passed to the run function\r\n   * from the async module.\r\n   *\r\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\r\n   * @param {function()} callback Callback to run.\r\n   * @return {void}\r\n   */\r\n  setConfig(asyncModule, callback) {\r\n    this._asyncModule = asyncModule;\r\n    this._callback = callback;\r\n    this._timer = this._asyncModule.run(() => {\r\n      this._timer = null;\r\n      debouncerQueue.delete(this);\r\n      this._callback();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cancels an active debouncer and returns a reference to itself.\r\n   *\r\n   * @return {void}\r\n   */\r\n  cancel() {\r\n    if (this.isActive()) {\r\n      this._cancelAsync();\r\n      // Canceling a debouncer removes its spot from the flush queue,\r\n      // so if a debouncer is manually canceled and re-debounced, it\r\n      // will reset its flush order (this is a very minor difference from 1.x)\r\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\r\n      debouncerQueue.delete(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancels a debouncer's async callback.\r\n   *\r\n   * @return {void}\r\n   */\r\n  _cancelAsync() {\r\n    if (this.isActive()) {\r\n      this._asyncModule.cancel(/** @type {number} */ (this._timer));\r\n      this._timer = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Flushes an active debouncer and returns a reference to itself.\r\n   *\r\n   * @return {void}\r\n   */\r\n  flush() {\r\n    if (this.isActive()) {\r\n      this.cancel();\r\n      this._callback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the debouncer is active.\r\n   *\r\n   * @return {boolean} True if active.\r\n   */\r\n  isActive() {\r\n    return this._timer != null;\r\n  }\r\n}\r\n\r\n/**\r\n * Adds a `Debouncer` to a list of globally flushable tasks.\r\n *\r\n * @param {!Debouncer} debouncer Debouncer to enqueue\r\n * @return {void}\r\n */\r\nexport function enqueueDebouncer(debouncer) {\r\n  debouncerQueue.add(debouncer);\r\n}\r\n\r\n/**\r\n * Flushes any enqueued debouncers\r\n *\r\n * @return {boolean} Returns whether any debouncers were flushed\r\n */\r\nexport function flushDebouncers() {\r\n  const didFlush = Boolean(debouncerQueue.size);\r\n  // If new debouncers are added while flushing, Set.forEach will ensure\r\n  // newly added ones are also flushed\r\n  debouncerQueue.forEach((debouncer) => {\r\n    try {\r\n      debouncer.flush();\r\n    } catch (e) {\r\n      setTimeout(() => {\r\n        throw e;\r\n      });\r\n    }\r\n  });\r\n  return didFlush;\r\n}\r\n\r\nexport const flush = () => {\r\n  let debouncers;\r\n  do {\r\n    debouncers = flushDebouncers();\r\n  } while (debouncers);\r\n};\r\n"],
  "mappings": ";AAUA,IAAM,iBAAiB,oBAAI,IAAI;AAKxB,IAAM,YAAN,MAAM,WAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmCrB,OAAO,SAAS,WAAW,aAAa,UAAU;AAChD,QAAI,qBAAqB,YAAW;AAGlC,gBAAU,aAAa;AAAA,IACzB,OAAO;AACL,kBAAY,IAAI,WAAU;AAAA,IAC5B;AACA,cAAU,UAAU,aAAa,QAAQ;AACzC,WAAO;AAAA,EACT;AAAA,EAEA,cAAc;AACZ,SAAK,eAAe;AACpB,SAAK,YAAY;AACjB,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,UAAU,aAAa,UAAU;AAC/B,SAAK,eAAe;AACpB,SAAK,YAAY;AACjB,SAAK,SAAS,KAAK,aAAa,IAAI,MAAM;AACxC,WAAK,SAAS;AACd,qBAAe,OAAO,IAAI;AAC1B,WAAK,UAAU;AAAA,IACjB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS;AACP,QAAI,KAAK,SAAS,GAAG;AACnB,WAAK,aAAa;AAKlB,qBAAe,OAAO,IAAI;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe;AACb,QAAI,KAAK,SAAS,GAAG;AACnB,WAAK,aAAa;AAAA;AAAA,QAA8B,KAAK;AAAA,MAAO;AAC5D,WAAK,SAAS;AAAA,IAChB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AACN,QAAI,KAAK,SAAS,GAAG;AACnB,WAAK,OAAO;AACZ,WAAK,UAAU;AAAA,IACjB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW;AACT,WAAO,KAAK,UAAU;AAAA,EACxB;AACF;AAQO,SAAS,iBAAiB,WAAW;AAC1C,iBAAe,IAAI,SAAS;AAC9B;AAOO,SAAS,kBAAkB;AAChC,QAAM,WAAW,QAAQ,eAAe,IAAI;AAG5C,iBAAe,QAAQ,CAAC,cAAc;AACpC,QAAI;AACF,gBAAU,MAAM;AAAA,IAClB,SAAS,GAAG;AACV,iBAAW,MAAM;AACf,cAAM;AAAA,MACR,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAEO,IAAM,QAAQ,MAAM;AACzB,MAAI;AACJ,KAAG;AACD,iBAAa,gBAAgB;AAAA,EAC/B,SAAS;AACX;",
  "names": []
}
