import {
  DialogBaseMixin,
  dialogOverlay2 as dialogOverlay,
  resizableOverlay
} from "./chunk-MIQA22T7.js";
import {
  processTemplates
} from "./chunk-KDMU7KRZ.js";
import {
  OverlayClassMixin
} from "./chunk-UF5ES3VB.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-K56GLCGU.js";
import {
  isTouch
} from "./chunk-VNRF6E57.js";
import {
  ThemableMixin,
  ThemePropertyMixin,
  registerStyles
} from "./chunk-KEWLZU7R.js";
import {
  ElementMixin
} from "./chunk-QN4QZSZG.js";
import {
  DirMixin
} from "./chunk-QBLL3FQM.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import {
  PolymerElement
} from "./chunk-YBEXGSZO.js";
import {
  html
} from "./chunk-QO5P4LIH.js";

// node_modules/@vaadin/dialog/src/vaadin-dialog-overlay-mixin.js
var DialogOverlayMixin = (superClass) => class DialogOverlayMixin extends OverlayMixin(superClass) {
  static get properties() {
    return {
      /**
       * String used for rendering a dialog title.
       */
      headerTitle: {
        type: String
      },
      /**
       * Custom function for rendering the dialog header.
       */
      headerRenderer: {
        type: Object
      },
      /**
       * Custom function for rendering the dialog footer.
       */
      footerRenderer: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "_headerFooterRendererChange(headerRenderer, footerRenderer, opened)",
      "_headerTitleChanged(headerTitle, opened)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__resizeObserver = new ResizeObserver(() => {
      this.__updateOverflow();
    });
    this.__resizeObserver.observe(this.$.resizerContainer);
    this.$.content.addEventListener("scroll", () => {
      this.__updateOverflow();
    });
  }
  /** @private */
  __createContainer(slot) {
    const container = document.createElement("div");
    container.setAttribute("slot", slot);
    return container;
  }
  /** @private */
  __clearContainer(container) {
    container.innerHTML = "";
    delete container._$litPart$;
  }
  /** @private */
  __initContainer(container, slot) {
    if (container) {
      this.__clearContainer(container);
    } else {
      container = this.__createContainer(slot);
    }
    return container;
  }
  /** @private */
  _headerFooterRendererChange(headerRenderer, footerRenderer, opened) {
    const headerRendererChanged = this.__oldHeaderRenderer !== headerRenderer;
    this.__oldHeaderRenderer = headerRenderer;
    const footerRendererChanged = this.__oldFooterRenderer !== footerRenderer;
    this.__oldFooterRenderer = footerRenderer;
    const openedChanged = this._oldOpenedFooterHeader !== opened;
    this._oldOpenedFooterHeader = opened;
    this.toggleAttribute("has-header", !!headerRenderer);
    this.toggleAttribute("has-footer", !!footerRenderer);
    if (headerRendererChanged) {
      if (headerRenderer) {
        this.headerContainer = this.__initContainer(this.headerContainer, "header-content");
      } else if (this.headerContainer) {
        this.headerContainer.remove();
        this.headerContainer = null;
        this.__updateOverflow();
      }
    }
    if (footerRendererChanged) {
      if (footerRenderer) {
        this.footerContainer = this.__initContainer(this.footerContainer, "footer");
      } else if (this.footerContainer) {
        this.footerContainer.remove();
        this.footerContainer = null;
        this.__updateOverflow();
      }
    }
    if (headerRenderer && (headerRendererChanged || openedChanged) || footerRenderer && (footerRendererChanged || openedChanged)) {
      if (opened) {
        this.requestContentUpdate();
      }
    }
  }
  /** @private */
  _headerTitleChanged(headerTitle, opened) {
    this.toggleAttribute("has-title", !!headerTitle);
    if (opened && (headerTitle || this._oldHeaderTitle)) {
      this.requestContentUpdate();
    }
    this._oldHeaderTitle = headerTitle;
  }
  /** @private */
  _headerTitleRenderer() {
    if (this.headerTitle) {
      if (!this.headerTitleElement) {
        this.headerTitleElement = document.createElement("h2");
        this.headerTitleElement.setAttribute("slot", "title");
        this.headerTitleElement.classList.add("draggable");
      }
      this.appendChild(this.headerTitleElement);
      this.headerTitleElement.textContent = this.headerTitle;
    } else if (this.headerTitleElement) {
      this.headerTitleElement.remove();
      this.headerTitleElement = null;
    }
  }
  /**
   * @override
   */
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.headerContainer) {
      if (!this.headerContainer.parentElement) {
        this.appendChild(this.headerContainer);
      }
      if (this.headerRenderer) {
        this.headerRenderer.call(this.owner, this.headerContainer, this.owner);
      }
    }
    if (this.footerContainer) {
      if (!this.footerContainer.parentElement) {
        this.appendChild(this.footerContainer);
      }
      if (this.footerRenderer) {
        this.footerRenderer.call(this.owner, this.footerContainer, this.owner);
      }
    }
    this._headerTitleRenderer();
    this.__updateOverflow();
  }
  /**
   * Updates the coordinates of the overlay.
   * @param {!DialogOverlayBoundsParam} bounds
   * @param {boolean} absolute
   */
  setBounds(bounds, absolute = true) {
    const overlay = this.$.overlay;
    const parsedBounds = { ...bounds };
    if (absolute && overlay.style.position !== "absolute") {
      overlay.style.position = "absolute";
    }
    Object.keys(parsedBounds).forEach((arg) => {
      if (!isNaN(parsedBounds[arg])) {
        parsedBounds[arg] = `${parsedBounds[arg]}px`;
      }
    });
    Object.assign(overlay.style, parsedBounds);
  }
  /**
   * Retrieves the coordinates of the overlay.
   * @return {!DialogOverlayBounds}
   */
  getBounds() {
    const overlayBounds = this.$.overlay.getBoundingClientRect();
    const containerBounds = this.getBoundingClientRect();
    const top = overlayBounds.top - containerBounds.top;
    const left = overlayBounds.left - containerBounds.left;
    const width = overlayBounds.width;
    const height = overlayBounds.height;
    return { top, left, width, height };
  }
  /** @private */
  __updateOverflow() {
    let overflow = "";
    if (this.hasAttribute("has-header") || this.hasAttribute("has-footer") || this.headerTitle) {
      const content = this.$.content;
      if (content.scrollTop > 0) {
        overflow += " top";
      }
      if (content.scrollTop < content.scrollHeight - content.clientHeight) {
        overflow += " bottom";
      }
    }
    const value = overflow.trim();
    if (value.length > 0 && this.getAttribute("overflow") !== value) {
      this.setAttribute("overflow", value);
    } else if (value.length === 0 && this.hasAttribute("overflow")) {
      this.removeAttribute("overflow");
    }
  }
};

// node_modules/@vaadin/dialog/src/vaadin-dialog-overlay.js
registerStyles("vaadin-dialog-overlay", [overlayStyles, dialogOverlay, resizableOverlay], {
  moduleId: "vaadin-dialog-overlay-styles"
});
var DialogOverlay = class extends DialogOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-dialog-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <section id="resizerContainer" class="resizer-container">
          <header part="header">
            <div part="title"><slot name="title"></slot></div>
            <div part="header-content"><slot name="header-content"></slot></div>
          </header>
          <div part="content" id="content"><slot></slot></div>
          <footer part="footer"><slot name="footer"></slot></footer>
        </section>
      </div>
    `;
  }
};
defineCustomElement(DialogOverlay);

// node_modules/@vaadin/dialog/src/vaadin-dialog-utils.js
function getMouseOrFirstTouchEvent(e) {
  return e.touches ? e.touches[0] : e;
}
function eventInWindow(e) {
  return e.clientX >= 0 && e.clientX <= window.innerWidth && e.clientY >= 0 && e.clientY <= window.innerHeight;
}

// node_modules/@vaadin/dialog/src/vaadin-dialog-draggable-mixin.js
var DialogDraggableMixin = (superClass) => class VaadinDialogDraggableMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to enable repositioning the dialog by clicking and dragging.
       *
       * By default, only the overlay area can be used to drag the element. But,
       * a child element can be marked as a draggable area by adding a
       * "`draggable`" class to it, this will by default make all of its children draggable also.
       * If you want a child element to be draggable
       * but still have its children non-draggable (by default), mark it with
       * "`draggable-leaf-only`" class name.
       *
       * @type {boolean}
       */
      draggable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      /* TODO: Expose as a public property (check naming) */
      __dragHandleClassName: {
        type: String
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._startDrag = this._startDrag.bind(this);
    this._drag = this._drag.bind(this);
    this._stopDrag = this._stopDrag.bind(this);
    this.$.overlay.$.overlay.addEventListener("mousedown", this._startDrag);
    this.$.overlay.$.overlay.addEventListener("touchstart", this._startDrag);
  }
  /** @private */
  _startDrag(e) {
    if (e.type === "touchstart" && e.touches.length > 1) {
      return;
    }
    if (this.draggable && (e.button === 0 || e.touches)) {
      const resizerContainer = this.$.overlay.$.resizerContainer;
      const isResizerContainer = e.target === resizerContainer;
      const isResizerContainerScrollbar = e.offsetX > resizerContainer.clientWidth || e.offsetY > resizerContainer.clientHeight;
      const isContentPart = e.target === this.$.overlay.$.content;
      const isDraggable = e.composedPath().some((node, index) => {
        if (!node.classList) {
          return false;
        }
        const isDraggableNode = node.classList.contains(this.__dragHandleClassName || "draggable");
        const isDraggableLeafOnly = node.classList.contains("draggable-leaf-only");
        const isLeafNode = index === 0;
        return isDraggableLeafOnly && isLeafNode || isDraggableNode && (!isDraggableLeafOnly || isLeafNode);
      });
      if (isResizerContainer && !isResizerContainerScrollbar || isContentPart || isDraggable) {
        if (!isDraggable) {
          e.preventDefault();
        }
        this._originalBounds = this.$.overlay.getBounds();
        const event = getMouseOrFirstTouchEvent(e);
        this._originalMouseCoords = { top: event.pageY, left: event.pageX };
        window.addEventListener("mouseup", this._stopDrag);
        window.addEventListener("touchend", this._stopDrag);
        window.addEventListener("mousemove", this._drag);
        window.addEventListener("touchmove", this._drag);
        if (this.$.overlay.$.overlay.style.position !== "absolute") {
          const { top, left } = this._originalBounds;
          this.$.overlay.setBounds({ top, left });
        }
      }
    }
  }
  /** @private */
  _drag(e) {
    const event = getMouseOrFirstTouchEvent(e);
    if (eventInWindow(event)) {
      const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
      const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
      this.top = top;
      this.left = left;
    }
  }
  /** @private */
  _stopDrag() {
    this.dispatchEvent(
      new CustomEvent("dragged", { bubbles: true, composed: true, detail: { top: this.top, left: this.left } })
    );
    window.removeEventListener("mouseup", this._stopDrag);
    window.removeEventListener("touchend", this._stopDrag);
    window.removeEventListener("mousemove", this._drag);
    window.removeEventListener("touchmove", this._drag);
  }
  /**
   * Fired when the dialog drag is finished.
   *
   * @event dragged
   */
};

// node_modules/@vaadin/dialog/src/vaadin-dialog-renderer-mixin.js
var DialogRendererMixin = (superClass) => class DialogRendererMixin extends superClass {
  static get properties() {
    return {
      /**
       * Custom function for rendering the content of the dialog.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       * @type {DialogRenderer | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * String used for rendering a dialog title.
       *
       * If both `headerTitle` and `headerRenderer` are defined, the title
       * and the elements created by the renderer will be placed next to
       * each other, with the title coming first.
       *
       * When `headerTitle` is set, the attribute `has-title` is added to the overlay element.
       * @attr {string} header-title
       */
      headerTitle: String,
      /**
       * Custom function for rendering the dialog header.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       *
       * If both `headerTitle` and `headerRenderer` are defined, the title
       * and the elements created by the renderer will be placed next to
       * each other, with the title coming first.
       *
       * When `headerRenderer` is set, the attribute `has-header` is added to the overlay element.
       * @type {DialogRenderer | undefined}
       */
      headerRenderer: {
        type: Object
      },
      /**
       * Custom function for rendering the dialog footer.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       *
       * When `footerRenderer` is set, the attribute `has-footer` is added to the overlay element.
       * @type {DialogRenderer | undefined}
       */
      footerRenderer: {
        type: Object
      }
    };
  }
  /**
   * Requests an update for the content of the dialog.
   * While performing the update, it invokes the renderer passed in the `renderer` property,
   * as well as `headerRender` and `footerRenderer` properties, if these are defined.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this._overlayElement) {
      this._overlayElement.requestContentUpdate();
    }
  }
};

// node_modules/@vaadin/dialog/src/vaadin-dialog-resizable-mixin.js
var DialogResizableMixin = (superClass) => class VaadinDialogResizableMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to enable resizing the dialog by dragging the corners and edges.
       * @type {boolean}
       */
      resizable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._resizeListeners = { start: {}, resize: {}, stop: {} };
    this._addResizeListeners();
  }
  /** @private */
  _addResizeListeners() {
    ["n", "e", "s", "w", "nw", "ne", "se", "sw"].forEach((direction) => {
      const resizer = document.createElement("div");
      this._resizeListeners.start[direction] = (e) => this._startResize(e, direction);
      this._resizeListeners.resize[direction] = (e) => this._resize(e, direction);
      this._resizeListeners.stop[direction] = () => this._stopResize(direction);
      if (direction.length === 1) {
        resizer.classList.add("edge");
      }
      resizer.classList.add("resizer");
      resizer.classList.add(direction);
      resizer.addEventListener("mousedown", this._resizeListeners.start[direction]);
      resizer.addEventListener("touchstart", this._resizeListeners.start[direction]);
      this.$.overlay.$.resizerContainer.appendChild(resizer);
    });
  }
  /**
   * @param {!MouseEvent | !TouchEvent} e
   * @param {!DialogResizableDirection} direction
   * @protected
   */
  _startResize(e, direction) {
    if (e.type === "touchstart" && e.touches.length > 1) {
      return;
    }
    if (e.button === 0 || e.touches) {
      e.preventDefault();
      this._originalBounds = this.$.overlay.getBounds();
      const event = getMouseOrFirstTouchEvent(e);
      this._originalMouseCoords = { top: event.pageY, left: event.pageX };
      window.addEventListener("mousemove", this._resizeListeners.resize[direction]);
      window.addEventListener("touchmove", this._resizeListeners.resize[direction]);
      window.addEventListener("mouseup", this._resizeListeners.stop[direction]);
      window.addEventListener("touchend", this._resizeListeners.stop[direction]);
      if (this.$.overlay.$.overlay.style.position !== "absolute" || this.width || this.height) {
        this.$.overlay.setBounds(this._originalBounds);
      }
      this.$.overlay.setAttribute("has-bounds-set", "");
    }
  }
  /**
   * @param {!MouseEvent | !TouchEvent} e
   * @param {!DialogResizableDirection} resizer
   * @protected
   */
  _resize(e, resizer) {
    const event = getMouseOrFirstTouchEvent(e);
    if (eventInWindow(event)) {
      const minimumSize = 40;
      resizer.split("").forEach((direction) => {
        switch (direction) {
          case "n": {
            const height = this._originalBounds.height - (event.pageY - this._originalMouseCoords.top);
            const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.top = top;
              this.height = height;
            }
            break;
          }
          case "e": {
            const width = this._originalBounds.width + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.width = width;
            }
            break;
          }
          case "s": {
            const height = this._originalBounds.height + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.height = height;
            }
            break;
          }
          case "w": {
            const width = this._originalBounds.width - (event.pageX - this._originalMouseCoords.left);
            const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.left = left;
              this.width = width;
            }
            break;
          }
          default:
            break;
        }
      });
    }
  }
  /**
   * @param {!DialogResizableDirection} direction
   * @protected
   */
  _stopResize(direction) {
    window.removeEventListener("mousemove", this._resizeListeners.resize[direction]);
    window.removeEventListener("touchmove", this._resizeListeners.resize[direction]);
    window.removeEventListener("mouseup", this._resizeListeners.stop[direction]);
    window.removeEventListener("touchend", this._resizeListeners.stop[direction]);
    this.dispatchEvent(new CustomEvent("resize", { detail: this._getResizeDimensions() }));
  }
  /**
   * @return {!DialogResizeDimensions}
   * @protected
   */
  _getResizeDimensions() {
    const scrollPosition = this.$.overlay.$.resizerContainer.scrollTop;
    const { width, height, top, left } = getComputedStyle(this.$.overlay.$.overlay);
    const content = this.$.overlay.$.content;
    content.setAttribute(
      "style",
      "position: absolute; top: 0; right: 0; bottom: 0; left: 0; box-sizing: content-box; height: auto;"
    );
    const { width: contentWidth, height: contentHeight } = getComputedStyle(content);
    content.removeAttribute("style");
    this.$.overlay.$.resizerContainer.scrollTop = scrollPosition;
    return { width, height, contentWidth, contentHeight, top, left };
  }
  /**
   * Fired when the dialog resize is finished.
   *
   * @event resize
   */
};

// node_modules/@vaadin/dialog/src/vaadin-dialog.js
var Dialog = class extends DialogDraggableMixin(
  DialogResizableMixin(
    DialogRendererMixin(DialogBaseMixin(OverlayClassMixin(ThemePropertyMixin(ElementMixin(PolymerElement)))))
  )
) {
  static get template() {
    return html`
      <style>
        :host {
          display: none !important;
        }
      </style>

      <vaadin-dialog-overlay
        id="overlay"
        role$="[[overlayRole]]"
        header-title="[[headerTitle]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        restore-focus-on-close
        focus-trap
      ></vaadin-dialog-overlay>
    `;
  }
  static get is() {
    return "vaadin-dialog";
  }
  static get properties() {
    return {
      /**
       * Set the `aria-label` attribute for assistive technologies like
       * screen readers. An empty string value for this property (the
       * default) means that the `aria-label` attribute is not present.
       */
      ariaLabel: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_ariaLabelChanged(ariaLabel, headerTitle)",
      "_rendererChanged(renderer, headerRenderer, footerRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /** @private */
  _rendererChanged(renderer, headerRenderer, footerRenderer) {
    this.$.overlay.setProperties({ owner: this, renderer, headerRenderer, footerRenderer });
  }
  /** @private */
  _openedChanged(opened) {
    this.$.overlay.opened = opened;
  }
  /** @private */
  _ariaLabelChanged(ariaLabel, headerTitle) {
    if (ariaLabel || headerTitle) {
      this.$.overlay.setAttribute("aria-label", ariaLabel || headerTitle);
    } else {
      this.$.overlay.removeAttribute("aria-label");
    }
  }
};
defineCustomElement(Dialog);

export {
  DialogOverlay,
  Dialog
};
/*! Bundled license information:

@vaadin/dialog/src/vaadin-dialog-overlay-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/dialog/src/vaadin-dialog-overlay.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/dialog/src/vaadin-dialog-utils.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/dialog/src/vaadin-dialog-draggable-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/dialog/src/vaadin-dialog-renderer-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/dialog/src/vaadin-dialog-resizable-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/dialog/src/vaadin-dialog.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-COJEYEIQ.js.map
