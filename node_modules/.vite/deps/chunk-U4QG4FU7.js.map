{
  "version": 3,
  "sources": ["../../@vaadin/item/node_modules/@vaadin/component-base/src/async.js", "../../@vaadin/item/node_modules/@vaadin/component-base/src/gestures.js", "../../@vaadin/item/node_modules/@vaadin/a11y-base/src/disabled-mixin.js", "../../@vaadin/item/node_modules/@vaadin/a11y-base/src/keyboard-mixin.js", "../../@vaadin/item/node_modules/@vaadin/a11y-base/src/active-mixin.js", "../../@vaadin/item/node_modules/@vaadin/a11y-base/src/focus-utils.js", "../../@vaadin/item/node_modules/@vaadin/a11y-base/src/focus-mixin.js", "../../@vaadin/item/src/vaadin-item-mixin.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n/**\r\n * @fileoverview\r\n *\r\n * This module provides a number of strategies for enqueuing asynchronous\r\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\r\n * handle, and a `cancel(handle)` interface for canceling async tasks before\r\n * they run.\r\n *\r\n * @summary Module that provides a number of strategies for enqueuing\r\n * asynchronous tasks.\r\n */\r\n\r\nlet microtaskCurrHandle = 0;\r\nlet microtaskLastHandle = 0;\r\nconst microtaskCallbacks = [];\r\nlet microtaskScheduled = false;\r\n\r\nfunction microtaskFlush() {\r\n  microtaskScheduled = false;\r\n  const len = microtaskCallbacks.length;\r\n  for (let i = 0; i < len; i++) {\r\n    const cb = microtaskCallbacks[i];\r\n    if (cb) {\r\n      try {\r\n        cb();\r\n      } catch (e) {\r\n        setTimeout(() => {\r\n          throw e;\r\n        });\r\n      }\r\n    }\r\n  }\r\n  microtaskCallbacks.splice(0, len);\r\n  microtaskLastHandle += len;\r\n}\r\n\r\n/**\r\n * Async interface wrapper around `setTimeout`.\r\n *\r\n * @namespace\r\n * @summary Async interface wrapper around `setTimeout`.\r\n */\r\nconst timeOut = {\r\n  /**\r\n   * Returns a sub-module with the async interface providing the provided\r\n   * delay.\r\n   *\r\n   * @memberof timeOut\r\n   * @param {number=} delay Time to wait before calling callbacks in ms\r\n   * @return {!AsyncInterface} An async timeout interface\r\n   */\r\n  after(delay) {\r\n    return {\r\n      run(fn) {\r\n        return window.setTimeout(fn, delay);\r\n      },\r\n      cancel(handle) {\r\n        window.clearTimeout(handle);\r\n      },\r\n    };\r\n  },\r\n  /**\r\n   * Enqueues a function called in the next task.\r\n   *\r\n   * @memberof timeOut\r\n   * @param {!Function} fn Callback to run\r\n   * @param {number=} delay Delay in milliseconds\r\n   * @return {number} Handle used for canceling task\r\n   */\r\n  run(fn, delay) {\r\n    return window.setTimeout(fn, delay);\r\n  },\r\n  /**\r\n   * Cancels a previously enqueued `timeOut` callback.\r\n   *\r\n   * @memberof timeOut\r\n   * @param {number} handle Handle returned from `run` of callback to cancel\r\n   * @return {void}\r\n   */\r\n  cancel(handle) {\r\n    window.clearTimeout(handle);\r\n  },\r\n};\r\nexport { timeOut };\r\n\r\n/**\r\n * Async interface wrapper around `requestAnimationFrame`.\r\n *\r\n * @namespace\r\n * @summary Async interface wrapper around `requestAnimationFrame`.\r\n */\r\nconst animationFrame = {\r\n  /**\r\n   * Enqueues a function called at `requestAnimationFrame` timing.\r\n   *\r\n   * @memberof animationFrame\r\n   * @param {function(number):void} fn Callback to run\r\n   * @return {number} Handle used for canceling task\r\n   */\r\n  run(fn) {\r\n    return window.requestAnimationFrame(fn);\r\n  },\r\n  /**\r\n   * Cancels a previously enqueued `animationFrame` callback.\r\n   *\r\n   * @memberof animationFrame\r\n   * @param {number} handle Handle returned from `run` of callback to cancel\r\n   * @return {void}\r\n   */\r\n  cancel(handle) {\r\n    window.cancelAnimationFrame(handle);\r\n  },\r\n};\r\nexport { animationFrame };\r\n\r\n/**\r\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\r\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\r\n *\r\n * @namespace\r\n * @summary Async interface wrapper around `requestIdleCallback`.\r\n */\r\nconst idlePeriod = {\r\n  /**\r\n   * Enqueues a function called at `requestIdleCallback` timing.\r\n   *\r\n   * @memberof idlePeriod\r\n   * @param {function(!IdleDeadline):void} fn Callback to run\r\n   * @return {number} Handle used for canceling task\r\n   */\r\n  run(fn) {\r\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\r\n  },\r\n  /**\r\n   * Cancels a previously enqueued `idlePeriod` callback.\r\n   *\r\n   * @memberof idlePeriod\r\n   * @param {number} handle Handle returned from `run` of callback to cancel\r\n   * @return {void}\r\n   */\r\n  cancel(handle) {\r\n    if (window.cancelIdleCallback) {\r\n      window.cancelIdleCallback(handle);\r\n    } else {\r\n      window.clearTimeout(handle);\r\n    }\r\n  },\r\n};\r\nexport { idlePeriod };\r\n\r\n/**\r\n * Async interface for enqueuing callbacks that run at microtask timing.\r\n *\r\n * @namespace\r\n * @summary Async interface for enqueuing callbacks that run at microtask\r\n *   timing.\r\n */\r\nconst microTask = {\r\n  /**\r\n   * Enqueues a function called at microtask timing.\r\n   *\r\n   * @memberof microTask\r\n   * @param {!Function=} callback Callback to run\r\n   * @return {number} Handle used for canceling task\r\n   */\r\n  run(callback) {\r\n    if (!microtaskScheduled) {\r\n      microtaskScheduled = true;\r\n      queueMicrotask(() => microtaskFlush());\r\n    }\r\n    microtaskCallbacks.push(callback);\r\n    const result = microtaskCurrHandle;\r\n    microtaskCurrHandle += 1;\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Cancels a previously enqueued `microTask` callback.\r\n   *\r\n   * @memberof microTask\r\n   * @param {number} handle Handle returned from `run` of callback to cancel\r\n   * @return {void}\r\n   */\r\n  cancel(handle) {\r\n    const idx = handle - microtaskLastHandle;\r\n    if (idx >= 0) {\r\n      if (!microtaskCallbacks[idx]) {\r\n        throw new Error(`invalid async handle: ${handle}`);\r\n      }\r\n      microtaskCallbacks[idx] = null;\r\n    }\r\n  },\r\n};\r\nexport { microTask };\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/* eslint-disable @typescript-eslint/no-use-before-define */\r\n\r\n/**\r\n * @fileoverview\r\n *\r\n * Module for adding listeners to a node for the following normalized\r\n * cross-platform \"gesture\" events:\r\n * - `down` - mouse or touch went down\r\n * - `up` - mouse or touch went up\r\n * - `tap` - mouse click or finger tap\r\n * - `track` - mouse drag or touch move\r\n *\r\n * @summary Module for adding cross-platform gesture event listeners.\r\n */\r\n\r\nimport { microTask } from './async.js';\r\n\r\nconst passiveTouchGestures = false;\r\nconst wrap = (node) => node;\r\n\r\n// Detect native touch action support\r\nconst HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\r\nconst GESTURE_KEY = '__polymerGestures';\r\nconst HANDLED_OBJ = '__polymerGesturesHandled';\r\nconst TOUCH_ACTION = '__polymerGesturesTouchAction';\r\n// Radius for tap and track\r\nconst TAP_DISTANCE = 25;\r\nconst TRACK_DISTANCE = 5;\r\n// Number of last N track positions to keep\r\nconst TRACK_LENGTH = 2;\r\n\r\nconst MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\r\n// An array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\r\nconst MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\r\nconst MOUSE_HAS_BUTTONS = (function () {\r\n  try {\r\n    return new MouseEvent('test', { buttons: 1 }).buttons === 1;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n})();\r\n\r\n/**\r\n * @param {string} name Possible mouse event name\r\n * @return {boolean} true if mouse event, false if not\r\n */\r\nfunction isMouseEvent(name) {\r\n  return MOUSE_EVENTS.indexOf(name) > -1;\r\n}\r\n\r\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\r\n// check for passive event listeners\r\nlet supportsPassive = false;\r\n(function () {\r\n  try {\r\n    const opts = Object.defineProperty({}, 'passive', {\r\n      // eslint-disable-next-line getter-return\r\n      get() {\r\n        supportsPassive = true;\r\n      },\r\n    });\r\n    window.addEventListener('test', null, opts);\r\n    window.removeEventListener('test', null, opts);\r\n  } catch (_) {}\r\n})();\r\n\r\n/**\r\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\r\n *\r\n * @param {string} eventName Event name to determine if `{passive}` option is\r\n *   needed\r\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\r\n *   and removeEventListener\r\n */\r\nfunction PASSIVE_TOUCH(eventName) {\r\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\r\n    return;\r\n  }\r\n  if (HAS_NATIVE_TA && supportsPassive && passiveTouchGestures) {\r\n    return { passive: true };\r\n  }\r\n}\r\n\r\n// Check for touch-only devices\r\nconst IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u);\r\n\r\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\r\n/** @type {!Object<boolean>} */\r\nconst canBeDisabled = {\r\n  button: true,\r\n  command: true,\r\n  fieldset: true,\r\n  input: true,\r\n  keygen: true,\r\n  optgroup: true,\r\n  option: true,\r\n  select: true,\r\n  textarea: true,\r\n};\r\n\r\n/**\r\n * @param {MouseEvent} ev event to test for left mouse button down\r\n * @return {boolean} has left mouse button down\r\n */\r\nfunction hasLeftMouseButton(ev) {\r\n  const type = ev.type;\r\n  // Exit early if the event is not a mouse event\r\n  if (!isMouseEvent(type)) {\r\n    return false;\r\n  }\r\n  // Ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\r\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\r\n  if (type === 'mousemove') {\r\n    // Allow undefined for testing events\r\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\r\n    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\r\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\r\n    }\r\n    // Buttons is a bitmask, check that the left button bit is set (1)\r\n    return Boolean(buttons & 1);\r\n  }\r\n  // Allow undefined for testing events\r\n  const button = ev.button === undefined ? 0 : ev.button;\r\n  // Ev.button is 0 in mousedown/mouseup/click for left button activation\r\n  return button === 0;\r\n}\r\n\r\nfunction isSyntheticClick(ev) {\r\n  if (ev.type === 'click') {\r\n    // Ev.detail is 0 for HTMLElement.click in most browsers\r\n    if (ev.detail === 0) {\r\n      return true;\r\n    }\r\n    // In the worst case, check that the x/y position of the click is within\r\n    // the bounding box of the target of the event\r\n    // Thanks IE 10 >:(\r\n    const t = _findOriginalTarget(ev);\r\n    // Make sure the target of the event is an element so we can use getBoundingClientRect,\r\n    // if not, just assume it is a synthetic click\r\n    if (!t.nodeType || /** @type {Element} */ (t).nodeType !== Node.ELEMENT_NODE) {\r\n      return true;\r\n    }\r\n    const bcr = /** @type {Element} */ (t).getBoundingClientRect();\r\n    // Use page x/y to account for scrolling\r\n    const x = ev.pageX,\r\n      y = ev.pageY;\r\n    // Ev is a synthetic click if the position is outside the bounding box of the target\r\n    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);\r\n  }\r\n  return false;\r\n}\r\n\r\nconst POINTERSTATE = {\r\n  mouse: {\r\n    target: null,\r\n    mouseIgnoreJob: null,\r\n  },\r\n  touch: {\r\n    x: 0,\r\n    y: 0,\r\n    id: -1,\r\n    scrollDecided: false,\r\n  },\r\n};\r\n\r\nfunction firstTouchAction(ev) {\r\n  let ta = 'auto';\r\n  const path = getComposedPath(ev);\r\n  for (let i = 0, n; i < path.length; i++) {\r\n    n = path[i];\r\n    if (n[TOUCH_ACTION]) {\r\n      ta = n[TOUCH_ACTION];\r\n      break;\r\n    }\r\n  }\r\n  return ta;\r\n}\r\n\r\nfunction trackDocument(stateObj, movefn, upfn) {\r\n  stateObj.movefn = movefn;\r\n  stateObj.upfn = upfn;\r\n  document.addEventListener('mousemove', movefn);\r\n  document.addEventListener('mouseup', upfn);\r\n}\r\n\r\nfunction untrackDocument(stateObj) {\r\n  document.removeEventListener('mousemove', stateObj.movefn);\r\n  document.removeEventListener('mouseup', stateObj.upfn);\r\n  stateObj.movefn = null;\r\n  stateObj.upfn = null;\r\n}\r\n\r\n/**\r\n * Returns the composedPath for the given event.\r\n * @param {Event} event to process\r\n * @return {!Array<!EventTarget>} Path of the event\r\n */\r\nconst getComposedPath =\r\n  window.ShadyDOM && window.ShadyDOM.noPatch\r\n    ? window.ShadyDOM.composedPath\r\n    : (event) => (event.composedPath && event.composedPath()) || [];\r\n\r\n/** @type {!Object<string, !GestureRecognizer>} */\r\nexport const gestures = {};\r\n\r\n/** @type {!Array<!GestureRecognizer>} */\r\nexport const recognizers = [];\r\n\r\n/**\r\n * Finds the element rendered on the screen at the provided coordinates.\r\n *\r\n * Similar to `document.elementFromPoint`, but pierces through\r\n * shadow roots.\r\n *\r\n * @param {number} x Horizontal pixel coordinate\r\n * @param {number} y Vertical pixel coordinate\r\n * @return {Element} Returns the deepest shadowRoot inclusive element\r\n * found at the screen position given.\r\n */\r\nexport function deepTargetFind(x, y) {\r\n  let node = document.elementFromPoint(x, y);\r\n  let next = node;\r\n  // This code path is only taken when native ShadowDOM is used\r\n  // if there is a shadowroot, it may have a node at x/y\r\n  // if there is not a shadowroot, exit the loop\r\n  while (next && next.shadowRoot && !window.ShadyDOM) {\r\n    // If there is a node at x/y in the shadowroot, look deeper\r\n    const oldNext = next;\r\n    next = next.shadowRoot.elementFromPoint(x, y);\r\n    // On Safari, elementFromPoint may return the shadowRoot host\r\n    if (oldNext === next) {\r\n      break;\r\n    }\r\n    if (next) {\r\n      node = next;\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\n/**\r\n * A cheaper check than ev.composedPath()[0];\r\n *\r\n * @private\r\n * @param {Event|Touch} ev Event.\r\n * @return {EventTarget} Returns the event target.\r\n */\r\nfunction _findOriginalTarget(ev) {\r\n  const path = getComposedPath(/** @type {?Event} */ (ev));\r\n  // It shouldn't be, but sometimes path is empty (window on Safari).\r\n  return path.length > 0 ? path[0] : ev.target;\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {Event} ev Event.\r\n * @return {void}\r\n */\r\nfunction _handleNative(ev) {\r\n  const type = ev.type;\r\n  const node = ev.currentTarget;\r\n  const gobj = node[GESTURE_KEY];\r\n  if (!gobj) {\r\n    return;\r\n  }\r\n  const gs = gobj[type];\r\n  if (!gs) {\r\n    return;\r\n  }\r\n  if (!ev[HANDLED_OBJ]) {\r\n    ev[HANDLED_OBJ] = {};\r\n    if (type.startsWith('touch')) {\r\n      const t = ev.changedTouches[0];\r\n      if (type === 'touchstart') {\r\n        // Only handle the first finger\r\n        if (ev.touches.length === 1) {\r\n          POINTERSTATE.touch.id = t.identifier;\r\n        }\r\n      }\r\n      if (POINTERSTATE.touch.id !== t.identifier) {\r\n        return;\r\n      }\r\n      if (!HAS_NATIVE_TA) {\r\n        if (type === 'touchstart' || type === 'touchmove') {\r\n          _handleTouchAction(ev);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  const handled = ev[HANDLED_OBJ];\r\n  // Used to ignore synthetic mouse events\r\n  if (handled.skip) {\r\n    return;\r\n  }\r\n  // Reset recognizer state\r\n  for (let i = 0, r; i < recognizers.length; i++) {\r\n    r = recognizers[i];\r\n    if (gs[r.name] && !handled[r.name]) {\r\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\r\n        r.reset();\r\n      }\r\n    }\r\n  }\r\n  // Enforce gesture recognizer order\r\n  for (let i = 0, r; i < recognizers.length; i++) {\r\n    r = recognizers[i];\r\n    if (gs[r.name] && !handled[r.name]) {\r\n      handled[r.name] = true;\r\n      r[type](ev);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {TouchEvent} ev Event.\r\n * @return {void}\r\n */\r\nfunction _handleTouchAction(ev) {\r\n  const t = ev.changedTouches[0];\r\n  const type = ev.type;\r\n  if (type === 'touchstart') {\r\n    POINTERSTATE.touch.x = t.clientX;\r\n    POINTERSTATE.touch.y = t.clientY;\r\n    POINTERSTATE.touch.scrollDecided = false;\r\n  } else if (type === 'touchmove') {\r\n    if (POINTERSTATE.touch.scrollDecided) {\r\n      return;\r\n    }\r\n    POINTERSTATE.touch.scrollDecided = true;\r\n    const ta = firstTouchAction(ev);\r\n    let shouldPrevent = false;\r\n    const dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\r\n    const dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\r\n    if (!ev.cancelable) {\r\n      // Scrolling is happening\r\n    } else if (ta === 'none') {\r\n      shouldPrevent = true;\r\n    } else if (ta === 'pan-x') {\r\n      shouldPrevent = dy > dx;\r\n    } else if (ta === 'pan-y') {\r\n      shouldPrevent = dx > dy;\r\n    }\r\n    if (shouldPrevent) {\r\n      ev.preventDefault();\r\n    } else {\r\n      prevent('track');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Adds an event listener to a node for the given gesture type.\r\n *\r\n * @param {!EventTarget} node Node to add listener on\r\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\r\n * @param {!function(!Event):void} handler Event listener function to call\r\n * @return {boolean} Returns true if a gesture event listener was added.\r\n */\r\nexport function addListener(node, evType, handler) {\r\n  if (gestures[evType]) {\r\n    _add(node, evType, handler);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Removes an event listener from a node for the given gesture type.\r\n *\r\n * @param {!EventTarget} node Node to remove listener from\r\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\r\n * @param {!function(!Event):void} handler Event listener function previously passed to\r\n *  `addListener`.\r\n * @return {boolean} Returns true if a gesture event listener was removed.\r\n */\r\nexport function removeListener(node, evType, handler) {\r\n  if (gestures[evType]) {\r\n    _remove(node, evType, handler);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Automate the event listeners for the native events\r\n *\r\n * @private\r\n * @param {!EventTarget} node Node on which to add the event.\r\n * @param {string} evType Event type to add.\r\n * @param {function(!Event)} handler Event handler function.\r\n * @return {void}\r\n */\r\nfunction _add(node, evType, handler) {\r\n  const recognizer = gestures[evType];\r\n  const deps = recognizer.deps;\r\n  const name = recognizer.name;\r\n  let gobj = node[GESTURE_KEY];\r\n  if (!gobj) {\r\n    node[GESTURE_KEY] = gobj = {};\r\n  }\r\n  for (let i = 0, dep, gd; i < deps.length; i++) {\r\n    dep = deps[i];\r\n    // Don't add mouse handlers on iOS because they cause gray selection overlays\r\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\r\n      continue;\r\n    }\r\n    gd = gobj[dep];\r\n    if (!gd) {\r\n      gobj[dep] = gd = { _count: 0 };\r\n    }\r\n    if (gd._count === 0) {\r\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\r\n    }\r\n    gd[name] = (gd[name] || 0) + 1;\r\n    gd._count = (gd._count || 0) + 1;\r\n  }\r\n  node.addEventListener(evType, handler);\r\n  if (recognizer.touchAction) {\r\n    setTouchAction(node, recognizer.touchAction);\r\n  }\r\n}\r\n\r\n/**\r\n * Automate event listener removal for native events\r\n *\r\n * @private\r\n * @param {!EventTarget} node Node on which to remove the event.\r\n * @param {string} evType Event type to remove.\r\n * @param {function(!Event): void} handler Event handler function.\r\n * @return {void}\r\n */\r\nfunction _remove(node, evType, handler) {\r\n  const recognizer = gestures[evType];\r\n  const deps = recognizer.deps;\r\n  const name = recognizer.name;\r\n  const gobj = node[GESTURE_KEY];\r\n  if (gobj) {\r\n    for (let i = 0, dep, gd; i < deps.length; i++) {\r\n      dep = deps[i];\r\n      gd = gobj[dep];\r\n      if (gd && gd[name]) {\r\n        gd[name] = (gd[name] || 1) - 1;\r\n        gd._count = (gd._count || 1) - 1;\r\n        if (gd._count === 0) {\r\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  node.removeEventListener(evType, handler);\r\n}\r\n\r\n/**\r\n * Registers a new gesture event recognizer for adding new custom\r\n * gesture event types.\r\n *\r\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\r\n * @return {void}\r\n */\r\nexport function register(recog) {\r\n  recognizers.push(recog);\r\n  recog.emits.forEach((emit) => {\r\n    gestures[emit] = recog;\r\n  });\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {string} evName Event name.\r\n * @return {Object} Returns the gesture for the given event name.\r\n */\r\nfunction _findRecognizerByEvent(evName) {\r\n  for (let i = 0, r; i < recognizers.length; i++) {\r\n    r = recognizers[i];\r\n    for (let j = 0, n; j < r.emits.length; j++) {\r\n      n = r.emits[j];\r\n      if (n === evName) {\r\n        return r;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Sets scrolling direction on node.\r\n *\r\n * This value is checked on first move, thus it should be called prior to\r\n * adding event listeners.\r\n *\r\n * @param {!EventTarget} node Node to set touch action setting on\r\n * @param {string} value Touch action value\r\n * @return {void}\r\n */\r\nexport function setTouchAction(node, value) {\r\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\r\n    // NOTE: add touchAction async so that events can be added in\r\n    // custom element constructors. Otherwise we run afoul of custom\r\n    // elements restriction against settings attributes (style) in the\r\n    // constructor.\r\n    microTask.run(() => {\r\n      node.style.touchAction = value;\r\n    });\r\n  }\r\n  node[TOUCH_ACTION] = value;\r\n}\r\n\r\n/**\r\n * Dispatches an event on the `target` element of `type` with the given\r\n * `detail`.\r\n * @private\r\n * @param {!EventTarget} target The element on which to fire an event.\r\n * @param {string} type The type of event to fire.\r\n * @param {!Object=} detail The detail object to populate on the event.\r\n * @return {void}\r\n */\r\nfunction _fire(target, type, detail) {\r\n  const ev = new Event(type, { bubbles: true, cancelable: true, composed: true });\r\n  ev.detail = detail;\r\n  wrap(/** @type {!Node} */ (target)).dispatchEvent(ev);\r\n  // Forward `preventDefault` in a clean way\r\n  if (ev.defaultPrevented) {\r\n    const preventer = detail.preventer || detail.sourceEvent;\r\n    if (preventer && preventer.preventDefault) {\r\n      preventer.preventDefault();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Prevents the dispatch and default action of the given event name.\r\n *\r\n * @param {string} evName Event name.\r\n * @return {void}\r\n */\r\nexport function prevent(evName) {\r\n  const recognizer = _findRecognizerByEvent(evName);\r\n  if (recognizer.info) {\r\n    recognizer.info.prevent = true;\r\n  }\r\n}\r\n\r\nregister({\r\n  name: 'downup',\r\n  deps: ['mousedown', 'touchstart', 'touchend'],\r\n  flow: {\r\n    start: ['mousedown', 'touchstart'],\r\n    end: ['mouseup', 'touchend'],\r\n  },\r\n  emits: ['down', 'up'],\r\n\r\n  info: {\r\n    movefn: null,\r\n    upfn: null,\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @return {void}\r\n   */\r\n  reset() {\r\n    untrackDocument(this.info);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  mousedown(e) {\r\n    if (!hasLeftMouseButton(e)) {\r\n      return;\r\n    }\r\n    const t = _findOriginalTarget(e);\r\n    const self = this;\r\n    const movefn = (e) => {\r\n      if (!hasLeftMouseButton(e)) {\r\n        downupFire('up', t, e);\r\n        untrackDocument(self.info);\r\n      }\r\n    };\r\n    const upfn = (e) => {\r\n      if (hasLeftMouseButton(e)) {\r\n        downupFire('up', t, e);\r\n      }\r\n      untrackDocument(self.info);\r\n    };\r\n    trackDocument(this.info, movefn, upfn);\r\n    downupFire('down', t, e);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchstart(e) {\r\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchend(e) {\r\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\r\n  },\r\n});\r\n\r\n/**\r\n * @param {string} type\r\n * @param {EventTarget} target\r\n * @param {Event|Touch} event\r\n * @param {Event=} preventer\r\n * @return {void}\r\n */\r\nfunction downupFire(type, target, event, preventer) {\r\n  if (!target) {\r\n    return;\r\n  }\r\n  _fire(target, type, {\r\n    x: event.clientX,\r\n    y: event.clientY,\r\n    sourceEvent: event,\r\n    preventer,\r\n    prevent(e) {\r\n      return prevent(e);\r\n    },\r\n  });\r\n}\r\n\r\nregister({\r\n  name: 'track',\r\n  touchAction: 'none',\r\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\r\n  flow: {\r\n    start: ['mousedown', 'touchstart'],\r\n    end: ['mouseup', 'touchend'],\r\n  },\r\n  emits: ['track'],\r\n\r\n  info: {\r\n    x: 0,\r\n    y: 0,\r\n    state: 'start',\r\n    started: false,\r\n    moves: [],\r\n    /** @this {GestureInfo} */\r\n    addMove(move) {\r\n      if (this.moves.length > TRACK_LENGTH) {\r\n        this.moves.shift();\r\n      }\r\n      this.moves.push(move);\r\n    },\r\n    movefn: null,\r\n    upfn: null,\r\n    prevent: false,\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @return {void}\r\n   */\r\n  reset() {\r\n    this.info.state = 'start';\r\n    this.info.started = false;\r\n    this.info.moves = [];\r\n    this.info.x = 0;\r\n    this.info.y = 0;\r\n    this.info.prevent = false;\r\n    untrackDocument(this.info);\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  mousedown(e) {\r\n    if (!hasLeftMouseButton(e)) {\r\n      return;\r\n    }\r\n    const t = _findOriginalTarget(e);\r\n    const self = this;\r\n    const movefn = (e) => {\r\n      const x = e.clientX,\r\n        y = e.clientY;\r\n      if (trackHasMovedEnough(self.info, x, y)) {\r\n        // First move is 'start', subsequent moves are 'move', mouseup is 'end'\r\n        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';\r\n        if (self.info.state === 'start') {\r\n          // If and only if tracking, always prevent tap\r\n          prevent('tap');\r\n        }\r\n        self.info.addMove({ x, y });\r\n        if (!hasLeftMouseButton(e)) {\r\n          // Always fire \"end\"\r\n          self.info.state = 'end';\r\n          untrackDocument(self.info);\r\n        }\r\n        if (t) {\r\n          trackFire(self.info, t, e);\r\n        }\r\n        self.info.started = true;\r\n      }\r\n    };\r\n    const upfn = (e) => {\r\n      if (self.info.started) {\r\n        movefn(e);\r\n      }\r\n\r\n      // Remove the temporary listeners\r\n      untrackDocument(self.info);\r\n    };\r\n    // Add temporary document listeners as mouse retargets\r\n    trackDocument(this.info, movefn, upfn);\r\n    this.info.x = e.clientX;\r\n    this.info.y = e.clientY;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchstart(e) {\r\n    const ct = e.changedTouches[0];\r\n    this.info.x = ct.clientX;\r\n    this.info.y = ct.clientY;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchmove(e) {\r\n    const t = _findOriginalTarget(e);\r\n    const ct = e.changedTouches[0];\r\n    const x = ct.clientX,\r\n      y = ct.clientY;\r\n    if (trackHasMovedEnough(this.info, x, y)) {\r\n      if (this.info.state === 'start') {\r\n        // If and only if tracking, always prevent tap\r\n        prevent('tap');\r\n      }\r\n      this.info.addMove({ x, y });\r\n      trackFire(this.info, t, ct);\r\n      this.info.state = 'track';\r\n      this.info.started = true;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchend(e) {\r\n    const t = _findOriginalTarget(e);\r\n    const ct = e.changedTouches[0];\r\n    // Only trackend if track was started and not aborted\r\n    if (this.info.started) {\r\n      // Reset started state on up\r\n      this.info.state = 'end';\r\n      this.info.addMove({ x: ct.clientX, y: ct.clientY });\r\n      trackFire(this.info, t, ct);\r\n    }\r\n  },\r\n});\r\n\r\n/**\r\n * @param {!GestureInfo} info\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction trackHasMovedEnough(info, x, y) {\r\n  if (info.prevent) {\r\n    return false;\r\n  }\r\n  if (info.started) {\r\n    return true;\r\n  }\r\n  const dx = Math.abs(info.x - x);\r\n  const dy = Math.abs(info.y - y);\r\n  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\r\n}\r\n\r\n/**\r\n * @param {!GestureInfo} info\r\n * @param {?EventTarget} target\r\n * @param {Touch} touch\r\n * @return {void}\r\n */\r\nfunction trackFire(info, target, touch) {\r\n  if (!target) {\r\n    return;\r\n  }\r\n  const secondlast = info.moves[info.moves.length - 2];\r\n  const lastmove = info.moves[info.moves.length - 1];\r\n  const dx = lastmove.x - info.x;\r\n  const dy = lastmove.y - info.y;\r\n  let ddx,\r\n    ddy = 0;\r\n  if (secondlast) {\r\n    ddx = lastmove.x - secondlast.x;\r\n    ddy = lastmove.y - secondlast.y;\r\n  }\r\n  _fire(target, 'track', {\r\n    state: info.state,\r\n    x: touch.clientX,\r\n    y: touch.clientY,\r\n    dx,\r\n    dy,\r\n    ddx,\r\n    ddy,\r\n    sourceEvent: touch,\r\n    hover() {\r\n      return deepTargetFind(touch.clientX, touch.clientY);\r\n    },\r\n  });\r\n}\r\n\r\nregister({\r\n  name: 'tap',\r\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\r\n  flow: {\r\n    start: ['mousedown', 'touchstart'],\r\n    end: ['click', 'touchend'],\r\n  },\r\n  emits: ['tap'],\r\n  info: {\r\n    x: NaN,\r\n    y: NaN,\r\n    prevent: false,\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @return {void}\r\n   */\r\n  reset() {\r\n    this.info.x = NaN;\r\n    this.info.y = NaN;\r\n    this.info.prevent = false;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  mousedown(e) {\r\n    if (hasLeftMouseButton(e)) {\r\n      this.info.x = e.clientX;\r\n      this.info.y = e.clientY;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {MouseEvent} e\r\n   * @return {void}\r\n   */\r\n  click(e) {\r\n    if (hasLeftMouseButton(e)) {\r\n      trackForward(this.info, e);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchstart(e) {\r\n    const touch = e.changedTouches[0];\r\n    this.info.x = touch.clientX;\r\n    this.info.y = touch.clientY;\r\n  },\r\n\r\n  /**\r\n   * @this {GestureRecognizer}\r\n   * @param {TouchEvent} e\r\n   * @return {void}\r\n   */\r\n  touchend(e) {\r\n    trackForward(this.info, e.changedTouches[0], e);\r\n  },\r\n});\r\n\r\n/**\r\n * @param {!GestureInfo} info\r\n * @param {Event | Touch} e\r\n * @param {Event=} preventer\r\n * @return {void}\r\n */\r\nfunction trackForward(info, e, preventer) {\r\n  const dx = Math.abs(e.clientX - info.x);\r\n  const dy = Math.abs(e.clientY - info.y);\r\n  // Find original target from `preventer` for TouchEvents, or `e` for MouseEvents\r\n  const t = _findOriginalTarget(preventer || e);\r\n  if (!t || (canBeDisabled[/** @type {!HTMLElement} */ (t).localName] && t.hasAttribute('disabled'))) {\r\n    return;\r\n  }\r\n  // Dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\r\n  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {\r\n    // Prevent taps from being generated if an event has canceled them\r\n    if (!info.prevent) {\r\n      _fire(t, 'tap', {\r\n        x: e.clientX,\r\n        y: e.clientY,\r\n        sourceEvent: e,\r\n        preventer,\r\n      });\r\n    }\r\n  }\r\n}\r\n", "/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { dedupingMixin } from '@polymer/polymer/lib/utils/mixin.js';\r\n\r\n/**\r\n * A mixin to provide disabled property for field components.\r\n *\r\n * @polymerMixin\r\n */\r\nexport const DisabledMixin = dedupingMixin(\r\n  (superclass) =>\r\n    class DisabledMixinClass extends superclass {\r\n      static get properties() {\r\n        return {\r\n          /**\r\n           * If true, the user cannot interact with this element.\r\n           */\r\n          disabled: {\r\n            type: Boolean,\r\n            value: false,\r\n            observer: '_disabledChanged',\r\n            reflectToAttribute: true,\r\n            sync: true,\r\n          },\r\n        };\r\n      }\r\n\r\n      /**\r\n       * @param {boolean} disabled\r\n       * @protected\r\n       */\r\n      _disabledChanged(disabled) {\r\n        this._setAriaDisabled(disabled);\r\n      }\r\n\r\n      /**\r\n       * @param {boolean} disabled\r\n       * @protected\r\n       */\r\n      _setAriaDisabled(disabled) {\r\n        if (disabled) {\r\n          this.setAttribute('aria-disabled', 'true');\r\n        } else {\r\n          this.removeAttribute('aria-disabled');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Overrides the default element `click` method in order to prevent\r\n       * firing the `click` event when the element is disabled.\r\n       * @protected\r\n       * @override\r\n       */\r\n      click() {\r\n        if (!this.disabled) {\r\n          super.click();\r\n        }\r\n      }\r\n    },\r\n);\r\n", "/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { dedupingMixin } from '@polymer/polymer/lib/utils/mixin.js';\r\n\r\n/**\r\n * A mixin that manages keyboard handling.\r\n * The mixin subscribes to the keyboard events while an actual implementation\r\n * for the event handlers is left to the client (a component or another mixin).\r\n *\r\n * @polymerMixin\r\n */\r\nexport const KeyboardMixin = dedupingMixin(\r\n  (superclass) =>\r\n    class KeyboardMixinClass extends superclass {\r\n      /** @protected */\r\n      ready() {\r\n        super.ready();\r\n\r\n        this.addEventListener('keydown', (event) => {\r\n          this._onKeyDown(event);\r\n        });\r\n\r\n        this.addEventListener('keyup', (event) => {\r\n          this._onKeyUp(event);\r\n        });\r\n      }\r\n\r\n      /**\r\n       * A handler for the `keydown` event. By default, it calls\r\n       * separate methods for handling \"Enter\" and \"Escape\" keys.\r\n       * Override the method to implement your own behavior.\r\n       *\r\n       * @param {KeyboardEvent} event\r\n       * @protected\r\n       */\r\n      _onKeyDown(event) {\r\n        switch (event.key) {\r\n          case 'Enter':\r\n            this._onEnter(event);\r\n            break;\r\n          case 'Escape':\r\n            this._onEscape(event);\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * A handler for the `keyup` event. By default, it does nothing.\r\n       * Override the method to implement your own behavior.\r\n       *\r\n       * @param {KeyboardEvent} _event\r\n       * @protected\r\n       */\r\n      _onKeyUp(_event) {\r\n        // To be implemented.\r\n      }\r\n\r\n      /**\r\n       * A handler for the \"Enter\" key. By default, it does nothing.\r\n       * Override the method to implement your own behavior.\r\n       *\r\n       * @param {KeyboardEvent} _event\r\n       * @protected\r\n       */\r\n      _onEnter(_event) {\r\n        // To be implemented.\r\n      }\r\n\r\n      /**\r\n       * A handler for the \"Escape\" key. By default, it does nothing.\r\n       * Override the method to implement your own behavior.\r\n       *\r\n       * @param {KeyboardEvent} _event\r\n       * @protected\r\n       */\r\n      _onEscape(_event) {\r\n        // To be implemented.\r\n      }\r\n    },\r\n);\r\n", "/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { addListener } from '@vaadin/component-base/src/gestures.js';\r\nimport { DisabledMixin } from './disabled-mixin.js';\r\nimport { KeyboardMixin } from './keyboard-mixin.js';\r\n\r\n/**\r\n * A mixin to toggle the `active` attribute.\r\n *\r\n * The attribute is set whenever the user activates the element by a pointer\r\n * or presses an activation key on the element from the keyboard.\r\n *\r\n * The attribute is removed as soon as the element is deactivated\r\n * by the pointer or by releasing the activation key.\r\n *\r\n * @polymerMixin\r\n * @mixes DisabledMixin\r\n * @mixes KeyboardMixin\r\n */\r\nexport const ActiveMixin = (superclass) =>\r\n  class ActiveMixinClass extends DisabledMixin(KeyboardMixin(superclass)) {\r\n    /**\r\n     * An array of activation keys.\r\n     *\r\n     * See possible values here:\r\n     * https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent/key/Key_Values\r\n     *\r\n     * @protected\r\n     * @return {!Array<!string>}\r\n     */\r\n    get _activeKeys() {\r\n      return [' '];\r\n    }\r\n\r\n    /** @protected */\r\n    ready() {\r\n      super.ready();\r\n\r\n      addListener(this, 'down', (event) => {\r\n        if (this._shouldSetActive(event)) {\r\n          this._setActive(true);\r\n        }\r\n      });\r\n\r\n      addListener(this, 'up', () => {\r\n        this._setActive(false);\r\n      });\r\n    }\r\n\r\n    /** @protected */\r\n    disconnectedCallback() {\r\n      super.disconnectedCallback();\r\n\r\n      // When the element is disconnecting from the DOM at the moment being active,\r\n      // the `active` attribute needs to be manually removed from the element.\r\n      // Otherwise, it will preserve on the element until the element is activated once again.\r\n      // The case reproduces for `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.\r\n      this._setActive(false);\r\n    }\r\n\r\n    /**\r\n     * @param {KeyboardEvent | MouseEvent} _event\r\n     * @protected\r\n     */\r\n    _shouldSetActive(_event) {\r\n      return !this.disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the `active` attribute on the element if an activation key is pressed.\r\n     *\r\n     * @param {KeyboardEvent} event\r\n     * @protected\r\n     * @override\r\n     */\r\n    _onKeyDown(event) {\r\n      super._onKeyDown(event);\r\n\r\n      if (this._shouldSetActive(event) && this._activeKeys.includes(event.key)) {\r\n        this._setActive(true);\r\n\r\n        // Element can become hidden before the `keyup` event, e.g. on button click.\r\n        // Use document listener to ensure `active` attribute is removed correctly.\r\n        document.addEventListener(\r\n          'keyup',\r\n          (e) => {\r\n            if (this._activeKeys.includes(e.key)) {\r\n              this._setActive(false);\r\n            }\r\n          },\r\n          { once: true },\r\n        );\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Toggles the `active` attribute on the element.\r\n     *\r\n     * @param {boolean} active\r\n     * @protected\r\n     */\r\n    _setActive(active) {\r\n      this.toggleAttribute('active', active);\r\n    }\r\n  };\r\n", "/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\n\r\n// We consider the keyboard to be active if the window has received a keydown\r\n// event since the last mousedown event.\r\nlet keyboardActive = false;\r\n\r\n// Listen for top-level keydown and mousedown events.\r\n// Use capture phase so we detect events even if they're handled.\r\nwindow.addEventListener(\r\n  'keydown',\r\n  () => {\r\n    keyboardActive = true;\r\n  },\r\n  { capture: true },\r\n);\r\n\r\nwindow.addEventListener(\r\n  'mousedown',\r\n  () => {\r\n    keyboardActive = false;\r\n  },\r\n  { capture: true },\r\n);\r\n\r\n/**\r\n * Returns the actually focused element by traversing shadow\r\n * trees recursively to ensure it's the leaf element.\r\n *\r\n * @return {Element}\r\n */\r\nexport function getDeepActiveElement() {\r\n  let host = document.activeElement || document.body;\r\n  while (host.shadowRoot && host.shadowRoot.activeElement) {\r\n    host = host.shadowRoot.activeElement;\r\n  }\r\n  return host;\r\n}\r\n\r\n/**\r\n * Returns true if the window has received a keydown\r\n * event since the last mousedown event.\r\n *\r\n * @return {boolean}\r\n */\r\nexport function isKeyboardActive() {\r\n  return keyboardActive;\r\n}\r\n\r\n/**\r\n * Returns true if the element is hidden directly with `display: none` or `visibility: hidden`,\r\n * false otherwise.\r\n *\r\n * The method doesn't traverse the element's ancestors, it only checks for the CSS properties\r\n * set directly to or inherited by the element.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nfunction isElementHiddenDirectly(element) {\r\n  // Check inline style first to save a re-flow.\r\n  const style = element.style;\r\n  if (style.visibility === 'hidden' || style.display === 'none') {\r\n    return true;\r\n  }\r\n\r\n  const computedStyle = window.getComputedStyle(element);\r\n  if (computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns if element `a` has lower tab order compared to element `b`\r\n * (both elements are assumed to be focusable and tabbable).\r\n * Elements with tabindex = 0 have lower tab order compared to elements\r\n * with tabindex > 0.\r\n * If both have same tabindex, it returns false.\r\n *\r\n * @param {HTMLElement} a\r\n * @param {HTMLElement} b\r\n * @return {boolean}\r\n */\r\nfunction hasLowerTabOrder(a, b) {\r\n  // Normalize tabIndexes\r\n  // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\r\n  const ati = Math.max(a.tabIndex, 0);\r\n  const bti = Math.max(b.tabIndex, 0);\r\n  return ati === 0 || bti === 0 ? bti > ati : ati > bti;\r\n}\r\n\r\n/**\r\n * Merge sort iterator, merges the two arrays into one, sorted by tabindex.\r\n *\r\n * @param {HTMLElement[]} left\r\n * @param {HTMLElement[]} right\r\n * @return {HTMLElement[]}\r\n */\r\nfunction mergeSortByTabIndex(left, right) {\r\n  const result = [];\r\n  while (left.length > 0 && right.length > 0) {\r\n    if (hasLowerTabOrder(left[0], right[0])) {\r\n      result.push(right.shift());\r\n    } else {\r\n      result.push(left.shift());\r\n    }\r\n  }\r\n\r\n  return result.concat(left, right);\r\n}\r\n\r\n/**\r\n * Sorts an array of elements by tabindex. Returns a new array.\r\n *\r\n * @param {HTMLElement[]} elements\r\n * @return {HTMLElement[]}\r\n */\r\nfunction sortElementsByTabIndex(elements) {\r\n  // Implement a merge sort as Array.prototype.sort does a non-stable sort\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\r\n  const len = elements.length;\r\n  if (len < 2) {\r\n    return elements;\r\n  }\r\n  const pivot = Math.ceil(len / 2);\r\n  const left = sortElementsByTabIndex(elements.slice(0, pivot));\r\n  const right = sortElementsByTabIndex(elements.slice(pivot));\r\n\r\n  return mergeSortByTabIndex(left, right);\r\n}\r\n\r\n/**\r\n * Returns true if the element is hidden, false otherwise.\r\n *\r\n * An element is treated as hidden when any of the following conditions are met:\r\n * - the element itself or one of its ancestors has `display: none`.\r\n * - the element has or inherits `visibility: hidden`.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nexport function isElementHidden(element) {\r\n  if (element.checkVisibility) {\r\n    return !element.checkVisibility({ visibilityProperty: true });\r\n  }\r\n\r\n  // TODO: checkVisibility is supported only from Safari 17.4, so we still need to\r\n  // keep the custom implementation as a fallback for older versions until Vaadin 25:\r\n\r\n  // `offsetParent` is `null` when the element itself\r\n  // or one of its ancestors is hidden with `display: none`.\r\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\r\n  // However `offsetParent` is also null when the element is using fixed\r\n  // positioning, so additionally check if the element takes up layout space.\r\n  if (element.offsetParent === null && element.clientWidth === 0 && element.clientHeight === 0) {\r\n    return true;\r\n  }\r\n\r\n  return isElementHiddenDirectly(element);\r\n}\r\n\r\n/**\r\n * Returns true if the element is focusable, otherwise false.\r\n *\r\n * The list of focusable elements is taken from http://stackoverflow.com/a/1600194/4228703.\r\n * However, there isn't a definite list, it's up to the browser.\r\n * The only standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,\r\n * according to which the only elements that have a `focus()` method are:\r\n * - HTMLInputElement\r\n * - HTMLSelectElement\r\n * - HTMLTextAreaElement\r\n * - HTMLAnchorElement\r\n *\r\n * This notably omits HTMLButtonElement and HTMLAreaElement.\r\n * Referring to these tests with tabbables in different browsers\r\n * http://allyjs.io/data-tables/focusable.html\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nexport function isElementFocusable(element) {\r\n  // The element cannot be focused if its `tabindex` attribute is set to `-1`.\r\n  if (element.matches('[tabindex=\"-1\"]')) {\r\n    return false;\r\n  }\r\n\r\n  // Elements that cannot be focused if they have a `disabled` attribute.\r\n  if (element.matches('input, select, textarea, button, object')) {\r\n    return element.matches(':not([disabled])');\r\n  }\r\n\r\n  // Elements that can be focused even if they have a `disabled` attribute.\r\n  return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\r\n}\r\n\r\n/**\r\n * Returns true if the element is focused, false otherwise.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nexport function isElementFocused(element) {\r\n  return element.getRootNode().activeElement === element;\r\n}\r\n\r\n/**\r\n * Returns the normalized element tabindex. If not focusable, returns -1.\r\n * It checks for the attribute \"tabindex\" instead of the element property\r\n * `tabIndex` since browsers assign different values to it.\r\n * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\r\n *\r\n * @param {HTMLElement} element\r\n * @return {number}\r\n */\r\nfunction normalizeTabIndex(element) {\r\n  if (!isElementFocusable(element)) {\r\n    return -1;\r\n  }\r\n\r\n  const tabIndex = element.getAttribute('tabindex') || 0;\r\n  return Number(tabIndex);\r\n}\r\n\r\n/**\r\n * Searches for nodes that are tabbable and adds them to the `result` array.\r\n * Returns if the `result` array needs to be sorted by tabindex.\r\n *\r\n * @param {Node} node The starting point for the search; added to `result` if tabbable.\r\n * @param {HTMLElement[]} result\r\n * @return {boolean}\r\n * @private\r\n */\r\nfunction collectFocusableNodes(node, result) {\r\n  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {\r\n    // Don't traverse children if the node is not an HTML element or not visible.\r\n    return false;\r\n  }\r\n\r\n  const element = /** @type {HTMLElement} */ (node);\r\n  const tabIndex = normalizeTabIndex(element);\r\n  let needsSort = tabIndex > 0;\r\n  if (tabIndex >= 0) {\r\n    result.push(element);\r\n  }\r\n\r\n  let children = [];\r\n  if (element.localName === 'slot') {\r\n    children = element.assignedNodes({ flatten: true });\r\n  } else {\r\n    // Use shadow root if possible, will check for distributed nodes.\r\n    children = (element.shadowRoot || element).children;\r\n  }\r\n  [...children].forEach((child) => {\r\n    // Ensure method is always invoked to collect focusable children.\r\n    needsSort = collectFocusableNodes(child, result) || needsSort;\r\n  });\r\n  return needsSort;\r\n}\r\n\r\n/**\r\n * Returns a tab-ordered array of focusable elements for a root element.\r\n * The resulting array will include the root element if it is focusable.\r\n *\r\n * The method traverses nodes in shadow DOM trees too if any.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement[]}\r\n */\r\nexport function getFocusableElements(element) {\r\n  const focusableElements = [];\r\n  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);\r\n  // If there is at least one element with tabindex > 0,\r\n  // we need to sort the final array by tabindex.\r\n  if (needsSortByTabIndex) {\r\n    return sortElementsByTabIndex(focusableElements);\r\n  }\r\n  return focusableElements;\r\n}\r\n", "/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { dedupingMixin } from '@polymer/polymer/lib/utils/mixin.js';\r\nimport { isKeyboardActive } from './focus-utils.js';\r\n\r\n/**\r\n * A mixin to handle `focused` and `focus-ring` attributes based on focus.\r\n *\r\n * @polymerMixin\r\n */\r\nexport const FocusMixin = dedupingMixin(\r\n  (superclass) =>\r\n    class FocusMixinClass extends superclass {\r\n      /**\r\n       * @protected\r\n       * @return {boolean}\r\n       */\r\n      get _keyboardActive() {\r\n        return isKeyboardActive();\r\n      }\r\n\r\n      /** @protected */\r\n      ready() {\r\n        this.addEventListener('focusin', (e) => {\r\n          if (this._shouldSetFocus(e)) {\r\n            this._setFocused(true);\r\n          }\r\n        });\r\n\r\n        this.addEventListener('focusout', (e) => {\r\n          if (this._shouldRemoveFocus(e)) {\r\n            this._setFocused(false);\r\n          }\r\n        });\r\n\r\n        // In super.ready() other 'focusin' and 'focusout' listeners might be\r\n        // added, so we call it after our own ones to ensure they execute first.\r\n        // Issue to watch out: when incorrect, <vaadin-combo-box> refocuses the\r\n        // input field on iOS after \"Done\" is pressed.\r\n        super.ready();\r\n      }\r\n\r\n      /** @protected */\r\n      disconnectedCallback() {\r\n        super.disconnectedCallback();\r\n\r\n        // In non-Chrome browsers, blur does not fire on the element when it is disconnected.\r\n        // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.\r\n        if (this.hasAttribute('focused')) {\r\n          this._setFocused(false);\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Override to change how focused and focus-ring attributes are set.\r\n       *\r\n       * @param {boolean} focused\r\n       * @protected\r\n       */\r\n      _setFocused(focused) {\r\n        this.toggleAttribute('focused', focused);\r\n\r\n        // Focus-ring is true when the element was focused from the keyboard.\r\n        // Focus Ring [A11ycasts]: https://youtu.be/ilj2P5-5CjI\r\n        this.toggleAttribute('focus-ring', focused && this._keyboardActive);\r\n      }\r\n\r\n      /**\r\n       * Override to define if the field receives focus based on the event.\r\n       *\r\n       * @param {FocusEvent} _event\r\n       * @return {boolean}\r\n       * @protected\r\n       */\r\n      _shouldSetFocus(_event) {\r\n        return true;\r\n      }\r\n\r\n      /**\r\n       * Override to define if the field loses focus based on the event.\r\n       *\r\n       * @param {FocusEvent} _event\r\n       * @return {boolean}\r\n       * @protected\r\n       */\r\n      _shouldRemoveFocus(_event) {\r\n        return true;\r\n      }\r\n    },\r\n);\r\n", "/**\r\n * @license\r\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { ActiveMixin } from '@vaadin/a11y-base/src/active-mixin.js';\r\nimport { FocusMixin } from '@vaadin/a11y-base/src/focus-mixin.js';\r\n\r\n/**\r\n * A mixin providing `focused`, `focus-ring`, `active`, `disabled` and `selected`.\r\n *\r\n * `focused`, `active` and `focus-ring` are set as only as attributes.\r\n *\r\n * @polymerMixin\r\n * @mixes ActiveMixin\r\n * @mixes FocusMixin\r\n */\r\nexport const ItemMixin = (superClass) =>\r\n  class VaadinItemMixin extends ActiveMixin(FocusMixin(superClass)) {\r\n    static get properties() {\r\n      return {\r\n        /**\r\n         * Used for mixin detection because `instanceof` does not work with mixins.\r\n         * e.g. in VaadinListMixin it filters items by using the\r\n         * `element._hasVaadinItemMixin` condition.\r\n         * @type {boolean}\r\n         */\r\n        _hasVaadinItemMixin: {\r\n          value: true,\r\n        },\r\n\r\n        /**\r\n         * If true, the item is in selected state.\r\n         * @type {boolean}\r\n         */\r\n        selected: {\r\n          type: Boolean,\r\n          value: false,\r\n          reflectToAttribute: true,\r\n          observer: '_selectedChanged',\r\n          sync: true,\r\n        },\r\n\r\n        /** @private */\r\n        _value: String,\r\n      };\r\n    }\r\n\r\n    /**\r\n     * By default, `Space` is the only possible activation key for a focusable HTML element.\r\n     * Nonetheless, the item is an exception as it can be also activated by pressing `Enter`.\r\n     * See the \"Keyboard Support\" section in https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-1/menubar-1.html.\r\n     *\r\n     * @protected\r\n     * @override\r\n     */\r\n    get _activeKeys() {\r\n      return ['Enter', ' '];\r\n    }\r\n\r\n    /**\r\n     * @return {string}\r\n     */\r\n    get value() {\r\n      return this._value !== undefined ? this._value : this.textContent.trim();\r\n    }\r\n\r\n    /**\r\n     * @param {string} value\r\n     */\r\n    set value(value) {\r\n      this._value = value;\r\n    }\r\n\r\n    /** @protected */\r\n    ready() {\r\n      super.ready();\r\n\r\n      const attrValue = this.getAttribute('value');\r\n      if (attrValue !== null) {\r\n        this.value = attrValue;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Override native `focus` to set focused attribute\r\n     * when focusing the item programmatically.\r\n     * @protected\r\n     * @override\r\n     */\r\n    focus() {\r\n      if (this.disabled) {\r\n        return;\r\n      }\r\n\r\n      super.focus();\r\n      this._setFocused(true);\r\n    }\r\n\r\n    /**\r\n     * @param {KeyboardEvent | MouseEvent} _event\r\n     * @protected\r\n     * @override\r\n     */\r\n    _shouldSetActive(event) {\r\n      return !this.disabled && !(event.type === 'keydown' && event.defaultPrevented);\r\n    }\r\n\r\n    /** @private */\r\n    _selectedChanged(selected) {\r\n      this.setAttribute('aria-selected', selected);\r\n    }\r\n\r\n    /**\r\n     * Override an observer from `DisabledMixin`.\r\n     * @protected\r\n     * @override\r\n     */\r\n    _disabledChanged(disabled) {\r\n      super._disabledChanged(disabled);\r\n\r\n      if (disabled) {\r\n        this.selected = false;\r\n        this.blur();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * In order to be fully accessible from the keyboard, the item should\r\n     * manually fire the `click` event once an activation key is pressed.\r\n     *\r\n     * According to the UI Events specifications,\r\n     * the `click` event should be fired exactly on `keydown`:\r\n     * https://www.w3.org/TR/uievents/#event-type-keydown\r\n     *\r\n     * @param {KeyboardEvent} event\r\n     * @protected\r\n     * @override\r\n     */\r\n    _onKeyDown(event) {\r\n      super._onKeyDown(event);\r\n\r\n      if (this._activeKeys.includes(event.key) && !event.defaultPrevented) {\r\n        event.preventDefault();\r\n\r\n        // `DisabledMixin` overrides the standard `click()` method\r\n        // so that it doesn't fire the `click` event when the element is disabled.\r\n        this.click();\r\n      }\r\n    }\r\n  };\r\n"],
  "mappings": "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",
  "names": ["e"]
}
