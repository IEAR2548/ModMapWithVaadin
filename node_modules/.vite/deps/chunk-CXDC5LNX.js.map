{
  "version": 3,
  "sources": ["../../@vaadin/a11y-base/src/focus-utils.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\n\r\n// We consider the keyboard to be active if the window has received a keydown\r\n// event since the last mousedown event.\r\nlet keyboardActive = false;\r\n\r\n// Listen for top-level keydown and mousedown events.\r\n// Use capture phase so we detect events even if they're handled.\r\nwindow.addEventListener(\r\n  'keydown',\r\n  () => {\r\n    keyboardActive = true;\r\n  },\r\n  { capture: true },\r\n);\r\n\r\nwindow.addEventListener(\r\n  'mousedown',\r\n  () => {\r\n    keyboardActive = false;\r\n  },\r\n  { capture: true },\r\n);\r\n\r\n/**\r\n * Returns the actually focused element by traversing shadow\r\n * trees recursively to ensure it's the leaf element.\r\n *\r\n * @return {Element}\r\n */\r\nexport function getDeepActiveElement() {\r\n  let host = document.activeElement || document.body;\r\n  while (host.shadowRoot && host.shadowRoot.activeElement) {\r\n    host = host.shadowRoot.activeElement;\r\n  }\r\n  return host;\r\n}\r\n\r\n/**\r\n * Returns true if the window has received a keydown\r\n * event since the last mousedown event.\r\n *\r\n * @return {boolean}\r\n */\r\nexport function isKeyboardActive() {\r\n  return keyboardActive;\r\n}\r\n\r\n/**\r\n * Returns true if the element is hidden directly with `display: none` or `visibility: hidden`,\r\n * false otherwise.\r\n *\r\n * The method doesn't traverse the element's ancestors, it only checks for the CSS properties\r\n * set directly to or inherited by the element.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nfunction isElementHiddenDirectly(element) {\r\n  // Check inline style first to save a re-flow.\r\n  const style = element.style;\r\n  if (style.visibility === 'hidden' || style.display === 'none') {\r\n    return true;\r\n  }\r\n\r\n  const computedStyle = window.getComputedStyle(element);\r\n  if (computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns if element `a` has lower tab order compared to element `b`\r\n * (both elements are assumed to be focusable and tabbable).\r\n * Elements with tabindex = 0 have lower tab order compared to elements\r\n * with tabindex > 0.\r\n * If both have same tabindex, it returns false.\r\n *\r\n * @param {HTMLElement} a\r\n * @param {HTMLElement} b\r\n * @return {boolean}\r\n */\r\nfunction hasLowerTabOrder(a, b) {\r\n  // Normalize tabIndexes\r\n  // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\r\n  const ati = Math.max(a.tabIndex, 0);\r\n  const bti = Math.max(b.tabIndex, 0);\r\n  return ati === 0 || bti === 0 ? bti > ati : ati > bti;\r\n}\r\n\r\n/**\r\n * Merge sort iterator, merges the two arrays into one, sorted by tabindex.\r\n *\r\n * @param {HTMLElement[]} left\r\n * @param {HTMLElement[]} right\r\n * @return {HTMLElement[]}\r\n */\r\nfunction mergeSortByTabIndex(left, right) {\r\n  const result = [];\r\n  while (left.length > 0 && right.length > 0) {\r\n    if (hasLowerTabOrder(left[0], right[0])) {\r\n      result.push(right.shift());\r\n    } else {\r\n      result.push(left.shift());\r\n    }\r\n  }\r\n\r\n  return result.concat(left, right);\r\n}\r\n\r\n/**\r\n * Sorts an array of elements by tabindex. Returns a new array.\r\n *\r\n * @param {HTMLElement[]} elements\r\n * @return {HTMLElement[]}\r\n */\r\nfunction sortElementsByTabIndex(elements) {\r\n  // Implement a merge sort as Array.prototype.sort does a non-stable sort\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\r\n  const len = elements.length;\r\n  if (len < 2) {\r\n    return elements;\r\n  }\r\n  const pivot = Math.ceil(len / 2);\r\n  const left = sortElementsByTabIndex(elements.slice(0, pivot));\r\n  const right = sortElementsByTabIndex(elements.slice(pivot));\r\n\r\n  return mergeSortByTabIndex(left, right);\r\n}\r\n\r\n/**\r\n * Returns true if the element is hidden, false otherwise.\r\n *\r\n * An element is treated as hidden when any of the following conditions are met:\r\n * - the element itself or one of its ancestors has `display: none`.\r\n * - the element has or inherits `visibility: hidden`.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nexport function isElementHidden(element) {\r\n  if (element.checkVisibility) {\r\n    return !element.checkVisibility({ visibilityProperty: true });\r\n  }\r\n\r\n  // TODO: checkVisibility is supported only from Safari 17.4, so we still need to\r\n  // keep the custom implementation as a fallback for older versions until Vaadin 25:\r\n\r\n  // `offsetParent` is `null` when the element itself\r\n  // or one of its ancestors is hidden with `display: none`.\r\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\r\n  // However `offsetParent` is also null when the element is using fixed\r\n  // positioning, so additionally check if the element takes up layout space.\r\n  if (element.offsetParent === null && element.clientWidth === 0 && element.clientHeight === 0) {\r\n    return true;\r\n  }\r\n\r\n  return isElementHiddenDirectly(element);\r\n}\r\n\r\n/**\r\n * Returns true if the element is focusable, otherwise false.\r\n *\r\n * The list of focusable elements is taken from http://stackoverflow.com/a/1600194/4228703.\r\n * However, there isn't a definite list, it's up to the browser.\r\n * The only standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,\r\n * according to which the only elements that have a `focus()` method are:\r\n * - HTMLInputElement\r\n * - HTMLSelectElement\r\n * - HTMLTextAreaElement\r\n * - HTMLAnchorElement\r\n *\r\n * This notably omits HTMLButtonElement and HTMLAreaElement.\r\n * Referring to these tests with tabbables in different browsers\r\n * http://allyjs.io/data-tables/focusable.html\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nexport function isElementFocusable(element) {\r\n  // The element cannot be focused if its `tabindex` attribute is set to `-1`.\r\n  if (element.matches('[tabindex=\"-1\"]')) {\r\n    return false;\r\n  }\r\n\r\n  // Elements that cannot be focused if they have a `disabled` attribute.\r\n  if (element.matches('input, select, textarea, button, object')) {\r\n    return element.matches(':not([disabled])');\r\n  }\r\n\r\n  // Elements that can be focused even if they have a `disabled` attribute.\r\n  return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\r\n}\r\n\r\n/**\r\n * Returns true if the element is focused, false otherwise.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {boolean}\r\n */\r\nexport function isElementFocused(element) {\r\n  return element.getRootNode().activeElement === element;\r\n}\r\n\r\n/**\r\n * Returns the normalized element tabindex. If not focusable, returns -1.\r\n * It checks for the attribute \"tabindex\" instead of the element property\r\n * `tabIndex` since browsers assign different values to it.\r\n * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\r\n *\r\n * @param {HTMLElement} element\r\n * @return {number}\r\n */\r\nfunction normalizeTabIndex(element) {\r\n  if (!isElementFocusable(element)) {\r\n    return -1;\r\n  }\r\n\r\n  const tabIndex = element.getAttribute('tabindex') || 0;\r\n  return Number(tabIndex);\r\n}\r\n\r\n/**\r\n * Searches for nodes that are tabbable and adds them to the `result` array.\r\n * Returns if the `result` array needs to be sorted by tabindex.\r\n *\r\n * @param {Node} node The starting point for the search; added to `result` if tabbable.\r\n * @param {HTMLElement[]} result\r\n * @return {boolean}\r\n * @private\r\n */\r\nfunction collectFocusableNodes(node, result) {\r\n  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {\r\n    // Don't traverse children if the node is not an HTML element or not visible.\r\n    return false;\r\n  }\r\n\r\n  const element = /** @type {HTMLElement} */ (node);\r\n  const tabIndex = normalizeTabIndex(element);\r\n  let needsSort = tabIndex > 0;\r\n  if (tabIndex >= 0) {\r\n    result.push(element);\r\n  }\r\n\r\n  let children = [];\r\n  if (element.localName === 'slot') {\r\n    children = element.assignedNodes({ flatten: true });\r\n  } else {\r\n    // Use shadow root if possible, will check for distributed nodes.\r\n    children = (element.shadowRoot || element).children;\r\n  }\r\n  [...children].forEach((child) => {\r\n    // Ensure method is always invoked to collect focusable children.\r\n    needsSort = collectFocusableNodes(child, result) || needsSort;\r\n  });\r\n  return needsSort;\r\n}\r\n\r\n/**\r\n * Returns a tab-ordered array of focusable elements for a root element.\r\n * The resulting array will include the root element if it is focusable.\r\n *\r\n * The method traverses nodes in shadow DOM trees too if any.\r\n *\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement[]}\r\n */\r\nexport function getFocusableElements(element) {\r\n  const focusableElements = [];\r\n  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);\r\n  // If there is at least one element with tabindex > 0,\r\n  // we need to sort the final array by tabindex.\r\n  if (needsSortByTabIndex) {\r\n    return sortElementsByTabIndex(focusableElements);\r\n  }\r\n  return focusableElements;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
