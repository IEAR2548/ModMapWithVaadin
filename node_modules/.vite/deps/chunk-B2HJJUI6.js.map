{
  "version": 3,
  "sources": ["../../@vaadin/overlay/src/vaadin-overlay-utils.js", "../../@vaadin/overlay/src/vaadin-overlay-position-mixin.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2024 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\n\r\n/**\r\n * Observe moving an element around on a page.\r\n *\r\n * Based on the idea from https://samthor.au/2021/observing-dom/ as implemented in Floating UI\r\n * https://github.com/floating-ui/floating-ui/blob/58ed169/packages/dom/src/autoUpdate.ts#L45\r\n *\r\n * @param {HTMLElement} element\r\n * @param {Function} callback\r\n * @return {Function}\r\n */\r\nexport function observeMove(element, callback) {\r\n  let io = null;\r\n\r\n  const root = document.documentElement;\r\n\r\n  function cleanup() {\r\n    io && io.disconnect();\r\n    io = null;\r\n  }\r\n\r\n  function refresh(skip = false, threshold = 1) {\r\n    cleanup();\r\n\r\n    const { left, top, width, height } = element.getBoundingClientRect();\r\n\r\n    if (!skip) {\r\n      callback();\r\n    }\r\n\r\n    if (!width || !height) {\r\n      return;\r\n    }\r\n\r\n    const insetTop = Math.floor(top);\r\n    const insetRight = Math.floor(root.clientWidth - (left + width));\r\n    const insetBottom = Math.floor(root.clientHeight - (top + height));\r\n    const insetLeft = Math.floor(left);\r\n\r\n    const rootMargin = `${-insetTop}px ${-insetRight}px ${-insetBottom}px ${-insetLeft}px`;\r\n\r\n    const options = {\r\n      rootMargin,\r\n      threshold: Math.max(0, Math.min(1, threshold)) || 1,\r\n    };\r\n\r\n    let isFirstUpdate = true;\r\n\r\n    function handleObserve(entries) {\r\n      let ratio = entries[0].intersectionRatio;\r\n\r\n      if (ratio !== threshold) {\r\n        if (!isFirstUpdate) {\r\n          return refresh();\r\n        }\r\n\r\n        // It's possible for the watched element to not be at perfect 1.0 visibility when we create\r\n        // the IntersectionObserver. This has a couple of causes:\r\n        //   - elements being on partial pixels\r\n        //   - elements being hidden offscreen (e.g., <html> has `overflow: hidden`)\r\n        //   - delays: if your DOM change occurs due to e.g., page resize, you can see elements\r\n        //     behind their actual position\r\n        //\r\n        // In all of these cases, refresh but with this lower ratio of threshold. When the element\r\n        // moves beneath _that_ new value, the user will get notified.\r\n        if (ratio === 0.0) {\r\n          ratio = 0.0000001; // Just needs to be non-zero\r\n        }\r\n\r\n        refresh(false, ratio);\r\n      }\r\n\r\n      isFirstUpdate = false;\r\n    }\r\n\r\n    io = new IntersectionObserver(handleObserve, options);\r\n\r\n    io.observe(element);\r\n  }\r\n\r\n  refresh(true);\r\n\r\n  return cleanup;\r\n}\r\n", "/**\r\n * @license\r\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\r\nimport { observeMove } from './vaadin-overlay-utils.js';\r\n\r\nconst PROP_NAMES_VERTICAL = {\r\n  start: 'top',\r\n  end: 'bottom',\r\n};\r\n\r\nconst PROP_NAMES_HORIZONTAL = {\r\n  start: 'left',\r\n  end: 'right',\r\n};\r\n\r\nconst targetResizeObserver = new ResizeObserver((entries) => {\r\n  setTimeout(() => {\r\n    entries.forEach((entry) => {\r\n      if (entry.target.__overlay) {\r\n        entry.target.__overlay._updatePosition();\r\n      }\r\n    });\r\n  });\r\n});\r\n\r\n/**\r\n * @polymerMixin\r\n */\r\nexport const PositionMixin = (superClass) =>\r\n  class PositionMixin extends superClass {\r\n    static get properties() {\r\n      return {\r\n        /**\r\n         * The element next to which this overlay should be aligned.\r\n         * The position of the overlay relative to the positionTarget can be adjusted\r\n         * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\r\n         * and `noVerticalOverlap`.\r\n         */\r\n        positionTarget: {\r\n          type: Object,\r\n          value: null,\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * When `positionTarget` is set, this property defines whether to align the overlay's\r\n         * left or right side to the target element by default.\r\n         * Possible values are `start` and `end`.\r\n         * RTL is taken into account when interpreting the value.\r\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\r\n         * the default side defined by this property.\r\n         *\r\n         * @attr {start|end} horizontal-align\r\n         */\r\n        horizontalAlign: {\r\n          type: String,\r\n          value: 'start',\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * When `positionTarget` is set, this property defines whether to align the overlay's\r\n         * top or bottom side to the target element by default.\r\n         * Possible values are `top` and `bottom`.\r\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\r\n         * the default side defined by this property.\r\n         *\r\n         * @attr {top|bottom} vertical-align\r\n         */\r\n        verticalAlign: {\r\n          type: String,\r\n          value: 'top',\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\r\n         * the target element in the x-axis, or be positioned right next to it.\r\n         *\r\n         * @attr {boolean} no-horizontal-overlap\r\n         */\r\n        noHorizontalOverlap: {\r\n          type: Boolean,\r\n          value: false,\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\r\n         * the target element in the y-axis, or be positioned right above/below it.\r\n         *\r\n         * @attr {boolean} no-vertical-overlap\r\n         */\r\n        noVerticalOverlap: {\r\n          type: Boolean,\r\n          value: false,\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * If the overlay content has no intrinsic height, this property can be used to set\r\n         * the minimum vertical space (in pixels) required by the overlay. Setting a value to\r\n         * the property effectively disables the content measurement in favor of using this\r\n         * fixed value for determining the open direction.\r\n         *\r\n         * @attr {number} required-vertical-space\r\n         */\r\n        requiredVerticalSpace: {\r\n          type: Number,\r\n          value: 0,\r\n          sync: true,\r\n        },\r\n      };\r\n    }\r\n\r\n    static get observers() {\r\n      return [\r\n        '__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)',\r\n        '__overlayOpenedChanged(opened, positionTarget)',\r\n      ];\r\n    }\r\n\r\n    constructor() {\r\n      super();\r\n\r\n      this.__onScroll = this.__onScroll.bind(this);\r\n      this._updatePosition = this._updatePosition.bind(this);\r\n    }\r\n\r\n    /** @protected */\r\n    connectedCallback() {\r\n      super.connectedCallback();\r\n\r\n      if (this.opened) {\r\n        this.__addUpdatePositionEventListeners();\r\n      }\r\n    }\r\n\r\n    /** @protected */\r\n    disconnectedCallback() {\r\n      super.disconnectedCallback();\r\n      this.__removeUpdatePositionEventListeners();\r\n    }\r\n\r\n    /** @private */\r\n    __addUpdatePositionEventListeners() {\r\n      window.visualViewport.addEventListener('resize', this._updatePosition);\r\n      window.visualViewport.addEventListener('scroll', this.__onScroll, true);\r\n\r\n      this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\r\n      this.__positionTargetAncestorRootNodes.forEach((node) => {\r\n        node.addEventListener('scroll', this.__onScroll, true);\r\n      });\r\n\r\n      if (this.positionTarget) {\r\n        this.__observePositionTargetMove = observeMove(this.positionTarget, () => {\r\n          this._updatePosition();\r\n        });\r\n      }\r\n    }\r\n\r\n    /** @private */\r\n    __removeUpdatePositionEventListeners() {\r\n      window.visualViewport.removeEventListener('resize', this._updatePosition);\r\n      window.visualViewport.removeEventListener('scroll', this.__onScroll, true);\r\n\r\n      if (this.__positionTargetAncestorRootNodes) {\r\n        this.__positionTargetAncestorRootNodes.forEach((node) => {\r\n          node.removeEventListener('scroll', this.__onScroll, true);\r\n        });\r\n        this.__positionTargetAncestorRootNodes = null;\r\n      }\r\n\r\n      if (this.__observePositionTargetMove) {\r\n        this.__observePositionTargetMove();\r\n        this.__observePositionTargetMove = null;\r\n      }\r\n    }\r\n\r\n    /** @private */\r\n    __overlayOpenedChanged(opened, positionTarget) {\r\n      this.__removeUpdatePositionEventListeners();\r\n\r\n      if (positionTarget) {\r\n        positionTarget.__overlay = null;\r\n        targetResizeObserver.unobserve(positionTarget);\r\n\r\n        if (opened) {\r\n          this.__addUpdatePositionEventListeners();\r\n          positionTarget.__overlay = this;\r\n          targetResizeObserver.observe(positionTarget);\r\n        }\r\n      }\r\n\r\n      if (opened) {\r\n        const computedStyle = getComputedStyle(this);\r\n        if (!this.__margins) {\r\n          this.__margins = {};\r\n          ['top', 'bottom', 'left', 'right'].forEach((propName) => {\r\n            this.__margins[propName] = parseInt(computedStyle[propName], 10);\r\n          });\r\n        }\r\n\r\n        this._updatePosition();\r\n        // Schedule another position update (to cover virtual keyboard opening for example)\r\n        requestAnimationFrame(() => this._updatePosition());\r\n      }\r\n    }\r\n\r\n    __positionSettingsChanged() {\r\n      this._updatePosition();\r\n    }\r\n\r\n    /** @private */\r\n    __onScroll(e) {\r\n      // If the scroll event occurred inside the overlay, ignore it.\r\n      if (e.target instanceof Node && this.contains(e.target)) {\r\n        return;\r\n      }\r\n\r\n      this._updatePosition();\r\n    }\r\n\r\n    _updatePosition() {\r\n      if (!this.positionTarget || !this.opened || !this.__margins) {\r\n        return;\r\n      }\r\n\r\n      const targetRect = this.positionTarget.getBoundingClientRect();\r\n\r\n      if (targetRect.width === 0 && targetRect.height === 0 && this.opened) {\r\n        this.opened = false;\r\n        return;\r\n      }\r\n\r\n      // Detect the desired alignment and update the layout accordingly\r\n      const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\r\n      this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\r\n\r\n      const isRTL = this.__isRTL;\r\n      const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);\r\n      const flexStart = (!isRTL && shouldAlignStartHorizontally) || (isRTL && !shouldAlignStartHorizontally);\r\n      this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\r\n\r\n      // Get the overlay rect after possible overlay alignment changes\r\n      const overlayRect = this.getBoundingClientRect();\r\n\r\n      // Obtain vertical positioning properties\r\n      const verticalProps = this.__calculatePositionInOneDimension(\r\n        targetRect,\r\n        overlayRect,\r\n        this.noVerticalOverlap,\r\n        PROP_NAMES_VERTICAL,\r\n        this,\r\n        shouldAlignStartVertically,\r\n      );\r\n\r\n      // Obtain horizontal positioning properties\r\n      const horizontalProps = this.__calculatePositionInOneDimension(\r\n        targetRect,\r\n        overlayRect,\r\n        this.noHorizontalOverlap,\r\n        PROP_NAMES_HORIZONTAL,\r\n        this,\r\n        shouldAlignStartHorizontally,\r\n      );\r\n\r\n      // Apply the positioning properties to the overlay\r\n      Object.assign(this.style, verticalProps, horizontalProps);\r\n\r\n      this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\r\n      this.toggleAttribute('top-aligned', shouldAlignStartVertically);\r\n\r\n      this.toggleAttribute('end-aligned', !flexStart);\r\n      this.toggleAttribute('start-aligned', flexStart);\r\n    }\r\n\r\n    __shouldAlignStartHorizontally(targetRect, rtl) {\r\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\r\n      // smaller than its current space before the fit-calculations.\r\n      const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\r\n      this.__oldContentWidth = this.$.overlay.offsetWidth;\r\n\r\n      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\r\n      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');\r\n\r\n      return this.__shouldAlignStart(\r\n        targetRect,\r\n        contentWidth,\r\n        viewportWidth,\r\n        this.__margins,\r\n        defaultAlignLeft,\r\n        this.noHorizontalOverlap,\r\n        PROP_NAMES_HORIZONTAL,\r\n      );\r\n    }\r\n\r\n    __shouldAlignStartVertically(targetRect) {\r\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\r\n      // smaller than its current space before the fit-calculations.\r\n      const contentHeight =\r\n        this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\r\n      this.__oldContentHeight = this.$.overlay.offsetHeight;\r\n\r\n      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\r\n      const defaultAlignTop = this.verticalAlign === 'top';\r\n\r\n      return this.__shouldAlignStart(\r\n        targetRect,\r\n        contentHeight,\r\n        viewportHeight,\r\n        this.__margins,\r\n        defaultAlignTop,\r\n        this.noVerticalOverlap,\r\n        PROP_NAMES_VERTICAL,\r\n      );\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/max-params\r\n    __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\r\n      const spaceForStartAlignment =\r\n        viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\r\n      const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\r\n\r\n      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\r\n      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\r\n\r\n      const shouldGoToDefaultSide =\r\n        spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\r\n\r\n      return defaultAlignStart === shouldGoToDefaultSide;\r\n    }\r\n\r\n    /**\r\n     * Returns an adjusted value after resizing the browser window,\r\n     * to avoid wrong calculations when e.g. previously set `bottom`\r\n     * CSS property value is larger than the updated viewport height.\r\n     * See https://github.com/vaadin/web-components/issues/4604\r\n     */\r\n    __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\r\n      let adjustedProp;\r\n\r\n      if (cssPropNameToSet === propNames.end) {\r\n        // Adjust horizontally\r\n        if (propNames.end === PROP_NAMES_VERTICAL.end) {\r\n          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\r\n\r\n          if (currentValue > viewportHeight && this.__oldViewportHeight) {\r\n            const heightDiff = this.__oldViewportHeight - viewportHeight;\r\n            adjustedProp = currentValue - heightDiff;\r\n          }\r\n\r\n          this.__oldViewportHeight = viewportHeight;\r\n        }\r\n\r\n        // Adjust vertically\r\n        if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\r\n          const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\r\n\r\n          if (currentValue > viewportWidth && this.__oldViewportWidth) {\r\n            const widthDiff = this.__oldViewportWidth - viewportWidth;\r\n            adjustedProp = currentValue - widthDiff;\r\n          }\r\n\r\n          this.__oldViewportWidth = viewportWidth;\r\n        }\r\n      }\r\n\r\n      return adjustedProp;\r\n    }\r\n\r\n    /**\r\n     * Returns an object with CSS position properties to set,\r\n     * e.g. { top: \"100px\" }\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/max-params\r\n    __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\r\n      const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\r\n      const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\r\n\r\n      const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\r\n      const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\r\n\r\n      const diff =\r\n        overlayRect[shouldAlignStart ? propNames.start : propNames.end] -\r\n        targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\r\n\r\n      const valueToSet = adjustedValue\r\n        ? `${adjustedValue}px`\r\n        : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;\r\n\r\n      return {\r\n        [cssPropNameToSet]: valueToSet,\r\n        [cssPropNameToClear]: '',\r\n      };\r\n    }\r\n  };\r\n"],
  "mappings": "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",
  "names": []
}
