{
  "version": 3,
  "sources": ["../../ol/src/interaction/Property.js", "../../ol/src/interaction/Interaction.js", "../../ol/src/MapBrowserEventType.js", "../../ol/src/interaction/Pointer.js", "../../ol/src/events/condition.js", "../../ol/src/interaction/Translate.js"],
  "sourcesContent": ["/**\r\n * @module ol/interaction/Property\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  ACTIVE: 'active',\r\n};\r\n", "/**\r\n * @module ol/interaction/Interaction\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport InteractionProperty from './Property.js';\r\nimport {easeOut, linear} from '../easing.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active', Return>} InteractionOnSignature\r\n */\r\n\r\n/**\r\n * Object literal with config options for interactions.\r\n * @typedef {Object} InteractionOptions\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} handleEvent\r\n * Method called by the map to notify the interaction that a browser event was\r\n * dispatched to the map. If the function returns a falsy value, propagation of\r\n * the event to other interactions in the map's interactions chain will be\r\n * prevented (this includes functions with no explicit return). The interactions\r\n * are traversed in reverse order of the interactions collection of the map.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * User actions that change the state of the map. Some are similar to controls,\r\n * but are not associated with a DOM element.\r\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\r\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\r\n * by a keyboard event not a button element event.\r\n * Although interactions do not have a DOM element, some of them do render\r\n * vectors and so are visible on the screen.\r\n * @api\r\n */\r\nclass Interaction extends BaseObject {\r\n  /**\r\n   * @param {InteractionOptions} [opt_options] Options.\r\n   */\r\n  constructor(opt_options) {\r\n    super();\r\n\r\n    /***\r\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {InteractionOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    if (opt_options && opt_options.handleEvent) {\r\n      this.handleEvent = opt_options.handleEvent;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../PluggableMap.js\").default|null}\r\n     */\r\n    this.map_ = null;\r\n\r\n    this.setActive(true);\r\n  }\r\n\r\n  /**\r\n   * Return whether the interaction is currently active.\r\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getActive() {\r\n    return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));\r\n  }\r\n\r\n  /**\r\n   * Get the map associated with this interaction.\r\n   * @return {import(\"../PluggableMap.js\").default|null} Map.\r\n   * @api\r\n   */\r\n  getMap() {\r\n    return this.map_;\r\n  }\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @api\r\n   */\r\n  handleEvent(mapBrowserEvent) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Activate or deactivate the interaction.\r\n   * @param {boolean} active Active.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setActive(active) {\r\n    this.set(InteractionProperty.ACTIVE, active);\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../PluggableMap.js\").default|null} map Map.\r\n   */\r\n  setMap(map) {\r\n    this.map_ = map;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../View.js\").default} view View.\r\n * @param {import(\"../coordinate.js\").Coordinate} delta Delta.\r\n * @param {number} [opt_duration] Duration.\r\n */\r\nexport function pan(view, delta, opt_duration) {\r\n  const currentCenter = view.getCenterInternal();\r\n  if (currentCenter) {\r\n    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];\r\n    view.animateInternal({\r\n      duration: opt_duration !== undefined ? opt_duration : 250,\r\n      easing: linear,\r\n      center: view.getConstrainedCenter(center),\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../View.js\").default} view View.\r\n * @param {number} delta Delta from previous zoom level.\r\n * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] Anchor coordinate in the user projection.\r\n * @param {number} [opt_duration] Duration.\r\n */\r\nexport function zoomByDelta(view, delta, opt_anchor, opt_duration) {\r\n  const currentZoom = view.getZoom();\r\n\r\n  if (currentZoom === undefined) {\r\n    return;\r\n  }\r\n\r\n  const newZoom = view.getConstrainedZoom(currentZoom + delta);\r\n  const newResolution = view.getResolutionForZoom(newZoom);\r\n\r\n  if (view.getAnimating()) {\r\n    view.cancelAnimations();\r\n  }\r\n  view.animate({\r\n    resolution: newResolution,\r\n    anchor: opt_anchor,\r\n    duration: opt_duration !== undefined ? opt_duration : 250,\r\n    easing: easeOut,\r\n  });\r\n}\r\n\r\nexport default Interaction;\r\n", "/**\r\n * @module ol/MapBrowserEventType\r\n */\r\nimport EventType from './events/EventType.js';\r\n\r\n/**\r\n * Constants for event names.\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * A true single click with no dragging and no double click. Note that this\r\n   * event is delayed by 250 ms to ensure that it is not a double click.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick\r\n   * @api\r\n   */\r\n  SINGLECLICK: 'singleclick',\r\n\r\n  /**\r\n   * A click with no dragging. A double click will fire two of this.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click\r\n   * @api\r\n   */\r\n  CLICK: EventType.CLICK,\r\n\r\n  /**\r\n   * A true double click, with no dragging.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick\r\n   * @api\r\n   */\r\n  DBLCLICK: EventType.DBLCLICK,\r\n\r\n  /**\r\n   * Triggered when a pointer is dragged.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag\r\n   * @api\r\n   */\r\n  POINTERDRAG: 'pointerdrag',\r\n\r\n  /**\r\n   * Triggered when a pointer is moved. Note that on touch devices this is\r\n   * triggered when the map is panned, so is not the same as mousemove.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove\r\n   * @api\r\n   */\r\n  POINTERMOVE: 'pointermove',\r\n\r\n  POINTERDOWN: 'pointerdown',\r\n  POINTERUP: 'pointerup',\r\n  POINTEROVER: 'pointerover',\r\n  POINTEROUT: 'pointerout',\r\n  POINTERENTER: 'pointerenter',\r\n  POINTERLEAVE: 'pointerleave',\r\n  POINTERCANCEL: 'pointercancel',\r\n};\r\n\r\n/***\r\n * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types\r\n */\r\n", "/**\r\n * @module ol/interaction/Pointer\r\n */\r\nimport Interaction from './Interaction.js';\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\nimport {getValues} from '../obj.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleDownEvent]\r\n * Function handling \"down\" events. If the function returns `true` then a drag\r\n * sequence is started.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleDragEvent]\r\n * Function handling \"drag\" events. This function is called on \"move\" events\r\n * during a drag sequence.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\r\n * Method called by the map to notify the interaction that a browser event was\r\n * dispatched to the map. The function may return `false` to prevent the\r\n * propagation of the event to other interactions in the map's interactions\r\n * chain.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleMoveEvent]\r\n * Function handling \"move\" events. This function is called on \"move\" events.\r\n * This functions is also called during a drag sequence, so during a drag\r\n * sequence both the `handleDragEvent` function and this function are called.\r\n * If `handleDownEvent` is defined and it returns true this function will not\r\n * be called during a drag sequence.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleUpEvent]\r\n *  Function handling \"up\" events. If the function returns `false` then the\r\n * current drag sequence is stopped.\r\n * @property {function(boolean):boolean} [stopDown]\r\n * Should the down event be propagated to other interactions, or should be\r\n * stopped?\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class that calls user-defined functions on `down`, `move` and `up`\r\n * events. This class also manages \"drag sequences\".\r\n *\r\n * When the `handleDownEvent` user function returns `true` a drag sequence is\r\n * started. During a drag sequence the `handleDragEvent` user function is\r\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\r\n * user function is called and returns `false`.\r\n * @api\r\n */\r\nclass PointerInteraction extends Interaction {\r\n  /**\r\n   * @param {Options} [opt_options] Options.\r\n   */\r\n  constructor(opt_options) {\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    super(\r\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options)\r\n    );\r\n\r\n    if (options.handleDownEvent) {\r\n      this.handleDownEvent = options.handleDownEvent;\r\n    }\r\n\r\n    if (options.handleDragEvent) {\r\n      this.handleDragEvent = options.handleDragEvent;\r\n    }\r\n\r\n    if (options.handleMoveEvent) {\r\n      this.handleMoveEvent = options.handleMoveEvent;\r\n    }\r\n\r\n    if (options.handleUpEvent) {\r\n      this.handleUpEvent = options.handleUpEvent;\r\n    }\r\n\r\n    if (options.stopDown) {\r\n      this.stopDown = options.stopDown;\r\n    }\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @protected\r\n     */\r\n    this.handlingDownUpSequence = false;\r\n\r\n    /**\r\n     * @type {!Object<string, PointerEvent>}\r\n     * @private\r\n     */\r\n    this.trackedPointers_ = {};\r\n\r\n    /**\r\n     * @type {Array<PointerEvent>}\r\n     * @protected\r\n     */\r\n    this.targetPointers = [];\r\n  }\r\n\r\n  /**\r\n   * Returns the current number of pointers involved in the interaction,\r\n   * e.g. `2` when two fingers are used.\r\n   * @return {number} The number of pointers.\r\n   * @api\r\n   */\r\n  getPointerCount() {\r\n    return this.targetPointers.length;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @protected\r\n   */\r\n  handleDownEvent(mapBrowserEvent) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @protected\r\n   */\r\n  handleDragEvent(mapBrowserEvent) {}\r\n\r\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into\r\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\r\n   * detected.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @api\r\n   */\r\n  handleEvent(mapBrowserEvent) {\r\n    if (!mapBrowserEvent.originalEvent) {\r\n      return true;\r\n    }\r\n\r\n    let stopEvent = false;\r\n    this.updateTrackedPointers_(mapBrowserEvent);\r\n    if (this.handlingDownUpSequence) {\r\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\r\n        this.handleDragEvent(mapBrowserEvent);\r\n        // prevent page scrolling during dragging\r\n        mapBrowserEvent.originalEvent.preventDefault();\r\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\r\n        const handledUp = this.handleUpEvent(mapBrowserEvent);\r\n        this.handlingDownUpSequence =\r\n          handledUp && this.targetPointers.length > 0;\r\n      }\r\n    } else {\r\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\r\n        const handled = this.handleDownEvent(mapBrowserEvent);\r\n        this.handlingDownUpSequence = handled;\r\n        stopEvent = this.stopDown(handled);\r\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\r\n        this.handleMoveEvent(mapBrowserEvent);\r\n      }\r\n    }\r\n    return !stopEvent;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer move events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @protected\r\n   */\r\n  handleMoveEvent(mapBrowserEvent) {}\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @protected\r\n   */\r\n  handleUpEvent(mapBrowserEvent) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * This function is used to determine if \"down\" events should be propagated\r\n   * to other interactions or should be stopped.\r\n   * @param {boolean} handled Was the event handled by the interaction?\r\n   * @return {boolean} Should the `down` event be stopped?\r\n   */\r\n  stopDown(handled) {\r\n    return handled;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @private\r\n   */\r\n  updateTrackedPointers_(mapBrowserEvent) {\r\n    if (isPointerDraggingEvent(mapBrowserEvent)) {\r\n      const event = mapBrowserEvent.originalEvent;\r\n\r\n      const id = event.pointerId.toString();\r\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\r\n        delete this.trackedPointers_[id];\r\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\r\n        this.trackedPointers_[id] = event;\r\n      } else if (id in this.trackedPointers_) {\r\n        // update only when there was a pointerdown event for this pointer\r\n        this.trackedPointers_[id] = event;\r\n      }\r\n      this.targetPointers = getValues(this.trackedPointers_);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<PointerEvent>} pointerEvents List of events.\r\n * @return {import(\"../pixel.js\").Pixel} Centroid pixel.\r\n */\r\nexport function centroid(pointerEvents) {\r\n  const length = pointerEvents.length;\r\n  let clientX = 0;\r\n  let clientY = 0;\r\n  for (let i = 0; i < length; i++) {\r\n    clientX += pointerEvents[i].clientX;\r\n    clientY += pointerEvents[i].clientY;\r\n  }\r\n  return [clientX / length, clientY / length];\r\n}\r\n\r\n/**\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n * @return {boolean} Whether the event is a pointerdown, pointerdrag\r\n *     or pointerup event.\r\n */\r\nfunction isPointerDraggingEvent(mapBrowserEvent) {\r\n  const type = mapBrowserEvent.type;\r\n  return (\r\n    type === MapBrowserEventType.POINTERDOWN ||\r\n    type === MapBrowserEventType.POINTERDRAG ||\r\n    type === MapBrowserEventType.POINTERUP\r\n  );\r\n}\r\n\r\nexport default PointerInteraction;\r\n", "/**\r\n * @module ol/events/condition\r\n */\r\nimport MapBrowserEventType from '../MapBrowserEventType.js';\r\nimport {FALSE, TRUE} from '../functions.js';\r\nimport {MAC, WEBKIT} from '../has.js';\r\nimport {assert} from '../asserts.js';\r\n\r\n/**\r\n * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * `{boolean}`. If the condition is met, true should be returned.\r\n *\r\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default): boolean} Condition\r\n */\r\n\r\n/**\r\n * Creates a condition function that passes when all provided conditions pass.\r\n * @param {...Condition} var_args Conditions to check.\r\n * @return {Condition} Condition function.\r\n */\r\nexport function all(var_args) {\r\n  const conditions = arguments;\r\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} All conditions passed.\r\n   */\r\n  return function (event) {\r\n    let pass = true;\r\n    for (let i = 0, ii = conditions.length; i < ii; ++i) {\r\n      pass = pass && conditions[i](event);\r\n      if (!pass) {\r\n        break;\r\n      }\r\n    }\r\n    return pass;\r\n  };\r\n}\r\n\r\n/**\r\n * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\r\n * additionally the shift-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the alt key is pressed.\r\n * @api\r\n */\r\nexport const altKeyOnly = function (mapBrowserEvent) {\r\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\r\n    mapBrowserEvent.originalEvent\r\n  );\r\n  return (\r\n    originalEvent.altKey &&\r\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\r\n    !originalEvent.shiftKey\r\n  );\r\n};\r\n\r\n/**\r\n * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\r\n * (e.g. when additionally the platform-modifier-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the alt and shift keys are pressed.\r\n * @api\r\n */\r\nexport const altShiftKeysOnly = function (mapBrowserEvent) {\r\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\r\n    mapBrowserEvent.originalEvent\r\n  );\r\n  return (\r\n    originalEvent.altKey &&\r\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\r\n    originalEvent.shiftKey\r\n  );\r\n};\r\n\r\n/**\r\n * Return `true` if the map has the focus. This condition requires a map target\r\n * element with a `tabindex` attribute, e.g. `<div id=\"map\" tabindex=\"1\">`.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\r\n * @return {boolean} The map has the focus.\r\n * @api\r\n */\r\nexport const focus = function (event) {\r\n  const targetElement = event.map.getTargetElement();\r\n  const activeElement = event.map.getOwnerDocument().activeElement;\r\n  return targetElement.contains(activeElement);\r\n};\r\n\r\n/**\r\n * Return `true` if the map has the focus or no 'tabindex' attribute set.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\r\n * @return {boolean} The map container has the focus or no 'tabindex' attribute.\r\n */\r\nexport const focusWithTabindex = function (event) {\r\n  return event.map.getTargetElement().hasAttribute('tabindex')\r\n    ? focus(event)\r\n    : true;\r\n};\r\n\r\n/**\r\n * Return always true.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True.\r\n * @api\r\n */\r\nexport const always = TRUE;\r\n\r\n/**\r\n * Return `true` if the event is a `click` event, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event is a map `click` event.\r\n * @api\r\n */\r\nexport const click = function (mapBrowserEvent) {\r\n  return mapBrowserEvent.type == MapBrowserEventType.CLICK;\r\n};\r\n\r\n/**\r\n * Return `true` if the event has an \"action\"-producing mouse button.\r\n *\r\n * By definition, this includes left-click on windows/linux, and left-click\r\n * without the ctrl key on Macs.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} The result.\r\n */\r\nexport const mouseActionButton = function (mapBrowserEvent) {\r\n  const originalEvent = /** @type {MouseEvent} */ (\r\n    mapBrowserEvent.originalEvent\r\n  );\r\n  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);\r\n};\r\n\r\n/**\r\n * Return always false.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} False.\r\n * @api\r\n */\r\nexport const never = FALSE;\r\n\r\n/**\r\n * Return `true` if the browser event is a `pointermove` event, `false`\r\n * otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the browser event is a `pointermove` event.\r\n * @api\r\n */\r\nexport const pointerMove = function (mapBrowserEvent) {\r\n  return mapBrowserEvent.type == 'pointermove';\r\n};\r\n\r\n/**\r\n * Return `true` if the event is a map `singleclick` event, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event is a map `singleclick` event.\r\n * @api\r\n */\r\nexport const singleClick = function (mapBrowserEvent) {\r\n  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\r\n};\r\n\r\n/**\r\n * Return `true` if the event is a map `dblclick` event, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event is a map `dblclick` event.\r\n * @api\r\n */\r\nexport const doubleClick = function (mapBrowserEvent) {\r\n  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;\r\n};\r\n\r\n/**\r\n * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\r\n * pressed.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True only if there no modifier keys are pressed.\r\n * @api\r\n */\r\nexport const noModifierKeys = function (mapBrowserEvent) {\r\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\r\n    mapBrowserEvent.originalEvent\r\n  );\r\n  return (\r\n    !originalEvent.altKey &&\r\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\r\n    !originalEvent.shiftKey\r\n  );\r\n};\r\n\r\n/**\r\n * Return `true` if only the platform-modifier-key (the meta-key on Mac,\r\n * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\r\n * the shift-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the platform modifier key is pressed.\r\n * @api\r\n */\r\nexport const platformModifierKeyOnly = function (mapBrowserEvent) {\r\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\r\n    mapBrowserEvent.originalEvent\r\n  );\r\n  return (\r\n    !originalEvent.altKey &&\r\n    (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&\r\n    !originalEvent.shiftKey\r\n  );\r\n};\r\n\r\n/**\r\n * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\r\n * additionally the alt-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the shift key is pressed.\r\n * @api\r\n */\r\nexport const shiftKeyOnly = function (mapBrowserEvent) {\r\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\r\n    mapBrowserEvent.originalEvent\r\n  );\r\n  return (\r\n    !originalEvent.altKey &&\r\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\r\n    originalEvent.shiftKey\r\n  );\r\n};\r\n\r\n/**\r\n * Return `true` if the target element is not editable, i.e. not a `<input>`-,\r\n * `<select>`- or `<textarea>`-element, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True only if the target element is not editable.\r\n * @api\r\n */\r\nexport const targetNotEditable = function (mapBrowserEvent) {\r\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\r\n    mapBrowserEvent.originalEvent\r\n  );\r\n  const tagName = /** @type {Element} */ (originalEvent.target).tagName;\r\n  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';\r\n};\r\n\r\n/**\r\n * Return `true` if the event originates from a mouse device.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a mouse device.\r\n * @api\r\n */\r\nexport const mouseOnly = function (mapBrowserEvent) {\r\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (\r\n    mapBrowserEvent\r\n  ).originalEvent;\r\n  assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\r\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\r\n  return pointerEvent.pointerType == 'mouse';\r\n};\r\n\r\n/**\r\n * Return `true` if the event originates from a touchable device.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a touchable device.\r\n * @api\r\n */\r\nexport const touchOnly = function (mapBrowserEvent) {\r\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (\r\n    mapBrowserEvent\r\n  ).originalEvent;\r\n  assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event\r\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\r\n  return pointerEvt.pointerType === 'touch';\r\n};\r\n\r\n/**\r\n * Return `true` if the event originates from a digital pen.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a digital pen.\r\n * @api\r\n */\r\nexport const penOnly = function (mapBrowserEvent) {\r\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (\r\n    mapBrowserEvent\r\n  ).originalEvent;\r\n  assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event\r\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\r\n  return pointerEvt.pointerType === 'pen';\r\n};\r\n\r\n/**\r\n * Return `true` if the event originates from a primary pointer in\r\n * contact with the surface or if the left mouse button is pressed.\r\n * See https://www.w3.org/TR/pointerevents/#button-states.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a primary pointer.\r\n * @api\r\n */\r\nexport const primaryAction = function (mapBrowserEvent) {\r\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (\r\n    mapBrowserEvent\r\n  ).originalEvent;\r\n  assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\r\n  return pointerEvent.isPrimary && pointerEvent.button === 0;\r\n};\r\n", "/**\r\n * @module ol/interaction/Translate\r\n */\r\nimport Collection from '../Collection.js';\r\nimport Event from '../events/Event.js';\r\nimport InteractionProperty from './Property.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport {TRUE} from '../functions.js';\r\nimport {always} from '../events/condition.js';\r\nimport {includes} from '../array.js';\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst TranslateEventType = {\r\n  /**\r\n   * Triggered upon feature translation start.\r\n   * @event TranslateEvent#translatestart\r\n   * @api\r\n   */\r\n  TRANSLATESTART: 'translatestart',\r\n  /**\r\n   * Triggered upon feature translation.\r\n   * @event TranslateEvent#translating\r\n   * @api\r\n   */\r\n  TRANSLATING: 'translating',\r\n  /**\r\n   * Triggered upon feature translation end.\r\n   * @event TranslateEvent#translateend\r\n   * @api\r\n   */\r\n  TRANSLATEEND: 'translateend',\r\n};\r\n\r\n/**\r\n * A function that takes an {@link module:ol/Feature~Feature} or\r\n * {@link module:ol/render/Feature~RenderFeature} and an\r\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\r\n * translated or `false` otherwise.\r\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * Default is {@link module:ol/events/condition.always}.\r\n * @property {Collection<import(\"../Feature.js\").default>} [features] Features contained in this collection will be able to be translated together.\r\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\r\n * translated. Alternatively, a filter function can be provided. The\r\n * function will be called for each layer in the map and should return\r\n * `true` for layers that you want to be translatable. If the option is\r\n * absent, all visible layers will be considered translatable.\r\n * Not used if `features` is provided.\r\n * @property {FilterFunction} [filter] A function\r\n * that takes an {@link module:ol/Feature~Feature} and an\r\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\r\n * translated or `false` otherwise. Not used if `features` is provided.\r\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\r\n * will be checked for features.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\r\n * are instances of this type.\r\n */\r\nexport class TranslateEvent extends Event {\r\n  /**\r\n   * @param {TranslateEventType} type Type.\r\n   * @param {Collection<import(\"../Feature.js\").default>} features The features translated.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   */\r\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\r\n    super(type);\r\n\r\n    /**\r\n     * The features being translated.\r\n     * @type {Collection<import(\"../Feature.js\").default>}\r\n     * @api\r\n     */\r\n    this.features = features;\r\n\r\n    /**\r\n     * The coordinate of the drag event.\r\n     * @const\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @api\r\n     */\r\n    this.coordinate = coordinate;\r\n\r\n    /**\r\n     * The coordinate of the start position before translation started.\r\n     * @const\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @api\r\n     */\r\n    this.startCoordinate = startCoordinate;\r\n\r\n    /**\r\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @api\r\n     */\r\n    this.mapBrowserEvent = mapBrowserEvent;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for translating (moving) features.\r\n * If you want to translate multiple features in a single action (for example,\r\n * the collection used by a select interaction), construct the interaction with\r\n * the `features` option.\r\n *\r\n * @fires TranslateEvent\r\n * @api\r\n */\r\nclass Translate extends PointerInteraction {\r\n  /**\r\n   * @param {Options} [opt_options] Options.\r\n   */\r\n  constructor(opt_options) {\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\r\n\r\n    /***\r\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {TranslateOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * The last position we translated to.\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.lastCoordinate_ = null;\r\n\r\n    /**\r\n     * The start position before translation started.\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.startCoordinate_ = null;\r\n\r\n    /**\r\n     * @type {Collection<import(\"../Feature.js\").default>|null}\r\n     * @private\r\n     */\r\n    this.features_ = options.features !== undefined ? options.features : null;\r\n\r\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\r\n    let layerFilter;\r\n    if (options.layers && !this.features_) {\r\n      if (typeof options.layers === 'function') {\r\n        layerFilter = options.layers;\r\n      } else {\r\n        const layers = options.layers;\r\n        layerFilter = function (layer) {\r\n          return includes(layers, layer);\r\n        };\r\n      }\r\n    } else {\r\n      layerFilter = TRUE;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\r\n     */\r\n    this.layerFilter_ = layerFilter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {FilterFunction}\r\n     */\r\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\r\n    this.condition_ = options.condition ? options.condition : always;\r\n\r\n    /**\r\n     * @type {import(\"../Feature.js\").default}\r\n     * @private\r\n     */\r\n    this.lastFeature_ = null;\r\n\r\n    this.addChangeListener(\r\n      InteractionProperty.ACTIVE,\r\n      this.handleActiveChanged_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(event) {\r\n    if (!event.originalEvent || !this.condition_(event)) {\r\n      return false;\r\n    }\r\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\r\n    if (!this.lastCoordinate_ && this.lastFeature_) {\r\n      this.startCoordinate_ = event.coordinate;\r\n      this.lastCoordinate_ = event.coordinate;\r\n      this.handleMoveEvent(event);\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATESTART,\r\n          features,\r\n          event.coordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(event) {\r\n    if (this.lastCoordinate_) {\r\n      this.lastCoordinate_ = null;\r\n      this.handleMoveEvent(event);\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATEEND,\r\n          features,\r\n          event.coordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n      // cleanup\r\n      this.startCoordinate_ = null;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   */\r\n  handleDragEvent(event) {\r\n    if (this.lastCoordinate_) {\r\n      const newCoordinate = event.coordinate;\r\n      const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\r\n      const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      features.forEach(function (feature) {\r\n        const geom = feature.getGeometry();\r\n        geom.translate(deltaX, deltaY);\r\n        feature.setGeometry(geom);\r\n      });\r\n\r\n      this.lastCoordinate_ = newCoordinate;\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATING,\r\n          features,\r\n          newCoordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pointer move events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   */\r\n  handleMoveEvent(event) {\r\n    const elem = event.map.getViewport();\r\n\r\n    // Change the cursor to grab/grabbing if hovering any of the features managed\r\n    // by the interaction\r\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\r\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\r\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\r\n    } else {\r\n      elem.classList.remove('ol-grab', 'ol-grabbing');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tests to see if the given coordinates intersects any of our selected\r\n   * features.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\r\n   * @param {import(\"../PluggableMap.js\").default} map Map to test the intersection on.\r\n   * @return {import(\"../Feature.js\").default} Returns the feature found at the specified pixel\r\n   * coordinates.\r\n   * @private\r\n   */\r\n  featuresAtPixel_(pixel, map) {\r\n    return map.forEachFeatureAtPixel(\r\n      pixel,\r\n      function (feature, layer) {\r\n        if (this.filter_(feature, layer)) {\r\n          if (!this.features_ || includes(this.features_.getArray(), feature)) {\r\n            return feature;\r\n          }\r\n        }\r\n      }.bind(this),\r\n      {\r\n        layerFilter: this.layerFilter_,\r\n        hitTolerance: this.hitTolerance_,\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the Hit-detection tolerance.\r\n   * @return {number} Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  getHitTolerance() {\r\n    return this.hitTolerance_;\r\n  }\r\n\r\n  /**\r\n   * Hit-detection tolerance. Pixels inside the radius around the given position\r\n   * will be checked for features.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  setHitTolerance(hitTolerance) {\r\n    this.hitTolerance_ = hitTolerance;\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../PluggableMap.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    const oldMap = this.getMap();\r\n    super.setMap(map);\r\n    this.updateState_(oldMap);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleActiveChanged_() {\r\n    this.updateState_(null);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../PluggableMap.js\").default} oldMap Old map.\r\n   * @private\r\n   */\r\n  updateState_(oldMap) {\r\n    let map = this.getMap();\r\n    const active = this.getActive();\r\n    if (!map || !active) {\r\n      map = map || oldMap;\r\n      if (map) {\r\n        const elem = map.getViewport();\r\n        elem.classList.remove('ol-grab', 'ol-grabbing');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Translate;\r\n"],
  "mappings": "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",
  "names": ["Interaction", "__extends", "PointerInteraction", "__extends", "TranslateEvent", "__extends", "Translate"]
}
