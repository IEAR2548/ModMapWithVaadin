{
  "version": 3,
  "sources": ["../../ol/src/layer/TileProperty.js", "../../ol/src/layer/BaseTile.js", "../../ol/src/renderer/canvas/TileLayer.js", "../../ol/src/layer/Tile.js"],
  "sourcesContent": ["/**\r\n * @module ol/layer/TileProperty\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  PRELOAD: 'preload',\r\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\r\n};\r\n", "/**\r\n * @module ol/layer/BaseTile\r\n */\r\nimport Layer from './Layer.js';\r\nimport TileProperty from './TileProperty.js';\r\nimport {assign} from '../obj.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\r\n *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\r\n * means no preloading.\r\n * @property {TileSourceType} [source] Source for this layer.\r\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../PluggableMap.js\").default#addLayer map.addLayer()}.\r\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<TileSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseTileLayer extends Layer {\r\n  /**\r\n   * @param {Options<TileSourceType>} [opt_options] Tile layer options.\r\n   */\r\n  constructor(opt_options) {\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    const baseOptions = assign({}, options);\r\n\r\n    delete baseOptions.preload;\r\n    delete baseOptions.useInterimTilesOnError;\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\r\n    this.setUseInterimTilesOnError(\r\n      options.useInterimTilesOnError !== undefined\r\n        ? options.useInterimTilesOnError\r\n        : true\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the level as number to which we will preload tiles up to.\r\n   * @return {number} The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getPreload() {\r\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\r\n  }\r\n\r\n  /**\r\n   * Set the level as number to which we will preload tiles up to.\r\n   * @param {number} preload The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setPreload(preload) {\r\n    this.set(TileProperty.PRELOAD, preload);\r\n  }\r\n\r\n  /**\r\n   * Whether we use interim tiles on error.\r\n   * @return {boolean} Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getUseInterimTilesOnError() {\r\n    return /** @type {boolean} */ (\r\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set whether we use interim tiles on error.\r\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setUseInterimTilesOnError(useInterimTilesOnError) {\r\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\r\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\r\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\r\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default BaseTileLayer;\r\n", "/**\r\n * @module ol/renderer/canvas/TileLayer\r\n */\r\nimport CanvasLayerRenderer from './Layer.js';\r\nimport ImageTile from '../../ImageTile.js';\r\nimport ReprojTile from '../../reproj/Tile.js';\r\nimport TileRange from '../../TileRange.js';\r\nimport TileState from '../../TileState.js';\r\nimport {IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED} from './common.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n  makeInverse,\r\n  toString as toTransformString,\r\n} from '../../transform.js';\r\nimport {assign} from '../../obj.js';\r\nimport {\r\n  containsCoordinate,\r\n  createEmpty,\r\n  equals,\r\n  getIntersection,\r\n  getTopLeft,\r\n  intersects,\r\n} from '../../extent.js';\r\nimport {cssOpacity} from '../../css.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\nimport {getUid} from '../../util.js';\r\nimport {numberSafeCompareFunction} from '../../array.js';\r\nimport {toSize} from '../../size.js';\r\n\r\n/**\r\n * @classdesc\r\n * Canvas renderer for tile layers.\r\n * @api\r\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\r\n * @extends {CanvasLayerRenderer<LayerType>}\r\n */\r\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\r\n  /**\r\n   * @param {LayerType} tileLayer Tile layer.\r\n   */\r\n  constructor(tileLayer) {\r\n    super(tileLayer);\r\n\r\n    /**\r\n     * Rendered extent has changed since the previous `renderFrame()` call\r\n     * @type {boolean}\r\n     */\r\n    this.extentChanged = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../../extent.js\").Extent}\r\n     */\r\n    this.renderedExtent_ = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedPixelRatio;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../proj/Projection.js\").default}\r\n     */\r\n    this.renderedProjection = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedRevision;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Array<import(\"../../Tile.js\").default>}\r\n     */\r\n    this.renderedTiles = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.newTiles_ = false;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\r\n    this.tmpExtent = createEmpty();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../../TileRange.js\").default}\r\n     */\r\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {import(\"../../Tile.js\").default} tile Tile.\r\n   * @return {boolean} Tile is drawable.\r\n   */\r\n  isDrawableTile(tile) {\r\n    const tileLayer = this.getLayer();\r\n    const tileState = tile.getState();\r\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\r\n    return (\r\n      tileState == TileState.LOADED ||\r\n      tileState == TileState.EMPTY ||\r\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @return {!import(\"../../Tile.js\").default} Tile.\r\n   */\r\n  getTile(z, x, y, frameState) {\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const projection = frameState.viewState.projection;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getSource();\r\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\r\n    if (tile.getState() == TileState.ERROR) {\r\n      if (!tileLayer.getUseInterimTilesOnError()) {\r\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\r\n        tile.setState(TileState.LOADED);\r\n      } else if (tileLayer.getPreload() > 0) {\r\n        // Preloaded tiles for lower resolutions might have finished loading.\r\n        this.newTiles_ = true;\r\n      }\r\n    }\r\n    if (!this.isDrawableTile(tile)) {\r\n      tile = tile.getInterimTile();\r\n    }\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray} Data at the pixel location.\r\n   */\r\n  getData(pixel) {\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice()\r\n    );\r\n\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (!containsCoordinate(layerExtent, coordinate)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const projection = frameState.viewState.projection;\r\n    const viewState = frameState.viewState;\r\n    const source = layer.getRenderSource();\r\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\r\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\r\n\r\n    for (\r\n      let z = tileGrid.getZForResolution(viewState.resolution);\r\n      z >= tileGrid.getMinZoom();\r\n      --z\r\n    ) {\r\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\r\n      const tile = source.getTile(\r\n        z,\r\n        tileCoord[1],\r\n        tileCoord[2],\r\n        pixelRatio,\r\n        projection\r\n      );\r\n      if (!(tile instanceof ImageTile || tile instanceof ReprojTile)) {\r\n        return null;\r\n      }\r\n\r\n      if (tile.getState() !== TileState.LOADED) {\r\n        continue;\r\n      }\r\n\r\n      const tileOrigin = tileGrid.getOrigin(z);\r\n      const tileSize = toSize(tileGrid.getTileSize(z));\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      const col = Math.floor(\r\n        tilePixelRatio *\r\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\r\n            tileCoord[1] * tileSize[0])\r\n      );\r\n\r\n      const row = Math.floor(\r\n        tilePixelRatio *\r\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\r\n            tileCoord[2] * tileSize[1])\r\n      );\r\n\r\n      return this.getImageData(tile.getImage(), col, row);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @param {import(\"../../Tile.js\").default} tile Tile.\r\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\r\n   */\r\n  loadedTileCallback(tiles, zoom, tile) {\r\n    if (this.isDrawableTile(tile)) {\r\n      return super.loadedTileCallback(tiles, zoom, tile);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\r\n  prepareFrame(frameState) {\r\n    return !!this.getLayer().getSource();\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   */\r\n  renderFrame(frameState, target) {\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const viewState = frameState.viewState;\r\n    const projection = viewState.projection;\r\n    const viewResolution = viewState.resolution;\r\n    const viewCenter = viewState.center;\r\n    const rotation = viewState.rotation;\r\n    const pixelRatio = frameState.pixelRatio;\r\n\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getSource();\r\n    const sourceRevision = tileSource.getRevision();\r\n    const tileGrid = tileSource.getTileGridForProjection(projection);\r\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\r\n    const tileResolution = tileGrid.getResolution(z);\r\n\r\n    let extent = frameState.extent;\r\n    const layerExtent =\r\n      layerState.extent && fromUserExtent(layerState.extent, projection);\r\n    if (layerExtent) {\r\n      extent = getIntersection(\r\n        extent,\r\n        fromUserExtent(layerState.extent, projection)\r\n      );\r\n    }\r\n\r\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\r\n\r\n    // desired dimensions of the canvas in pixels\r\n    let width = Math.round(frameState.size[0] * tilePixelRatio);\r\n    let height = Math.round(frameState.size[1] * tilePixelRatio);\r\n\r\n    if (rotation) {\r\n      const size = Math.round(Math.sqrt(width * width + height * height));\r\n      width = size;\r\n      height = size;\r\n    }\r\n\r\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\r\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\r\n    const canvasExtent = [\r\n      viewCenter[0] - dx,\r\n      viewCenter[1] - dy,\r\n      viewCenter[0] + dx,\r\n      viewCenter[1] + dy,\r\n    ];\r\n\r\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\r\n\r\n    /**\r\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\r\n     */\r\n    const tilesToDrawByZ = {};\r\n    tilesToDrawByZ[z] = {};\r\n\r\n    const findLoadedTiles = this.createLoadedTileFinder(\r\n      tileSource,\r\n      projection,\r\n      tilesToDrawByZ\r\n    );\r\n\r\n    const tmpExtent = this.tmpExtent;\r\n    const tmpTileRange = this.tmpTileRange_;\r\n    this.newTiles_ = false;\r\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n        const tile = this.getTile(z, x, y, frameState);\r\n        if (this.isDrawableTile(tile)) {\r\n          const uid = getUid(this);\r\n          if (tile.getState() == TileState.LOADED) {\r\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\r\n            const inTransition = tile.inTransition(uid);\r\n            if (\r\n              !this.newTiles_ &&\r\n              (inTransition || this.renderedTiles.indexOf(tile) === -1)\r\n            ) {\r\n              this.newTiles_ = true;\r\n            }\r\n          }\r\n          if (tile.getAlpha(uid, frameState.time) === 1) {\r\n            // don't look for alt tiles if alpha is 1\r\n            continue;\r\n          }\r\n        }\r\n\r\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\r\n          tile.tileCoord,\r\n          tmpTileRange,\r\n          tmpExtent\r\n        );\r\n\r\n        let covered = false;\r\n        if (childTileRange) {\r\n          covered = findLoadedTiles(z + 1, childTileRange);\r\n        }\r\n        if (!covered) {\r\n          tileGrid.forEachTileCoordParentTileRange(\r\n            tile.tileCoord,\r\n            findLoadedTiles,\r\n            tmpTileRange,\r\n            tmpExtent\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    const canvasScale = tileResolution / viewResolution;\r\n\r\n    // set forward and inverse pixel transforms\r\n    composeTransform(\r\n      this.pixelTransform,\r\n      frameState.size[0] / 2,\r\n      frameState.size[1] / 2,\r\n      1 / tilePixelRatio,\r\n      1 / tilePixelRatio,\r\n      rotation,\r\n      -width / 2,\r\n      -height / 2\r\n    );\r\n\r\n    const canvasTransform = toTransformString(this.pixelTransform);\r\n\r\n    this.useContainer(\r\n      target,\r\n      canvasTransform,\r\n      layerState.opacity,\r\n      this.getBackground(frameState)\r\n    );\r\n    const context = this.context;\r\n    const canvas = context.canvas;\r\n\r\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\r\n\r\n    // set scale transform for calculating tile positions on the canvas\r\n    composeTransform(\r\n      this.tempTransform,\r\n      width / 2,\r\n      height / 2,\r\n      canvasScale,\r\n      canvasScale,\r\n      0,\r\n      -width / 2,\r\n      -height / 2\r\n    );\r\n\r\n    if (canvas.width != width || canvas.height != height) {\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n    } else if (!this.containerReused) {\r\n      context.clearRect(0, 0, width, height);\r\n    }\r\n\r\n    if (layerExtent) {\r\n      this.clipUnrotated(context, frameState, layerExtent);\r\n    }\r\n\r\n    if (!tileSource.getInterpolate()) {\r\n      assign(context, IMAGE_SMOOTHING_DISABLED);\r\n    }\r\n\r\n    this.preRender(context, frameState);\r\n\r\n    this.renderedTiles.length = 0;\r\n    /** @type {Array<number>} */\r\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\r\n    zs.sort(numberSafeCompareFunction);\r\n\r\n    let clips, clipZs, currentClip;\r\n    if (\r\n      layerState.opacity === 1 &&\r\n      (!this.containerReused ||\r\n        tileSource.getOpaque(frameState.viewState.projection))\r\n    ) {\r\n      zs = zs.reverse();\r\n    } else {\r\n      clips = [];\r\n      clipZs = [];\r\n    }\r\n    for (let i = zs.length - 1; i >= 0; --i) {\r\n      const currentZ = zs[i];\r\n      const currentTilePixelSize = tileSource.getTilePixelSize(\r\n        currentZ,\r\n        pixelRatio,\r\n        projection\r\n      );\r\n      const currentResolution = tileGrid.getResolution(currentZ);\r\n      const currentScale = currentResolution / tileResolution;\r\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\r\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\r\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\r\n        getTopLeft(canvasExtent),\r\n        currentZ\r\n      );\r\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\r\n      const origin = applyTransform(this.tempTransform, [\r\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\r\n          tileResolution,\r\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\r\n          tileResolution,\r\n      ]);\r\n      const tileGutter =\r\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\r\n      const tilesToDraw = tilesToDrawByZ[currentZ];\r\n      for (const tileCoordKey in tilesToDraw) {\r\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\r\n          tilesToDraw[tileCoordKey]\r\n        );\r\n        const tileCoord = tile.tileCoord;\r\n\r\n        // Calculate integer positions and sizes so that tiles align\r\n        const xIndex = originTileCoord[1] - tileCoord[1];\r\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\r\n        const yIndex = originTileCoord[2] - tileCoord[2];\r\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\r\n        const x = Math.round(origin[0] - xIndex * dx);\r\n        const y = Math.round(origin[1] - yIndex * dy);\r\n        const w = nextX - x;\r\n        const h = nextY - y;\r\n        const transition = z === currentZ;\r\n\r\n        const inTransition =\r\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\r\n        let contextSaved = false;\r\n        if (!inTransition) {\r\n          if (clips) {\r\n            // Clip mask for regions in this tile that already filled by a higher z tile\r\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\r\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\r\n              if (z !== currentZ && currentZ < clipZs[i]) {\r\n                const clip = clips[i];\r\n                if (\r\n                  intersects(\r\n                    [x, y, x + w, y + h],\r\n                    [clip[0], clip[3], clip[4], clip[7]]\r\n                  )\r\n                ) {\r\n                  if (!contextSaved) {\r\n                    context.save();\r\n                    contextSaved = true;\r\n                  }\r\n                  context.beginPath();\r\n                  // counter-clockwise (outer ring) for current tile\r\n                  context.moveTo(currentClip[0], currentClip[1]);\r\n                  context.lineTo(currentClip[2], currentClip[3]);\r\n                  context.lineTo(currentClip[4], currentClip[5]);\r\n                  context.lineTo(currentClip[6], currentClip[7]);\r\n                  // clockwise (inner ring) for higher z tile\r\n                  context.moveTo(clip[6], clip[7]);\r\n                  context.lineTo(clip[4], clip[5]);\r\n                  context.lineTo(clip[2], clip[3]);\r\n                  context.lineTo(clip[0], clip[1]);\r\n                  context.clip();\r\n                }\r\n              }\r\n            }\r\n            clips.push(currentClip);\r\n            clipZs.push(currentZ);\r\n          } else {\r\n            context.clearRect(x, y, w, h);\r\n          }\r\n        }\r\n        this.drawTileImage(\r\n          tile,\r\n          frameState,\r\n          x,\r\n          y,\r\n          w,\r\n          h,\r\n          tileGutter,\r\n          transition\r\n        );\r\n        if (clips && !inTransition) {\r\n          if (contextSaved) {\r\n            context.restore();\r\n          }\r\n          this.renderedTiles.unshift(tile);\r\n        } else {\r\n          this.renderedTiles.push(tile);\r\n        }\r\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\r\n      }\r\n    }\r\n\r\n    this.renderedRevision = sourceRevision;\r\n    this.renderedResolution = tileResolution;\r\n    this.extentChanged =\r\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\r\n    this.renderedExtent_ = canvasExtent;\r\n    this.renderedPixelRatio = pixelRatio;\r\n    this.renderedProjection = projection;\r\n\r\n    this.manageTilePyramid(\r\n      frameState,\r\n      tileSource,\r\n      tileGrid,\r\n      pixelRatio,\r\n      projection,\r\n      extent,\r\n      z,\r\n      tileLayer.getPreload()\r\n    );\r\n    this.scheduleExpireCache(frameState, tileSource);\r\n\r\n    this.postRender(context, frameState);\r\n\r\n    if (layerState.extent) {\r\n      context.restore();\r\n    }\r\n    assign(context, IMAGE_SMOOTHING_ENABLED);\r\n\r\n    if (canvasTransform !== canvas.style.transform) {\r\n      canvas.style.transform = canvasTransform;\r\n    }\r\n    const opacity = cssOpacity(layerState.opacity);\r\n    const container = this.container;\r\n    if (opacity !== container.style.opacity) {\r\n      container.style.opacity = opacity;\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {number} x Left of the tile.\r\n   * @param {number} y Top of the tile.\r\n   * @param {number} w Width of the tile.\r\n   * @param {number} h Height of the tile.\r\n   * @param {number} gutter Tile gutter.\r\n   * @param {boolean} transition Apply an alpha transition.\r\n   */\r\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\r\n    const image = this.getTileImage(tile);\r\n    if (!image) {\r\n      return;\r\n    }\r\n    const uid = getUid(this);\r\n    const alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\r\n    const alphaChanged = alpha !== this.context.globalAlpha;\r\n    if (alphaChanged) {\r\n      this.context.save();\r\n      this.context.globalAlpha = alpha;\r\n    }\r\n    this.context.drawImage(\r\n      image,\r\n      gutter,\r\n      gutter,\r\n      image.width - 2 * gutter,\r\n      image.height - 2 * gutter,\r\n      x,\r\n      y,\r\n      w,\r\n      h\r\n    );\r\n\r\n    if (alphaChanged) {\r\n      this.context.restore();\r\n    }\r\n    if (alpha !== 1) {\r\n      frameState.animate = true;\r\n    } else if (transition) {\r\n      tile.endTransition(uid);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Image\r\n   */\r\n  getImage() {\r\n    const context = this.context;\r\n    return context ? context.canvas : null;\r\n  }\r\n\r\n  /**\r\n   * Get the image from a tile.\r\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @protected\r\n   */\r\n  getTileImage(tile) {\r\n    return tile.getImage();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n   * @protected\r\n   */\r\n  scheduleExpireCache(frameState, tileSource) {\r\n    if (tileSource.canExpireCache()) {\r\n      /**\r\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\r\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n       */\r\n      const postRenderFunction = function (tileSource, map, frameState) {\r\n        const tileSourceKey = getUid(tileSource);\r\n        if (tileSourceKey in frameState.usedTiles) {\r\n          tileSource.expireCache(\r\n            frameState.viewState.projection,\r\n            frameState.usedTiles[tileSourceKey]\r\n          );\r\n        }\r\n      }.bind(null, tileSource);\r\n\r\n      frameState.postRenderFunctions.push(\r\n        /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (\r\n          postRenderFunction\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\r\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n   * @param {import('../../Tile.js').default} tile Tile.\r\n   * @protected\r\n   */\r\n  updateUsedTiles(usedTiles, tileSource, tile) {\r\n    // FIXME should we use tilesToDrawByZ instead?\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in usedTiles)) {\r\n      usedTiles[tileSourceKey] = {};\r\n    }\r\n    usedTiles[tileSourceKey][tile.getKey()] = true;\r\n  }\r\n\r\n  /**\r\n   * Manage tile pyramid.\r\n   * This function performs a number of functions related to the tiles at the\r\n   * current zoom and lower zoom levels:\r\n   * - registers idle tiles in frameState.wantedTiles so that they are not\r\n   *   discarded by the tile queue\r\n   * - enqueues missing tiles\r\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n   * @param {number} currentZ Current Z.\r\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\r\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\r\n   * @protected\r\n   */\r\n  manageTilePyramid(\r\n    frameState,\r\n    tileSource,\r\n    tileGrid,\r\n    pixelRatio,\r\n    projection,\r\n    extent,\r\n    currentZ,\r\n    preload,\r\n    opt_tileCallback\r\n  ) {\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in frameState.wantedTiles)) {\r\n      frameState.wantedTiles[tileSourceKey] = {};\r\n    }\r\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\r\n    const tileQueue = frameState.tileQueue;\r\n    const minZoom = tileGrid.getMinZoom();\r\n    let tileCount = 0;\r\n    let tile, tileRange, tileResolution, x, y, z;\r\n    for (z = minZoom; z <= currentZ; ++z) {\r\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\r\n      tileResolution = tileGrid.getResolution(z);\r\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n          if (currentZ - z <= preload) {\r\n            ++tileCount;\r\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\r\n            if (tile.getState() == TileState.IDLE) {\r\n              wantedTiles[tile.getKey()] = true;\r\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\r\n                tileQueue.enqueue([\r\n                  tile,\r\n                  tileSourceKey,\r\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\r\n                  tileResolution,\r\n                ]);\r\n              }\r\n            }\r\n            if (opt_tileCallback !== undefined) {\r\n              opt_tileCallback(tile);\r\n            }\r\n          } else {\r\n            tileSource.useTile(z, x, y, projection);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    tileSource.updateCacheSize(tileCount, projection);\r\n  }\r\n}\r\n\r\nexport default CanvasTileLayerRenderer;\r\n", "/**\r\n * @module ol/layer/Tile\r\n */\r\nimport BaseTileLayer from './BaseTile.js';\r\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\r\n * @api\r\n */\r\nclass TileLayer extends BaseTileLayer {\r\n  /**\r\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [opt_options] Tile layer options.\r\n   */\r\n  constructor(opt_options) {\r\n    super(opt_options);\r\n  }\r\n\r\n  createRenderer() {\r\n    return new CanvasTileLayerRenderer(this);\r\n  }\r\n}\r\n\r\nexport default TileLayer;\r\n"],
  "mappings": "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",
  "names": ["BaseTileLayer", "__extends", "CanvasTileLayerRenderer", "tileSource", "frameState", "Layer_default", "__extends", "TileLayer", "Tile_default"]
}
