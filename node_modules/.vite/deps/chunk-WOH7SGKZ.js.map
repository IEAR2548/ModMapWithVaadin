{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/dom-utils.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\n\r\n/**\r\n * Returns an array of ancestor root nodes for the given node.\r\n *\r\n * A root node is either a document node or a document fragment node (Shadow Root).\r\n * The array is collected by a bottom-up DOM traversing that starts with the given node\r\n * and involves both the light DOM and ancestor shadow DOM trees.\r\n *\r\n * @param {Node} node\r\n * @return {Node[]}\r\n */\r\nexport function getAncestorRootNodes(node) {\r\n  const result = [];\r\n\r\n  while (node) {\r\n    if (node.nodeType === Node.DOCUMENT_NODE) {\r\n      result.push(node);\r\n      break;\r\n    }\r\n\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n      result.push(node);\r\n      node = node.host;\r\n      continue;\r\n    }\r\n\r\n    if (node.assignedSlot) {\r\n      node = node.assignedSlot;\r\n      continue;\r\n    }\r\n\r\n    node = node.parentNode;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Returns the list of flattened elements for the given `node`.\r\n * This list consists of a node's children and, for any children that are\r\n * `<slot>` elements, the expanded flattened list of `assignedElements`.\r\n *\r\n * @param {Node} node\r\n * @return {Element[]}\r\n */\r\nexport function getFlattenedElements(node) {\r\n  const result = [];\r\n  let elements;\r\n  if (node.localName === 'slot') {\r\n    elements = node.assignedElements();\r\n  } else {\r\n    result.push(node);\r\n    elements = [...node.children];\r\n  }\r\n  elements.forEach((elem) => result.push(...getFlattenedElements(elem)));\r\n  return result;\r\n}\r\n\r\n/**\r\n * Traverses the given node and its parents, including those that are across\r\n * the shadow root boundaries, until it finds a node that matches the selector.\r\n *\r\n * @param {string} selector The CSS selector to match against\r\n * @param {Node} node The starting node for the traversal\r\n * @return {Node | null} The closest matching element, or null if no match is found\r\n */\r\nexport function getClosestElement(selector, node) {\r\n  if (!node) {\r\n    return null;\r\n  }\r\n\r\n  return node.closest(selector) || getClosestElement(selector, node.getRootNode().host);\r\n}\r\n\r\n/**\r\n * Takes a string with values separated by space and returns a set the values\r\n *\r\n * @param {string} value\r\n * @return {Set<string>}\r\n */\r\nexport function deserializeAttributeValue(value) {\r\n  if (!value) {\r\n    return new Set();\r\n  }\r\n\r\n  return new Set(value.split(' '));\r\n}\r\n\r\n/**\r\n * Takes a set of string values and returns a string with values separated by space\r\n *\r\n * @param {Set<string>} values\r\n * @return {string}\r\n */\r\nexport function serializeAttributeValue(values) {\r\n  return values ? [...values].join(' ') : '';\r\n}\r\n\r\n/**\r\n * Adds a value to an attribute containing space-delimited values.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {string} attr\r\n * @param {string} value\r\n */\r\nexport function addValueToAttribute(element, attr, value) {\r\n  const values = deserializeAttributeValue(element.getAttribute(attr));\r\n  values.add(value);\r\n  element.setAttribute(attr, serializeAttributeValue(values));\r\n}\r\n\r\n/**\r\n * Removes a value from an attribute containing space-delimited values.\r\n * If the value is the last one, the whole attribute is removed.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {string} attr\r\n * @param {string} value\r\n */\r\nexport function removeValueFromAttribute(element, attr, value) {\r\n  const values = deserializeAttributeValue(element.getAttribute(attr));\r\n  values.delete(value);\r\n  if (values.size === 0) {\r\n    element.removeAttribute(attr);\r\n    return;\r\n  }\r\n  element.setAttribute(attr, serializeAttributeValue(values));\r\n}\r\n\r\n/**\r\n * Returns true if the given node is an empty text node, false otherwise.\r\n *\r\n * @param {Node} node\r\n * @return {boolean}\r\n */\r\nexport function isEmptyTextNode(node) {\r\n  return node.nodeType === Node.TEXT_NODE && node.textContent.trim() === '';\r\n}\r\n"],
  "mappings": ";AAgBO,SAAS,qBAAqB,MAAM;AACzC,QAAM,SAAS,CAAC;AAEhB,SAAO,MAAM;AACX,QAAI,KAAK,aAAa,KAAK,eAAe;AACxC,aAAO,KAAK,IAAI;AAChB;AAAA,IACF;AAEA,QAAI,KAAK,aAAa,KAAK,wBAAwB;AACjD,aAAO,KAAK,IAAI;AAChB,aAAO,KAAK;AACZ;AAAA,IACF;AAEA,QAAI,KAAK,cAAc;AACrB,aAAO,KAAK;AACZ;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,EACd;AAEA,SAAO;AACT;AAUO,SAAS,qBAAqB,MAAM;AACzC,QAAM,SAAS,CAAC;AAChB,MAAI;AACJ,MAAI,KAAK,cAAc,QAAQ;AAC7B,eAAW,KAAK,iBAAiB;AAAA,EACnC,OAAO;AACL,WAAO,KAAK,IAAI;AAChB,eAAW,CAAC,GAAG,KAAK,QAAQ;AAAA,EAC9B;AACA,WAAS,QAAQ,CAAC,SAAS,OAAO,KAAK,GAAG,qBAAqB,IAAI,CAAC,CAAC;AACrE,SAAO;AACT;AAUO,SAAS,kBAAkB,UAAU,MAAM;AAChD,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,SAAO,KAAK,QAAQ,QAAQ,KAAK,kBAAkB,UAAU,KAAK,YAAY,EAAE,IAAI;AACtF;AAQO,SAAS,0BAA0B,OAAO;AAC/C,MAAI,CAAC,OAAO;AACV,WAAO,oBAAI,IAAI;AAAA,EACjB;AAEA,SAAO,IAAI,IAAI,MAAM,MAAM,GAAG,CAAC;AACjC;AAQO,SAAS,wBAAwB,QAAQ;AAC9C,SAAO,SAAS,CAAC,GAAG,MAAM,EAAE,KAAK,GAAG,IAAI;AAC1C;AASO,SAAS,oBAAoB,SAAS,MAAM,OAAO;AACxD,QAAM,SAAS,0BAA0B,QAAQ,aAAa,IAAI,CAAC;AACnE,SAAO,IAAI,KAAK;AAChB,UAAQ,aAAa,MAAM,wBAAwB,MAAM,CAAC;AAC5D;AAUO,SAAS,yBAAyB,SAAS,MAAM,OAAO;AAC7D,QAAM,SAAS,0BAA0B,QAAQ,aAAa,IAAI,CAAC;AACnE,SAAO,OAAO,KAAK;AACnB,MAAI,OAAO,SAAS,GAAG;AACrB,YAAQ,gBAAgB,IAAI;AAC5B;AAAA,EACF;AACA,UAAQ,aAAa,MAAM,wBAAwB,MAAM,CAAC;AAC5D;AAQO,SAAS,gBAAgB,MAAM;AACpC,SAAO,KAAK,aAAa,KAAK,aAAa,KAAK,YAAY,KAAK,MAAM;AACzE;",
  "names": []
}
