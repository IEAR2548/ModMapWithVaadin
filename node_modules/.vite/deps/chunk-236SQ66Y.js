import {
  Scroller
} from "./chunk-I5DXOGXQ.js";
import {
  OverflowController
} from "./chunk-XJDRXJQL.js";
import {
  loader
} from "./chunk-P32CKAHW.js";
import {
  DelegateStateMixin
} from "./chunk-JZD2KJJX.js";
import {
  SlotController
} from "./chunk-FIRGGFKS.js";
import {
  generateUniqueId
} from "./chunk-4SWSK3CD.js";
import {
  SlotObserver
} from "./chunk-HXO5X6HG.js";
import {
  ElementMixin
} from "./chunk-QN4QZSZG.js";
import {
  ControllerMixin
} from "./chunk-QZAHM4JN.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-KEWLZU7R.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import {
  PolymerElement
} from "./chunk-YBEXGSZO.js";
import {
  html
} from "./chunk-QO5P4LIH.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";

// node_modules/@vaadin/tabsheet/theme/lumo/vaadin-tabsheet-styles.js
var tabsheet = css`
  :host {
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    font-family: var(--lumo-font-family);
  }

  :host([theme~='bordered']) {
    border: 1px solid var(--lumo-contrast-20pct);
    border-radius: var(--lumo-border-radius-l);
  }

  [part='tabs-container'] {
    box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
    padding: var(--lumo-space-xs) var(--lumo-space-s);
    gap: var(--lumo-space-s);
  }

  ::slotted([slot='tabs']) {
    box-shadow: initial;
    margin: calc(var(--lumo-space-xs) * -1) calc(var(--lumo-space-s) * -1);
  }

  [part='content'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    border-bottom-left-radius: inherit;
    border-bottom-right-radius: inherit;
  }

  :host([loading]) [part='content'] {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }
`;
registerStyles("vaadin-tabsheet", [tabsheet, loader], { moduleId: "lumo-tabsheet" });

// node_modules/@vaadin/tabsheet/src/vaadin-tabsheet-scroller.js
var TabsheetScroller = class extends Scroller {
  static get is() {
    return "vaadin-tabsheet-scroller";
  }
};
defineCustomElement(TabsheetScroller);

// node_modules/@vaadin/tabsheet/src/vaadin-tabsheet-mixin.js
var TabsSlotController = class extends SlotController {
  constructor(host) {
    super(host, "tabs");
    this.__tabsItemsChangedListener = this.__tabsItemsChangedListener.bind(this);
    this.__tabsSelectedChangedListener = this.__tabsSelectedChangedListener.bind(this);
    this.__tabIdObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const tab = mutation.target;
        host.__linkTabAndPanel(tab);
        if (tab.selected) {
          host.__togglePanels(tab);
        }
      });
    });
  }
  /** @private */
  __tabsItemsChangedListener() {
    this.__tabIdObserver.disconnect();
    const items = this.tabs.items || [];
    items.forEach((tab) => {
      this.__tabIdObserver.observe(tab, {
        attributeFilter: ["id"]
      });
    });
    this.host._setItems(items);
  }
  /** @private */
  __tabsSelectedChangedListener() {
    this.host.selected = this.tabs.selected;
  }
  initCustomNode(tabs) {
    if (!(tabs instanceof customElements.get("vaadin-tabs"))) {
      throw Error('The "tabs" slot of a <vaadin-tabsheet> must only contain a <vaadin-tabs> element!');
    }
    this.tabs = tabs;
    tabs.addEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.addEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = tabs;
    this.host.stateTarget = tabs;
    this.__tabsItemsChangedListener();
  }
  teardownNode(tabs) {
    this.tabs = null;
    tabs.removeEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.removeEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = null;
    this.host._setItems([]);
    this.host.stateTarget = void 0;
  }
};
var TabSheetMixin = (superClass) => class extends DelegateStateMixin(superClass) {
  static get properties() {
    return {
      /**
       * The list of `<vaadin-tab>`s from which a selection can be made.
       * It is populated from the elements passed inside the slotted
       * `<vaadin-tabs>`, and updated dynamically when adding or removing items.
       *
       * Note: unlike `<vaadin-combo-box>`, this property is read-only.
       * @type {!Array<!Tab> | undefined}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      /**
       * The index of the selected tab.
       */
      selected: {
        value: 0,
        type: Number,
        notify: true
      },
      /**
       * The slotted <vaadin-tabs> element.
       */
      __tabs: {
        type: Object
      },
      /**
       * The panel elements.
       */
      __panels: {
        type: Array
      }
    };
  }
  static get observers() {
    return ["__itemsOrPanelsChanged(items, __panels)", "__selectedTabItemChanged(selected, items, __panels)"];
  }
  /** @override */
  static get delegateProps() {
    return ["selected", "_theme"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__overflowController = new OverflowController(this, this.shadowRoot.querySelector('[part="content"]'));
    this.addController(this.__overflowController);
    this._tabsSlotController = new TabsSlotController(this);
    this.addController(this._tabsSlotController);
    const panelSlot = this.shadowRoot.querySelector("#panel-slot");
    this.__panelsObserver = new SlotObserver(panelSlot, ({ addedNodes, removedNodes }) => {
      if (addedNodes.length) {
        addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            node.__customHidden = true;
          }
        });
      }
      if (removedNodes.length) {
        removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            if (node.__customHidden) {
              delete node.__customHidden;
            } else {
              node.hidden = false;
            }
          }
        });
      }
      this.__panels = Array.from(
        panelSlot.assignedNodes({
          flatten: true
        })
      ).filter((node) => node.nodeType === Node.ELEMENT_NODE);
    });
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * An observer which applies the necessary roles and ARIA attributes
   * to associate the tab elements with the panels.
   * @private
   */
  __itemsOrPanelsChanged(items, panels) {
    if (!items || !panels) {
      return;
    }
    items.forEach((tabItem) => {
      this.__linkTabAndPanel(tabItem, panels);
    });
  }
  /**
   * An observer which toggles the visibility of the panels based on the selected tab.
   * @private
   */
  __selectedTabItemChanged(selected, items, panels) {
    if (!items || !panels || selected === void 0) {
      return;
    }
    this.__togglePanels(items[selected], panels);
  }
  /** @private */
  __togglePanels(selectedTab, panels = this.__panels) {
    const selectedTabId = selectedTab ? selectedTab.id : "";
    const selectedPanel = panels.find((panel) => panel.getAttribute("tab") === selectedTabId);
    const content = this.shadowRoot.querySelector('[part="content"]');
    this.toggleAttribute("loading", !selectedPanel);
    const hasOneVisiblePanel = panels.filter((panel) => !panel.hidden).length === 1;
    if (selectedPanel) {
      content.style.minHeight = "";
    } else if (hasOneVisiblePanel) {
      content.style.minHeight = `${content.offsetHeight}px`;
    }
    panels.forEach((panel) => {
      panel.hidden = panel !== selectedPanel;
    });
  }
  /** @private */
  __linkTabAndPanel(tab, panels = this.__panels) {
    const panel = panels.find((panel2) => panel2.getAttribute("tab") === tab.id);
    if (panel) {
      panel.role = "tabpanel";
      if (!panel.id) {
        panel.id = `tabsheet-panel-${generateUniqueId()}`;
      }
      panel.setAttribute("aria-labelledby", tab.id);
      tab.setAttribute("aria-controls", panel.id);
    }
  }
};

// node_modules/@vaadin/tabsheet/src/vaadin-tabsheet.js
var TabSheet = class extends TabSheetMixin(ThemableMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host([hidden]) {
          display: none !important;
        }

        :host {
          display: flex;
          flex-direction: column;
        }

        [part='tabs-container'] {
          position: relative;
          display: flex;
          align-items: center;
        }

        ::slotted([slot='tabs']) {
          flex: 1;
          align-self: stretch;
          min-width: 8em;
        }

        [part='content'] {
          position: relative;
          flex: 1;
          box-sizing: border-box;
        }
      </style>

      <div part="tabs-container">
        <slot name="prefix"></slot>
        <slot name="tabs"></slot>
        <slot name="suffix"></slot>
      </div>

      <vaadin-tabsheet-scroller part="content">
        <div part="loader"></div>
        <slot id="panel-slot"></slot>
      </vaadin-tabsheet-scroller>
    `;
  }
  static get is() {
    return "vaadin-tabsheet";
  }
};
defineCustomElement(TabSheet);

export {
  TabSheet
};
/*! Bundled license information:

@vaadin/tabsheet/src/vaadin-tabsheet-scroller.js:
  (**
   * @license
   * Copyright (c) 2022 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/tabsheet/src/vaadin-tabsheet-mixin.js:
  (**
   * @license
   * Copyright (c) 2022 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/tabsheet/src/vaadin-tabsheet.js:
  (**
   * @license
   * Copyright (c) 2022 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-236SQ66Y.js.map
