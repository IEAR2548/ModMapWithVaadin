{
  "version": 3,
  "sources": ["../../ol/src/Tile.js", "../../ol/src/ImageTile.js", "../../ol/src/reproj/Tile.js", "../../ol/src/TileRange.js"],
  "sourcesContent": ["/**\r\n * @module ol/Tile\r\n */\r\nimport EventTarget from './events/Target.js';\r\nimport EventType from './events/EventType.js';\r\nimport TileState from './TileState.js';\r\nimport {abstract} from './util.js';\r\nimport {easeIn} from './easing.js';\r\n\r\n/**\r\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\r\n * `{string}` for the url as arguments. The default is\r\n * ```js\r\n * source.setTileLoadFunction(function(tile, src) {\r\n *   tile.getImage().src = src;\r\n * });\r\n * ```\r\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\r\n * error handling:\r\n *\r\n * ```js\r\n * import TileState from 'ol/TileState';\r\n *\r\n * source.setTileLoadFunction(function(tile, src) {\r\n *   var xhr = new XMLHttpRequest();\r\n *   xhr.responseType = 'blob';\r\n *   xhr.addEventListener('loadend', function (evt) {\r\n *     var data = this.response;\r\n *     if (data !== undefined) {\r\n *       tile.getImage().src = URL.createObjectURL(data);\r\n *     } else {\r\n *       tile.setState(TileState.ERROR);\r\n *     }\r\n *   });\r\n *   xhr.addEventListener('error', function () {\r\n *     tile.setState(TileState.ERROR);\r\n *   });\r\n *   xhr.open('GET', src);\r\n *   xhr.send();\r\n * });\r\n * ```\r\n *\r\n * @typedef {function(Tile, string): void} LoadFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\r\n * the url that provides a tile for a given tile coordinate.\r\n *\r\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\r\n * coordinate, a `{number}` representing the pixel ratio and a\r\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\r\n * and returns a `{string}` representing the tile URL, or undefined if no tile\r\n * should be requested for the passed tile coordinate.\r\n *\r\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\r\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @api\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for tiles.\r\n *\r\n * @abstract\r\n */\r\nclass Tile extends EventTarget {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {Options} [opt_options] Tile options.\r\n   */\r\n  constructor(tileCoord, state, opt_options) {\r\n    super();\r\n\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    /**\r\n     * @type {import(\"./tilecoord.js\").TileCoord}\r\n     */\r\n    this.tileCoord = tileCoord;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./TileState.js\").default}\r\n     */\r\n    this.state = state;\r\n\r\n    /**\r\n     * An \"interim\" tile for this tile. The interim tile may be used while this\r\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\r\n     * on the source.\r\n     * @type {Tile}\r\n     */\r\n    this.interimTile = null;\r\n\r\n    /**\r\n     * A key assigned to the tile. This is used by the tile source to determine\r\n     * if this tile can effectively be used, or if a new tile should be created\r\n     * and this one be used as an interim tile for this new tile.\r\n     * @type {string}\r\n     */\r\n    this.key = '';\r\n\r\n    /**\r\n     * The duration for the opacity transition.\r\n     * @type {number}\r\n     */\r\n    this.transition_ =\r\n      options.transition === undefined ? 250 : options.transition;\r\n\r\n    /**\r\n     * Lookup of start times for rendering transitions.  If the start time is\r\n     * equal to -1, the transition is complete.\r\n     * @type {Object<string, number>}\r\n     */\r\n    this.transitionStarts_ = {};\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.interpolate = !!options.interpolate;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  changed() {\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  /**\r\n   * Called by the tile cache when the tile is removed from the cache due to expiry\r\n   */\r\n  release() {}\r\n\r\n  /**\r\n   * @return {string} Key.\r\n   */\r\n  getKey() {\r\n    return this.key + '/' + this.tileCoord;\r\n  }\r\n\r\n  /**\r\n   * Get the interim tile most suitable for rendering using the chain of interim\r\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\r\n   * such tile exists, the original tile is returned.\r\n   * @return {!Tile} Best tile for rendering.\r\n   */\r\n  getInterimTile() {\r\n    if (!this.interimTile) {\r\n      //empty chain\r\n      return this;\r\n    }\r\n    let tile = this.interimTile;\r\n\r\n    // find the first loaded tile and return it. Since the chain is sorted in\r\n    // decreasing order of creation time, there is no need to search the remainder\r\n    // of the list (all those tiles correspond to older requests and will be\r\n    // cleaned up by refreshInterimChain)\r\n    do {\r\n      if (tile.getState() == TileState.LOADED) {\r\n        // Show tile immediately instead of fading it in after loading, because\r\n        // the interim tile is in place already\r\n        this.transition_ = 0;\r\n        return tile;\r\n      }\r\n      tile = tile.interimTile;\r\n    } while (tile);\r\n\r\n    // we can not find a better tile\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Goes through the chain of interim tiles and discards sections of the chain\r\n   * that are no longer relevant.\r\n   */\r\n  refreshInterimChain() {\r\n    if (!this.interimTile) {\r\n      return;\r\n    }\r\n\r\n    let tile = this.interimTile;\r\n\r\n    /**\r\n     * @type {Tile}\r\n     */\r\n    let prev = this;\r\n\r\n    do {\r\n      if (tile.getState() == TileState.LOADED) {\r\n        //we have a loaded tile, we can discard the rest of the list\r\n        //we would could abort any LOADING tile request\r\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\r\n        tile.interimTile = null;\r\n        break;\r\n      } else if (tile.getState() == TileState.LOADING) {\r\n        //keep this LOADING tile any loaded tiles later in the chain are\r\n        //older than this tile, so we're still interested in the request\r\n        prev = tile;\r\n      } else if (tile.getState() == TileState.IDLE) {\r\n        //the head of the list is the most current tile, we don't need\r\n        //to start any other requests for this chain\r\n        prev.interimTile = tile.interimTile;\r\n      } else {\r\n        prev = tile;\r\n      }\r\n      tile = prev.interimTile;\r\n    } while (tile);\r\n  }\r\n\r\n  /**\r\n   * Get the tile coordinate for this tile.\r\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoord() {\r\n    return this.tileCoord;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./TileState.js\").default} State.\r\n   */\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\r\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\r\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\r\n   * the tile queue and will block other requests.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @api\r\n   */\r\n  setState(state) {\r\n    if (this.state !== TileState.ERROR && this.state > state) {\r\n      throw new Error('Tile load sequence violation');\r\n    }\r\n    this.state = state;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load the image or retry if loading previously failed.\r\n   * Loading is taken care of by the tile queue, and calling this method is\r\n   * only needed for preloading or for reloading in case of an error.\r\n   * @abstract\r\n   * @api\r\n   */\r\n  load() {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Get the alpha value for rendering.\r\n   * @param {string} id An id for the renderer.\r\n   * @param {number} time The render frame time.\r\n   * @return {number} A number between 0 and 1.\r\n   */\r\n  getAlpha(id, time) {\r\n    if (!this.transition_) {\r\n      return 1;\r\n    }\r\n\r\n    let start = this.transitionStarts_[id];\r\n    if (!start) {\r\n      start = time;\r\n      this.transitionStarts_[id] = start;\r\n    } else if (start === -1) {\r\n      return 1;\r\n    }\r\n\r\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\r\n    if (delta >= this.transition_) {\r\n      return 1;\r\n    }\r\n    return easeIn(delta / this.transition_);\r\n  }\r\n\r\n  /**\r\n   * Determine if a tile is in an alpha transition.  A tile is considered in\r\n   * transition if tile.getAlpha() has not yet been called or has been called\r\n   * and returned 1.\r\n   * @param {string} id An id for the renderer.\r\n   * @return {boolean} The tile is in transition.\r\n   */\r\n  inTransition(id) {\r\n    if (!this.transition_) {\r\n      return false;\r\n    }\r\n    return this.transitionStarts_[id] !== -1;\r\n  }\r\n\r\n  /**\r\n   * Mark a transition as complete.\r\n   * @param {string} id An id for the renderer.\r\n   */\r\n  endTransition(id) {\r\n    if (this.transition_) {\r\n      this.transitionStarts_[id] = -1;\r\n    }\r\n  }\r\n}\r\n\r\nexport default Tile;\r\n", "/**\r\n * @module ol/ImageTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\nimport {listenImage} from './Image.js';\r\n\r\nclass ImageTile extends Tile {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {string} src Image source URI.\r\n   * @param {?string} crossOrigin Cross origin.\r\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @param {import(\"./Tile.js\").Options} [opt_options] Tile options.\r\n   */\r\n  constructor(\r\n    tileCoord,\r\n    state,\r\n    src,\r\n    crossOrigin,\r\n    tileLoadFunction,\r\n    opt_options\r\n  ) {\r\n    super(tileCoord, state, opt_options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {?string}\r\n     */\r\n    this.crossOrigin_ = crossOrigin;\r\n\r\n    /**\r\n     * Image URI\r\n     *\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.src_ = src;\r\n\r\n    this.key = src;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLImageElement|HTMLCanvasElement}\r\n     */\r\n    this.image_ = new Image();\r\n    if (crossOrigin !== null) {\r\n      this.image_.crossOrigin = crossOrigin;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {?function():void}\r\n     */\r\n    this.unlisten_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./Tile.js\").LoadFunction}\r\n     */\r\n    this.tileLoadFunction_ = tileLoadFunction;\r\n  }\r\n\r\n  /**\r\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @api\r\n   */\r\n  getImage() {\r\n    return this.image_;\r\n  }\r\n\r\n  /**\r\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\r\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\r\n   */\r\n  setImage(element) {\r\n    this.image_ = element;\r\n    this.state = TileState.LOADED;\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks loading or read errors.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageError_() {\r\n    this.state = TileState.ERROR;\r\n    this.unlistenImage_();\r\n    this.image_ = getBlankImage();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks successful image load.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageLoad_() {\r\n    const image = /** @type {HTMLImageElement} */ (this.image_);\r\n    if (image.naturalWidth && image.naturalHeight) {\r\n      this.state = TileState.LOADED;\r\n    } else {\r\n      this.state = TileState.EMPTY;\r\n    }\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @api\r\n   */\r\n  load() {\r\n    if (this.state == TileState.ERROR) {\r\n      this.state = TileState.IDLE;\r\n      this.image_ = new Image();\r\n      if (this.crossOrigin_ !== null) {\r\n        this.image_.crossOrigin = this.crossOrigin_;\r\n      }\r\n    }\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n      this.tileLoadFunction_(this, this.src_);\r\n      this.unlisten_ = listenImage(\r\n        this.image_,\r\n        this.handleImageLoad_.bind(this),\r\n        this.handleImageError_.bind(this)\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Discards event handlers which listen for load completion or errors.\r\n   *\r\n   * @private\r\n   */\r\n  unlistenImage_() {\r\n    if (this.unlisten_) {\r\n      this.unlisten_();\r\n      this.unlisten_ = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get a 1-pixel blank image.\r\n * @return {HTMLCanvasElement} Blank image.\r\n */\r\nfunction getBlankImage() {\r\n  const ctx = createCanvasContext2D(1, 1);\r\n  ctx.fillStyle = 'rgba(0,0,0,0)';\r\n  ctx.fillRect(0, 0, 1, 1);\r\n  return ctx.canvas;\r\n}\r\n\r\nexport default ImageTile;\r\n", "/**\r\n * @module ol/reproj/Tile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport Tile from '../Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceExtentResolution,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {getArea, getIntersection} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected tile.\r\n * See {@link module:ol/source/TileImage~TileImage}.\r\n *\r\n */\r\nclass ReprojTile extends Tile {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} gutter Gutter of the source tiles.\r\n   * @param {FunctionType} getTileFunction\r\n   *     Function returning source tiles (z, x, y, pixelRatio).\r\n   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\r\n   * @param {boolean} [opt_renderEdges] Render reprojection edges.\r\n   * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    sourceTileGrid,\r\n    targetProj,\r\n    targetTileGrid,\r\n    tileCoord,\r\n    wrappedTileCoord,\r\n    pixelRatio,\r\n    gutter,\r\n    getTileFunction,\r\n    opt_errorThreshold,\r\n    opt_renderEdges,\r\n    opt_interpolate\r\n  ) {\r\n    super(tileCoord, TileState.IDLE, {interpolate: !!opt_interpolate});\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = gutter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<import(\"../Tile.js\").default>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    const targetExtent = targetTileGrid.getTileCoordExtent(\r\n      this.wrappedTileCoord_\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = targetTileGrid.getResolution(\r\n      this.wrappedTileCoord_[0]\r\n    );\r\n\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3]\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3]\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\r\n        sourceExtent,\r\n        this.sourceZ_\r\n      );\r\n\r\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\r\n          if (tile) {\r\n            this.sourceTiles_.push(tile);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the HTML Canvas element for this tile.\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const sources = [];\r\n    this.sourceTiles_.forEach(\r\n      function (tile, i, arr) {\r\n        if (tile && tile.getState() == TileState.LOADED) {\r\n          sources.push({\r\n            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\r\n            image: tile.getImage(),\r\n          });\r\n        }\r\n      }.bind(this)\r\n    );\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (sources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n    } else {\r\n      const z = this.wrappedTileCoord_[0];\r\n      const size = this.targetTileGrid_.getTileSize(z);\r\n      const width = typeof size === 'number' ? size : size[0];\r\n      const height = typeof size === 'number' ? size : size[1];\r\n      const targetResolution = this.targetTileGrid_.getResolution(z);\r\n      const sourceResolution = this.sourceTileGrid_.getResolution(\r\n        this.sourceZ_\r\n      );\r\n\r\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n        this.wrappedTileCoord_\r\n      );\r\n\r\n      this.canvas_ = renderReprojected(\r\n        width,\r\n        height,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        this.sourceTileGrid_.getExtent(),\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        this.renderEdges_,\r\n        this.interpolate\r\n      );\r\n\r\n      this.state = TileState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   */\r\n  load() {\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n\r\n      let leftToLoad = 0;\r\n\r\n      this.sourcesListenerKeys_ = [];\r\n      this.sourceTiles_.forEach(\r\n        function (tile, i, arr) {\r\n          const state = tile.getState();\r\n          if (state == TileState.IDLE || state == TileState.LOADING) {\r\n            leftToLoad++;\r\n\r\n            const sourceListenKey = listen(\r\n              tile,\r\n              EventType.CHANGE,\r\n              function (e) {\r\n                const state = tile.getState();\r\n                if (\r\n                  state == TileState.LOADED ||\r\n                  state == TileState.ERROR ||\r\n                  state == TileState.EMPTY\r\n                ) {\r\n                  unlistenByKey(sourceListenKey);\r\n                  leftToLoad--;\r\n                  if (leftToLoad === 0) {\r\n                    this.unlistenSources_();\r\n                    this.reproject_();\r\n                  }\r\n                }\r\n              },\r\n              this\r\n            );\r\n            this.sourcesListenerKeys_.push(sourceListenKey);\r\n          }\r\n        }.bind(this)\r\n      );\r\n\r\n      if (leftToLoad === 0) {\r\n        setTimeout(this.reproject_.bind(this), 0);\r\n      } else {\r\n        this.sourceTiles_.forEach(function (tile, i, arr) {\r\n          const state = tile.getState();\r\n          if (state == TileState.IDLE) {\r\n            tile.load();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n}\r\n\r\nexport default ReprojTile;\r\n", "/**\r\n * @module ol/TileRange\r\n */\r\n\r\n/**\r\n * A representation of a contiguous block of tiles.  A tile range is specified\r\n * by its min/max tile coordinates and is inclusive of coordinates.\r\n */\r\nclass TileRange {\r\n  /**\r\n   * @param {number} minX Minimum X.\r\n   * @param {number} maxX Maximum X.\r\n   * @param {number} minY Minimum Y.\r\n   * @param {number} maxY Maximum Y.\r\n   */\r\n  constructor(minX, maxX, minY, maxY) {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.minX = minX;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.maxX = maxX;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.minY = minY;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.maxY = maxY;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {boolean} Contains tile coordinate.\r\n   */\r\n  contains(tileCoord) {\r\n    return this.containsXY(tileCoord[1], tileCoord[2]);\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Contains.\r\n   */\r\n  containsTileRange(tileRange) {\r\n    return (\r\n      this.minX <= tileRange.minX &&\r\n      tileRange.maxX <= this.maxX &&\r\n      this.minY <= tileRange.minY &&\r\n      tileRange.maxY <= this.maxY\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @return {boolean} Contains coordinate.\r\n   */\r\n  containsXY(x, y) {\r\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Equals.\r\n   */\r\n  equals(tileRange) {\r\n    return (\r\n      this.minX == tileRange.minX &&\r\n      this.minY == tileRange.minY &&\r\n      this.maxX == tileRange.maxX &&\r\n      this.maxY == tileRange.maxY\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   */\r\n  extend(tileRange) {\r\n    if (tileRange.minX < this.minX) {\r\n      this.minX = tileRange.minX;\r\n    }\r\n    if (tileRange.maxX > this.maxX) {\r\n      this.maxX = tileRange.maxX;\r\n    }\r\n    if (tileRange.minY < this.minY) {\r\n      this.minY = tileRange.minY;\r\n    }\r\n    if (tileRange.maxY > this.maxY) {\r\n      this.maxY = tileRange.maxY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {number} Height.\r\n   */\r\n  getHeight() {\r\n    return this.maxY - this.minY + 1;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./size.js\").Size} Size.\r\n   */\r\n  getSize() {\r\n    return [this.getWidth(), this.getHeight()];\r\n  }\r\n\r\n  /**\r\n   * @return {number} Width.\r\n   */\r\n  getWidth() {\r\n    return this.maxX - this.minX + 1;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Intersects.\r\n   */\r\n  intersects(tileRange) {\r\n    return (\r\n      this.minX <= tileRange.maxX &&\r\n      this.maxX >= tileRange.minX &&\r\n      this.minY <= tileRange.maxY &&\r\n      this.maxY >= tileRange.minY\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} minX Minimum X.\r\n * @param {number} maxX Maximum X.\r\n * @param {number} minY Minimum Y.\r\n * @param {number} maxY Maximum Y.\r\n * @param {TileRange} [tileRange] TileRange.\r\n * @return {TileRange} Tile range.\r\n */\r\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\r\n  if (tileRange !== undefined) {\r\n    tileRange.minX = minX;\r\n    tileRange.maxX = maxX;\r\n    tileRange.minY = minY;\r\n    tileRange.maxY = maxY;\r\n    return tileRange;\r\n  } else {\r\n    return new TileRange(minX, maxX, minY, maxY);\r\n  }\r\n}\r\n\r\nexport default TileRange;\r\n"],
  "mappings": "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",
  "names": ["Tile", "__extends", "ImageTile", "__extends", "ReprojTile", "state", "Tile_default", "TileRange"]
}
