import {
  processTemplates
} from "./chunk-KDMU7KRZ.js";
import {
  OverlayClassMixin
} from "./chunk-UF5ES3VB.js";
import {
  OverlayStackMixin
} from "./chunk-NPC7FAUI.js";
import {
  isIOS
} from "./chunk-VNRF6E57.js";
import {
  ThemableMixin,
  ThemePropertyMixin,
  registerStyles
} from "./chunk-KEWLZU7R.js";
import {
  ElementMixin
} from "./chunk-QN4QZSZG.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import {
  PolymerElement
} from "./chunk-YBEXGSZO.js";
import {
  html
} from "./chunk-QO5P4LIH.js";
import {
  isTemplateResult
} from "./chunk-NRT2FW3G.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";
import {
  render
} from "./chunk-4QYCOPDF.js";

// node_modules/@vaadin/notification/theme/lumo/vaadin-notification-styles.js
registerStyles(
  "vaadin-notification-card",
  css`
    :host {
      position: relative;
      margin: var(--lumo-space-s);
    }

    [part='overlay'] {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      border-radius: var(--lumo-border-radius-l);
      box-shadow:
        0 0 0 1px var(--lumo-contrast-10pct),
        var(--lumo-box-shadow-l);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      font-weight: 400;
      line-height: var(--lumo-line-height-s);
      letter-spacing: 0;
      text-transform: none;
      -webkit-text-size-adjust: 100%;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    [part='content'] {
      padding: var(--lumo-space-wide-l);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    [part='content'] ::slotted(vaadin-button) {
      flex: none;
      margin: 0 calc(var(--lumo-space-s) * -1) 0 var(--lumo-space-m);
    }

    :host([slot^='middle']) {
      max-width: 80vw;
      margin: var(--lumo-space-s) auto;
    }

    :host([slot$='stretch']) {
      margin: 0;
    }

    :host([slot$='stretch']) [part='overlay'] {
      border-radius: 0;
    }

    @media (min-width: 421px) {
      :host(:not([slot$='stretch'])) {
        display: flex;
      }

      :host([slot$='end']) {
        justify-content: flex-end;
      }

      :host([slot^='middle']),
      :host([slot$='center']) {
        display: flex;
        justify-content: center;
      }
    }

    @keyframes lumo-notification-exit-fade-out {
      100% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-fade-in {
      0% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-down {
      0% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-up {
      100% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-up {
      0% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-down {
      100% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    :host([slot='middle'][opening]) {
      animation: lumo-notification-enter-fade-in 300ms;
    }

    :host([slot='middle'][closing]) {
      animation: lumo-notification-exit-fade-out 300ms;
    }

    :host([slot^='top'][opening]) {
      animation: lumo-notification-enter-slide-down 300ms;
    }

    :host([slot^='top'][closing]) {
      animation: lumo-notification-exit-slide-up 300ms;
    }

    :host([slot^='bottom'][opening]) {
      animation: lumo-notification-enter-slide-up 300ms;
    }

    :host([slot^='bottom'][closing]) {
      animation: lumo-notification-exit-slide-down 300ms;
    }

    :host([theme='success']) {
      --_focus-ring-gap-color: var(--lumo-success-color);
      --vaadin-focus-ring-color: var(--lumo-success-contrast-color);
    }

    :host([theme='warning']) {
      --_focus-ring-gap-color: var(--lumo-warning-color);
      --vaadin-focus-ring-color: var(--lumo-warning-contrast-color);
    }

    :host([theme='error']) {
      --_focus-ring-gap-color: var(--lumo-error-color);
      --vaadin-focus-ring-color: var(--lumo-error-contrast-color);
    }

    :host([theme='primary']) {
      --_focus-ring-gap-color: var(--lumo-primary-color);
      --vaadin-focus-ring-color: var(--lumo-primary-contrast-color);
    }

    :host([theme~='primary']) [part='overlay'] {
      background: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='primary']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-background: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-primary-text-color);
    }

    :host([theme~='contrast']) [part='overlay'] {
      background: var(--lumo-contrast);
      color: var(--lumo-base-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='contrast']) {
      --vaadin-button-background: var(--lumo-contrast-20pct);
      --vaadin-button-text-color: var(--lumo-base-color);
      --vaadin-button-primary-background: var(--lumo-base-color);
      --vaadin-button-primary-text-color: var(--lumo-contrast);
    }

    :host([theme~='success']) [part='overlay'] {
      background: var(--lumo-success-color);
      color: var(--lumo-success-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='success']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-success-contrast-color);
      --vaadin-button-primary-background: var(--lumo-success-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-success-text-color);
    }

    :host([theme~='error']) [part='overlay'] {
      background: var(--lumo-error-color);
      color: var(--lumo-error-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='error']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-error-contrast-color);
      --vaadin-button-primary-background: var(--lumo-error-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-error-text-color);
    }

    :host([theme~='warning']) [part='overlay'] {
      background: var(--lumo-warning-color);
      color: var(--lumo-warning-contrast-color);
      box-shadow:
        inset 0 0 0 1px var(--lumo-contrast-20pct),
        var(--lumo-box-shadow-l);
    }

    :host([theme~='warning']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-warning-contrast-color);
      --vaadin-button-primary-background: var(--lumo-shade-50pct);
      --vaadin-button-primary-text-color: var(--lumo-primary-contrast-color);
    }
  `,
  { moduleId: "lumo-notification-card" }
);

// node_modules/@vaadin/notification/src/vaadin-notification-mixin.js
var NotificationContainerMixin = (superClass) => class extends OverlayStackMixin(superClass) {
  static get properties() {
    return {
      /**
       * True when the container is opened
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        sync: true,
        observer: "_openedChanged"
      }
    };
  }
  constructor() {
    super();
    this._boundVaadinOverlayClose = this._onVaadinOverlayClose.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      document.body.appendChild(this);
      document.addEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        this._detectIosNavbar();
        window.addEventListener("resize", this._boundIosResizeListener);
      }
    } else {
      document.body.removeChild(this);
      document.removeEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        window.removeEventListener("resize", this._boundIosResizeListener);
      }
    }
  }
  /** @private */
  _detectIosNavbar() {
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.bottom = `${clientHeight - innerHeight}px`;
    } else {
      this.style.bottom = "0";
    }
  }
  /** @private */
  _onVaadinOverlayClose(event) {
    const sourceEvent = event.detail.sourceEvent;
    const isFromNotification = sourceEvent && sourceEvent.composedPath().indexOf(this) >= 0;
    if (isFromNotification) {
      event.preventDefault();
    }
  }
};
var NotificationMixin = (superClass) => class extends ThemePropertyMixin(OverlayClassMixin(superClass)) {
  static get properties() {
    return {
      /**
       * When true, the notification card has `aria-live` attribute set to
       * `assertive` instead of `polite`. This makes screen readers announce
       * the notification content immediately when it appears.
       */
      assertive: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * The duration in milliseconds to show the notification.
       * Set to `0` or a negative number to disable the notification auto-closing.
       * @type {number}
       */
      duration: {
        type: Number,
        value: 5e3,
        sync: true
      },
      /**
       * True if the notification is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        sync: true,
        observer: "_openedChanged"
      },
      /**
       * Alignment of the notification in the viewport
       * Valid values are `top-stretch|top-start|top-center|top-end|middle|bottom-start|bottom-center|bottom-end|bottom-stretch`
       * @type {!NotificationPosition}
       */
      position: {
        type: String,
        value: "bottom-start",
        observer: "_positionChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of the notification.
       * Receives two arguments:
       *
       * - `root` The `<vaadin-notification-card>` DOM element. Append
       *   your content to it.
       * - `notification` The reference to the `<vaadin-notification>` element.
       * @type {!NotificationRenderer | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_durationChanged(duration, opened)", "_rendererChanged(renderer, opened, _overlayElement)"];
  }
  /**
   * Shows a notification with the given content.
   * By default, positions the notification at `bottom-start` and uses a 5 second duration.
   * An options object can be passed to configure the notification.
   * The options object has the following structure:
   *
   * ```
   * {
   *   assertive?: boolean
   *   position?: string
   *   duration?: number
   *   theme?: string
   * }
   * ```
   *
   * See the individual documentation for:
   * - [`assertive`](#/elements/vaadin-notification#property-assertive)
   * - [`position`](#/elements/vaadin-notification#property-position)
   * - [`duration`](#/elements/vaadin-notification#property-duration)
   *
   * @param contents the contents to show, either as a string or a Lit template.
   * @param options optional options for customizing the notification.
   */
  static show(contents, options) {
    const Notification2 = customElements.get("vaadin-notification");
    if (isTemplateResult(contents)) {
      return Notification2._createAndShowNotification((root) => {
        render(contents, root);
      }, options);
    }
    return Notification2._createAndShowNotification((root) => {
      root.innerText = contents;
    }, options);
  }
  /** @private */
  static _createAndShowNotification(renderer, options) {
    const notification = document.createElement("vaadin-notification");
    if (options && Number.isFinite(options.duration)) {
      notification.duration = options.duration;
    }
    if (options && options.position) {
      notification.position = options.position;
    }
    if (options && options.assertive) {
      notification.assertive = options.assertive;
    }
    if (options && options.theme) {
      notification.setAttribute("theme", options.theme);
    }
    notification.renderer = renderer;
    document.body.appendChild(notification);
    notification.opened = true;
    notification.addEventListener("opened-changed", (e) => {
      if (!e.detail.value) {
        notification.remove();
      }
    });
    return notification;
  }
  /** @private */
  get _container() {
    const Notification2 = customElements.get("vaadin-notification");
    if (!Notification2._container) {
      Notification2._container = document.createElement("vaadin-notification-container");
      document.body.appendChild(Notification2._container);
    }
    return Notification2._container;
  }
  /** @protected */
  get _card() {
    return this._overlayElement;
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.shadowRoot.querySelector("vaadin-notification-card");
    processTemplates(this);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    queueMicrotask(() => {
      if (!this.isConnected) {
        this.opened = false;
      }
    });
  }
  /**
   * Requests an update for the content of the notification.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || !this._card) {
      return;
    }
    this.renderer(this._card, this);
  }
  /** @private */
  __computeAriaLive(assertive) {
    return assertive ? "assertive" : "polite";
  }
  /** @private */
  _rendererChanged(renderer, opened, card) {
    if (!card) {
      return;
    }
    const rendererChanged = this._oldRenderer !== renderer;
    this._oldRenderer = renderer;
    if (rendererChanged) {
      card.innerHTML = "";
      delete card._$litPart$;
    }
    if (opened) {
      if (!this._didAnimateNotificationAppend) {
        this._animatedAppendNotificationCard();
      }
      this.requestContentUpdate();
    }
  }
  /**
   * Opens the notification.
   */
  open() {
    this.opened = true;
  }
  /**
   * Closes the notification.
   */
  close() {
    this.opened = false;
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      this._container.opened = true;
      this._animatedAppendNotificationCard();
    } else if (this._card) {
      this._closeNotificationCard();
    }
  }
  /** @private */
  __cleanUpOpeningClosingState() {
    this._card.removeAttribute("opening");
    this._card.removeAttribute("closing");
    this._card.removeEventListener("animationend", this.__animationEndListener);
  }
  /** @private */
  _animatedAppendNotificationCard() {
    if (this._card) {
      this.__cleanUpOpeningClosingState();
      this._card.setAttribute("opening", "");
      this._appendNotificationCard();
      this.__animationEndListener = () => this.__cleanUpOpeningClosingState();
      this._card.addEventListener("animationend", this.__animationEndListener);
      this._didAnimateNotificationAppend = true;
    } else {
      this._didAnimateNotificationAppend = false;
    }
  }
  /** @private */
  _appendNotificationCard() {
    if (!this._card) {
      return;
    }
    if (!this._container.shadowRoot.querySelector(`slot[name="${this.position}"]`)) {
      console.warn(`Invalid alignment parameter provided: position=${this.position}`);
      return;
    }
    this._container.bringToFront();
    this._card.slot = this.position;
    if (this._container.firstElementChild && /top/u.test(this.position)) {
      this._container.insertBefore(this._card, this._container.firstElementChild);
    } else {
      this._container.appendChild(this._card);
    }
  }
  /** @private */
  _removeNotificationCard() {
    if (!this._card) {
      return;
    }
    if (this._card.parentNode) {
      this._card.parentNode.removeChild(this._card);
    }
    this._card.removeAttribute("closing");
    this._container.opened = Boolean(this._container.firstElementChild);
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @private */
  _closeNotificationCard() {
    if (this._durationTimeoutId) {
      clearTimeout(this._durationTimeoutId);
    }
    this._animatedRemoveNotificationCard();
  }
  /** @private */
  _animatedRemoveNotificationCard() {
    this.__cleanUpOpeningClosingState();
    this._card.setAttribute("closing", "");
    const name = getComputedStyle(this._card).getPropertyValue("animation-name");
    if (name && name !== "none") {
      this.__animationEndListener = () => {
        this._removeNotificationCard();
        this.__cleanUpOpeningClosingState();
      };
      this._card.addEventListener("animationend", this.__animationEndListener);
    } else {
      this._removeNotificationCard();
    }
  }
  /** @private */
  _positionChanged() {
    if (this.opened) {
      this._animatedAppendNotificationCard();
    }
  }
  /** @private */
  _durationChanged(duration, opened) {
    if (opened) {
      clearTimeout(this._durationTimeoutId);
      if (duration > 0) {
        this._durationTimeoutId = setTimeout(() => this.close(), duration);
      }
    }
  }
  /**
   * Fired when the notification is closed.
   *
   * @event closed
   */
};

// node_modules/@vaadin/notification/src/vaadin-notification-styles.js
var notificationContainerStyles = css`
  :host {
    position: fixed;
    z-index: 1000;
    inset: 0;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    pointer-events: none;
  }

  [region-group] {
    flex: 1 1 0%;
    display: flex;
  }

  [region-group='top'] {
    align-items: flex-start;
  }

  [region-group='bottom'] {
    align-items: flex-end;
  }

  [region-group] > [region] {
    flex: 1 1 0%;
  }

  @media (max-width: 420px) {
    [region-group] {
      flex-direction: column;
      align-items: stretch;
    }

    [region-group='top'] {
      justify-content: flex-start;
    }

    [region-group='bottom'] {
      justify-content: flex-end;
    }

    [region-group] > [region] {
      flex: initial;
    }
  }
`;
var notificationCardStyles = css`
  :host {
    display: block;
  }

  [part='overlay'] {
    pointer-events: auto;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;

// node_modules/@vaadin/notification/src/vaadin-notification.js
registerStyles("vaadin-notification-container", notificationContainerStyles, {
  moduleId: "vaadin-notification-container-styles"
});
registerStyles("vaadin-notification-card", notificationCardStyles, {
  moduleId: "vaadin-notification-card-styles"
});
var NotificationContainer = class extends NotificationContainerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <div region="top-stretch"><slot name="top-stretch"></slot></div>
      <div region-group="top">
        <div region="top-start"><slot name="top-start"></slot></div>
        <div region="top-center"><slot name="top-center"></slot></div>
        <div region="top-end"><slot name="top-end"></slot></div>
      </div>
      <div region="middle"><slot name="middle"></slot></div>
      <div region-group="bottom">
        <div region="bottom-start"><slot name="bottom-start"></slot></div>
        <div region="bottom-center"><slot name="bottom-center"></slot></div>
        <div region="bottom-end"><slot name="bottom-end"></slot></div>
      </div>
      <div region="bottom-stretch"><slot name="bottom-stretch"></slot></div>
    `;
  }
  static get is() {
    return "vaadin-notification-container";
  }
};
var NotificationCard = class extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
      <div part="overlay">
        <div part="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-notification-card";
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "alert");
  }
};
var Notification = class extends NotificationMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: none !important;
        }
      </style>
      <vaadin-notification-card
        theme$="[[_theme]]"
        aria-live$="[[__computeAriaLive(assertive)]]"
      ></vaadin-notification-card>
    `;
  }
  static get is() {
    return "vaadin-notification";
  }
};
defineCustomElement(NotificationContainer);
defineCustomElement(NotificationCard);
defineCustomElement(Notification);

export {
  Notification
};
/*! Bundled license information:

@vaadin/notification/src/vaadin-notification-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/notification/src/vaadin-notification-styles.js:
  (**
   * @license
   * Copyright (c) 2016 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/notification/src/vaadin-notification.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-YUHOTINU.js.map
