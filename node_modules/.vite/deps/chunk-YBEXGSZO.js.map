{
  "version": 3,
  "sources": ["../../@polymer/polymer/lib/utils/wrap.js", "../../@polymer/polymer/lib/utils/path.js", "../../@polymer/polymer/lib/utils/case-map.js", "../../@polymer/polymer/lib/mixins/properties-changed.js", "../../@polymer/polymer/lib/mixins/property-accessors.js", "../../@polymer/polymer/lib/mixins/template-stamp.js", "../../@polymer/polymer/lib/mixins/property-effects.js", "../../@polymer/polymer/lib/utils/telemetry.js", "../../@polymer/polymer/lib/mixins/properties-mixin.js", "../../@polymer/polymer/lib/mixins/element-mixin.js", "../../@polymer/polymer/polymer-element.js"],
  "sourcesContent": ["/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/* eslint-disable valid-jsdoc */\r\n/**\r\n * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill\r\n * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,\r\n * a node wrapper must be used to access ShadowDOM API.\r\n * This is similar to using `Polymer.dom` but relies exclusively\r\n * on the presence of the ShadyDOM polyfill rather than requiring the loading\r\n * of legacy (Polymer.dom) API.\r\n * @type {function(Node):Node}\r\n */\r\nexport const wrap = (window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap']) ?\r\n  window['ShadyDOM']['wrap'] :\r\n  (window['ShadyDOM'] ? (n) => ShadyDOM['patch'](n) : (n) => n);\r\n\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\nimport './boot.js';\r\n\r\n/**\r\n * Module with utilities for manipulating structured data path strings.\r\n *\r\n * @summary Module with utilities for manipulating structured data path strings.\r\n */\r\n\r\n/**\r\n * Returns true if the given string is a structured data path (has dots).\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * isPath('foo.bar.baz') // true\r\n * isPath('foo')         // false\r\n * ```\r\n *\r\n * @param {string} path Path string\r\n * @return {boolean} True if the string contained one or more dots\r\n */\r\nexport function isPath(path) {\r\n  return path.indexOf('.') >= 0;\r\n}\r\n\r\n/**\r\n * Returns the root property name for the given path.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * root('foo.bar.baz') // 'foo'\r\n * root('foo')         // 'foo'\r\n * ```\r\n *\r\n * @param {string} path Path string\r\n * @return {string} Root property name\r\n */\r\nexport function root(path) {\r\n  let dotIndex = path.indexOf('.');\r\n  if (dotIndex === -1) {\r\n    return path;\r\n  }\r\n  return path.slice(0, dotIndex);\r\n}\r\n\r\n/**\r\n * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\r\n * Returns true if the given path is an ancestor of the base path.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * isAncestor('foo.bar', 'foo')         // true\r\n * isAncestor('foo.bar', 'foo.bar')     // false\r\n * isAncestor('foo.bar', 'foo.bar.baz') // false\r\n * ```\r\n *\r\n * @param {string} base Path string to test against.\r\n * @param {string} path Path string to test.\r\n * @return {boolean} True if `path` is an ancestor of `base`.\r\n */\r\nexport function isAncestor(base, path) {\r\n  //     base.startsWith(path + '.');\r\n  return base.indexOf(path + '.') === 0;\r\n}\r\n\r\n/**\r\n * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * isDescendant('foo.bar', 'foo.bar.baz') // true\r\n * isDescendant('foo.bar', 'foo.bar')     // false\r\n * isDescendant('foo.bar', 'foo')         // false\r\n * ```\r\n *\r\n * @param {string} base Path string to test against.\r\n * @param {string} path Path string to test.\r\n * @return {boolean} True if `path` is a descendant of `base`.\r\n */\r\nexport function isDescendant(base, path) {\r\n  //     path.startsWith(base + '.');\r\n  return path.indexOf(base + '.') === 0;\r\n}\r\n\r\n/**\r\n * Replaces a previous base path with a new base path, preserving the\r\n * remainder of the path.\r\n *\r\n * User must ensure `path` has a prefix of `base`.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'\r\n * ```\r\n *\r\n * @param {string} base Current base string to remove\r\n * @param {string} newBase New base string to replace with\r\n * @param {string} path Path to translate\r\n * @return {string} Translated string\r\n */\r\nexport function translate(base, newBase, path) {\r\n  return newBase + path.slice(base.length);\r\n}\r\n\r\n/**\r\n * @param {string} base Path string to test against\r\n * @param {string} path Path string to test\r\n * @return {boolean} True if `path` is equal to `base`\r\n */\r\nexport function matches(base, path) {\r\n  return (base === path) ||\r\n         isAncestor(base, path) ||\r\n         isDescendant(base, path);\r\n}\r\n\r\n/**\r\n * Converts array-based paths to flattened path.  String-based paths\r\n * are returned as-is.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\r\n * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\r\n * ```\r\n *\r\n * @param {string | !Array<string|number>} path Input path\r\n * @return {string} Flattened path\r\n */\r\nexport function normalize(path) {\r\n  if (Array.isArray(path)) {\r\n    let parts = [];\r\n    for (let i=0; i<path.length; i++) {\r\n      let args = path[i].toString().split('.');\r\n      for (let j=0; j<args.length; j++) {\r\n        parts.push(args[j]);\r\n      }\r\n    }\r\n    return parts.join('.');\r\n  } else {\r\n    return path;\r\n  }\r\n}\r\n\r\n/**\r\n * Splits a path into an array of property names. Accepts either arrays\r\n * of path parts or strings.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\r\n * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\r\n * ```\r\n *\r\n * @param {string | !Array<string|number>} path Input path\r\n * @return {!Array<string>} Array of path parts\r\n * @suppress {checkTypes}\r\n */\r\nexport function split(path) {\r\n  if (Array.isArray(path)) {\r\n    return normalize(path).split('.');\r\n  }\r\n  return path.toString().split('.');\r\n}\r\n\r\n/**\r\n * Reads a value from a path.  If any sub-property in the path is `undefined`,\r\n * this method returns `undefined` (will never throw.\r\n *\r\n * @param {Object} root Object from which to dereference path from\r\n * @param {string | !Array<string|number>} path Path to read\r\n * @param {Object=} info If an object is provided to `info`, the normalized\r\n *  (flattened) path will be set to `info.path`.\r\n * @return {*} Value at path, or `undefined` if the path could not be\r\n *  fully dereferenced.\r\n */\r\nexport function get(root, path, info) {\r\n  let prop = root;\r\n  let parts = split(path);\r\n  // Loop over path parts[0..n-1] and dereference\r\n  for (let i=0; i<parts.length; i++) {\r\n    if (!prop) {\r\n      return;\r\n    }\r\n    let part = parts[i];\r\n    prop = prop[part];\r\n  }\r\n  if (info) {\r\n    info.path = parts.join('.');\r\n  }\r\n  return prop;\r\n}\r\n\r\n/**\r\n * Sets a value to a path.  If any sub-property in the path is `undefined`,\r\n * this method will no-op.\r\n *\r\n * @param {Object} root Object from which to dereference path from\r\n * @param {string | !Array<string|number>} path Path to set\r\n * @param {*} value Value to set to path\r\n * @return {string | undefined} The normalized version of the input path\r\n */\r\nexport function set(root, path, value) {\r\n  let prop = root;\r\n  let parts = split(path);\r\n  let last = parts[parts.length-1];\r\n  if (parts.length > 1) {\r\n    // Loop over path parts[0..n-2] and dereference\r\n    for (let i=0; i<parts.length-1; i++) {\r\n      let part = parts[i];\r\n      prop = prop[part];\r\n      if (!prop) {\r\n        return;\r\n      }\r\n    }\r\n    // Set value to object at end of path\r\n    prop[last] = value;\r\n  } else {\r\n    // Simple property set\r\n    prop[path] = value;\r\n  }\r\n  return parts.join('.');\r\n}\r\n\r\n/**\r\n * Returns true if the given string is a structured data path (has dots).\r\n *\r\n * This function is deprecated.  Use `isPath` instead.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * isDeep('foo.bar.baz') // true\r\n * isDeep('foo')         // false\r\n * ```\r\n *\r\n * @deprecated\r\n * @param {string} path Path string\r\n * @return {boolean} True if the string contained one or more dots\r\n */\r\nexport const isDeep = isPath;\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\nimport './boot.js';\r\n\r\nconst caseMap = {};\r\nconst DASH_TO_CAMEL = /-[a-z]/g;\r\nconst CAMEL_TO_DASH = /([A-Z])/g;\r\n\r\n/**\r\n * @fileoverview Module with utilities for converting between \"dash-case\" and\r\n * \"camelCase\" identifiers.\r\n */\r\n\r\n/**\r\n * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\r\n * (e.g. `fooBarBaz`).\r\n *\r\n * @param {string} dash Dash-case identifier\r\n * @return {string} Camel-case representation of the identifier\r\n */\r\nexport function dashToCamelCase(dash) {\r\n  return caseMap[dash] || (\r\n    caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,\r\n      (m) => m[1].toUpperCase()\r\n    )\r\n  );\r\n}\r\n\r\n/**\r\n * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\r\n * (e.g. `foo-bar-baz`).\r\n *\r\n * @param {string} camel Camel-case identifier\r\n * @return {string} Dash-case representation of the identifier\r\n */\r\nexport function camelToDashCase(camel) {\r\n  return caseMap[camel] || (\r\n    caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()\r\n  );\r\n}\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\nimport '../utils/boot.js';\r\n\r\nimport { dedupingMixin } from '../utils/mixin.js';\r\nimport { microTask } from '../utils/async.js';\r\nimport { wrap } from '../utils/wrap.js';\r\n\r\n/** @const {!AsyncInterface} */\r\nconst microtask = microTask;\r\n\r\n/**\r\n * Element class mixin that provides basic meta-programming for creating one\r\n * or more property accessors (getter/setter pair) that enqueue an async\r\n * (batched) `_propertiesChanged` callback.\r\n *\r\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\r\n * once at class definition time to create property accessors for properties\r\n * named in props, implement `_propertiesChanged` to react as desired to\r\n * property changes, and implement `static get observedAttributes()` and\r\n * include lowercase versions of any property names that should be set from\r\n * attributes. Last, call `this._enableProperties()` in the element's\r\n * `connectedCallback` to enable the accessors.\r\n *\r\n * @mixinFunction\r\n * @polymer\r\n * @summary Element class mixin for reacting to property changes from\r\n *   generated property accessors.\r\n * @template T\r\n * @param {function(new:T)} superClass Class to apply mixin to.\r\n * @return {function(new:T)} superClass with mixin applied.\r\n */\r\nexport const PropertiesChanged = dedupingMixin(\r\n    /**\r\n     * @template T\r\n     * @param {function(new:T)} superClass Class to apply mixin to.\r\n     * @return {function(new:T)} superClass with mixin applied.\r\n     */\r\n    (superClass) => {\r\n\r\n  /**\r\n   * @polymer\r\n   * @mixinClass\r\n   * @implements {Polymer_PropertiesChanged}\r\n   * @unrestricted\r\n   */\r\n  class PropertiesChanged extends superClass {\r\n\r\n    /**\r\n     * Creates property accessors for the given property names.\r\n     * @param {!Object} props Object whose keys are names of accessors.\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createProperties(props) {\r\n      const proto = this.prototype;\r\n      for (let prop in props) {\r\n        // don't stomp an existing accessor\r\n        if (!(prop in proto)) {\r\n          proto._createPropertyAccessor(prop);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns an attribute name that corresponds to the given property.\r\n     * The attribute name is the lowercased property name. Override to\r\n     * customize this mapping.\r\n     * @param {string} property Property to convert\r\n     * @return {string} Attribute name corresponding to the given property.\r\n     *\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static attributeNameForProperty(property) {\r\n      return property.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Override point to provide a type to which to deserialize a value to\r\n     * a given property.\r\n     * @param {string} name Name of property\r\n     *\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static typeForProperty(name) { } //eslint-disable-line no-unused-vars\r\n\r\n    /**\r\n     * Creates a setter/getter pair for the named property with its own\r\n     * local storage.  The getter returns the value in the local storage,\r\n     * and the setter calls `_setProperty`, which updates the local storage\r\n     * for the property and enqueues a `_propertiesChanged` callback.\r\n     *\r\n     * This method may be called on a prototype or an instance.  Calling\r\n     * this method may overwrite a property value that already exists on\r\n     * the prototype/instance by creating the accessor.\r\n     *\r\n     * @param {string} property Name of the property\r\n     * @param {boolean=} readOnly When true, no setter is created; the\r\n     *   protected `_setProperty` function must be used to set the property\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _createPropertyAccessor(property, readOnly) {\r\n      this._addPropertyToAttributeMap(property);\r\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\r\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\r\n      }\r\n      if (!this.__dataHasAccessor[property]) {\r\n        this.__dataHasAccessor[property] = true;\r\n        this._definePropertyAccessor(property, readOnly);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Adds the given `property` to a map matching attribute names\r\n     * to property names, using `attributeNameForProperty`. This map is\r\n     * used when deserializing attribute values to properties.\r\n     *\r\n     * @param {string} property Name of the property\r\n     * @override\r\n     */\r\n    _addPropertyToAttributeMap(property) {\r\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\r\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\r\n      }\r\n      // This check is technically not correct; it's an optimization that\r\n      // assumes that if a _property_ name is already in the map (note this is\r\n      // an attr->property map), the property mapped directly to the attribute\r\n      // and it has already been mapped.  This would fail if\r\n      // `attributeNameForProperty` were overridden such that this was not the\r\n      // case.\r\n      let attr = this.__dataAttributes[property];\r\n      if (!attr) {\r\n        attr = this.constructor.attributeNameForProperty(property);\r\n        this.__dataAttributes[attr] = property;\r\n      }\r\n      return attr;\r\n    }\r\n\r\n    /**\r\n     * Defines a property accessor for the given property.\r\n     * @param {string} property Name of the property\r\n     * @param {boolean=} readOnly When true, no setter is created\r\n     * @return {void}\r\n     * @override\r\n     */\r\n     _definePropertyAccessor(property, readOnly) {\r\n      Object.defineProperty(this, property, {\r\n        /* eslint-disable valid-jsdoc */\r\n        /** @this {PropertiesChanged} */\r\n        get() {\r\n          // Inline for perf instead of using `_getProperty`\r\n          return this.__data[property];\r\n        },\r\n        /** @this {PropertiesChanged} */\r\n        set: readOnly ? function () {} : function (value) {\r\n          // Inline for perf instead of using `_setProperty`\r\n          if (this._setPendingProperty(property, value, true)) {\r\n            this._invalidateProperties();\r\n          }\r\n        }\r\n        /* eslint-enable */\r\n      });\r\n    }\r\n\r\n    constructor() {\r\n      super();\r\n      /** @type {boolean} */\r\n      this.__dataEnabled = false;\r\n      this.__dataReady = false;\r\n      this.__dataInvalid = false;\r\n      this.__data = {};\r\n      this.__dataPending = null;\r\n      this.__dataOld = null;\r\n      this.__dataInstanceProps = null;\r\n      /** @type {number} */\r\n      // NOTE: used to track re-entrant calls to `_flushProperties`\r\n      this.__dataCounter = 0;\r\n      this.__serializing = false;\r\n      this._initializeProperties();\r\n    }\r\n\r\n    /**\r\n     * Lifecycle callback called when properties are enabled via\r\n     * `_enableProperties`.\r\n     *\r\n     * Users may override this function to implement behavior that is\r\n     * dependent on the element having its property data initialized, e.g.\r\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\r\n     * `attributeChangedCallback`, or values propagated from host e.g. via\r\n     * bindings.  `super.ready()` must be called to ensure the data system\r\n     * becomes enabled.\r\n     *\r\n     * @return {void}\r\n     * @public\r\n     * @override\r\n     */\r\n    ready() {\r\n      this.__dataReady = true;\r\n      this._flushProperties();\r\n    }\r\n\r\n    /**\r\n     * Initializes the local storage for property accessors.\r\n     *\r\n     * Provided as an override point for performing any setup work prior\r\n     * to initializing the property accessor system.\r\n     *\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _initializeProperties() {\r\n      // Capture instance properties; these will be set into accessors\r\n      // during first flush. Don't set them here, since we want\r\n      // these to overwrite defaults/constructor assignments\r\n      for (let p in this.__dataHasAccessor) {\r\n        if (this.hasOwnProperty(p)) {\r\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\r\n          this.__dataInstanceProps[p] = this[p];\r\n          delete this[p];\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Called at ready time with bag of instance properties that overwrote\r\n     * accessors when the element upgraded.\r\n     *\r\n     * The default implementation sets these properties back into the\r\n     * setter at ready time.  This method is provided as an override\r\n     * point for customizing or providing more efficient initialization.\r\n     *\r\n     * @param {Object} props Bag of property values that were overwritten\r\n     *   when creating property accessors.\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _initializeInstanceProperties(props) {\r\n      Object.assign(this, props);\r\n    }\r\n\r\n    /**\r\n     * Updates the local storage for a property (via `_setPendingProperty`)\r\n     * and enqueues a `_proeprtiesChanged` callback.\r\n     *\r\n     * @param {string} property Name of the property\r\n     * @param {*} value Value to set\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _setProperty(property, value) {\r\n      if (this._setPendingProperty(property, value)) {\r\n        this._invalidateProperties();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns the value for the given property.\r\n     * @param {string} property Name of property\r\n     * @return {*} Value for the given property\r\n     * @protected\r\n     * @override\r\n     */\r\n    _getProperty(property) {\r\n      return this.__data[property];\r\n    }\r\n\r\n    /* eslint-disable no-unused-vars */\r\n    /**\r\n     * Updates the local storage for a property, records the previous value,\r\n     * and adds it to the set of \"pending changes\" that will be passed to the\r\n     * `_propertiesChanged` callback.  This method does not enqueue the\r\n     * `_propertiesChanged` callback.\r\n     *\r\n     * @param {string} property Name of the property\r\n     * @param {*} value Value to set\r\n     * @param {boolean=} ext Not used here; affordance for closure\r\n     * @return {boolean} Returns true if the property changed\r\n     * @protected\r\n     * @override\r\n     */\r\n    _setPendingProperty(property, value, ext) {\r\n      let old = this.__data[property];\r\n      let changed = this._shouldPropertyChange(property, value, old);\r\n      if (changed) {\r\n        if (!this.__dataPending) {\r\n          this.__dataPending = {};\r\n          this.__dataOld = {};\r\n        }\r\n        // Ensure old is captured from the last turn\r\n        if (this.__dataOld && !(property in this.__dataOld)) {\r\n          this.__dataOld[property] = old;\r\n        }\r\n        this.__data[property] = value;\r\n        this.__dataPending[property] = value;\r\n      }\r\n      return changed;\r\n    }\r\n    /* eslint-enable */\r\n\r\n    /**\r\n     * @param {string} property Name of the property\r\n     * @return {boolean} Returns true if the property is pending.\r\n     */\r\n    _isPropertyPending(property) {\r\n      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\r\n    }\r\n\r\n    /**\r\n     * Marks the properties as invalid, and enqueues an async\r\n     * `_propertiesChanged` callback.\r\n     *\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _invalidateProperties() {\r\n      if (!this.__dataInvalid && this.__dataReady) {\r\n        this.__dataInvalid = true;\r\n        microtask.run(() => {\r\n          if (this.__dataInvalid) {\r\n            this.__dataInvalid = false;\r\n            this._flushProperties();\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Call to enable property accessor processing. Before this method is\r\n     * called accessor values will be set but side effects are\r\n     * queued. When called, any pending side effects occur immediately.\r\n     * For elements, generally `connectedCallback` is a normal spot to do so.\r\n     * It is safe to call this method multiple times as it only turns on\r\n     * property accessors once.\r\n     *\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _enableProperties() {\r\n      if (!this.__dataEnabled) {\r\n        this.__dataEnabled = true;\r\n        if (this.__dataInstanceProps) {\r\n          this._initializeInstanceProperties(this.__dataInstanceProps);\r\n          this.__dataInstanceProps = null;\r\n        }\r\n        this.ready();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Calls the `_propertiesChanged` callback with the current set of\r\n     * pending changes (and old values recorded when pending changes were\r\n     * set), and resets the pending set of changes. Generally, this method\r\n     * should not be called in user code.\r\n     *\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _flushProperties() {\r\n      this.__dataCounter++;\r\n      const props = this.__data;\r\n      const changedProps = this.__dataPending;\r\n      const old = this.__dataOld;\r\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\r\n        this.__dataPending = null;\r\n        this.__dataOld = null;\r\n        this._propertiesChanged(props, changedProps, old);\r\n      }\r\n      this.__dataCounter--;\r\n    }\r\n\r\n    /**\r\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\r\n     * should be called. The default implementation returns true if\r\n     * properties are pending. Override to customize when\r\n     * `_propertiesChanged` is called.\r\n     * @param {!Object} currentProps Bag of all current accessor values\r\n     * @param {?Object} changedProps Bag of properties changed since the last\r\n     *   call to `_propertiesChanged`\r\n     * @param {?Object} oldProps Bag of previous values for each property\r\n     *   in `changedProps`\r\n     * @return {boolean} true if changedProps is truthy\r\n     * @override\r\n     */\r\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\r\n      return Boolean(changedProps);\r\n    }\r\n\r\n    /**\r\n     * Callback called when any properties with accessors created via\r\n     * `_createPropertyAccessor` have been set.\r\n     *\r\n     * @param {!Object} currentProps Bag of all current accessor values\r\n     * @param {?Object} changedProps Bag of properties changed since the last\r\n     *   call to `_propertiesChanged`\r\n     * @param {?Object} oldProps Bag of previous values for each property\r\n     *   in `changedProps`\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\r\n    }\r\n\r\n    /**\r\n     * Method called to determine whether a property value should be\r\n     * considered as a change and cause the `_propertiesChanged` callback\r\n     * to be enqueued.\r\n     *\r\n     * The default implementation returns `true` if a strict equality\r\n     * check fails. The method always returns false for `NaN`.\r\n     *\r\n     * Override this method to e.g. provide stricter checking for\r\n     * Objects/Arrays when using immutable patterns.\r\n     *\r\n     * @param {string} property Property name\r\n     * @param {*} value New property value\r\n     * @param {*} old Previous property value\r\n     * @return {boolean} Whether the property should be considered a change\r\n     *   and enqueue a `_proeprtiesChanged` callback\r\n     * @protected\r\n     * @override\r\n     */\r\n    _shouldPropertyChange(property, value, old) {\r\n      return (\r\n        // Strict equality check\r\n        (old !== value &&\r\n          // This ensures (old==NaN, value==NaN) always returns false\r\n          (old === old || value === value))\r\n      );\r\n    }\r\n\r\n    /**\r\n     * Implements native Custom Elements `attributeChangedCallback` to\r\n     * set an attribute value to a property via `_attributeToProperty`.\r\n     *\r\n     * @param {string} name Name of attribute that changed\r\n     * @param {?string} old Old attribute value\r\n     * @param {?string} value New attribute value\r\n     * @param {?string} namespace Attribute namespace.\r\n     * @return {void}\r\n     * @suppress {missingProperties} Super may or may not implement the callback\r\n     * @override\r\n     */\r\n    attributeChangedCallback(name, old, value, namespace) {\r\n      if (old !== value) {\r\n        this._attributeToProperty(name, value);\r\n      }\r\n      if (super.attributeChangedCallback) {\r\n        super.attributeChangedCallback(name, old, value, namespace);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Deserializes an attribute to its associated property.\r\n     *\r\n     * This method calls the `_deserializeValue` method to convert the string to\r\n     * a typed value.\r\n     *\r\n     * @param {string} attribute Name of attribute to deserialize.\r\n     * @param {?string} value of the attribute.\r\n     * @param {*=} type type to deserialize to, defaults to the value\r\n     * returned from `typeForProperty`\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _attributeToProperty(attribute, value, type) {\r\n      if (!this.__serializing) {\r\n        const map = this.__dataAttributes;\r\n        const property = map && map[attribute] || attribute;\r\n        this[property] = this._deserializeValue(value, type ||\r\n          this.constructor.typeForProperty(property));\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Serializes a property to its associated attribute.\r\n     *\r\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\r\n     *\r\n     * @param {string} property Property name to reflect.\r\n     * @param {string=} attribute Attribute name to reflect to.\r\n     * @param {*=} value Property value to refect.\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _propertyToAttribute(property, attribute, value) {\r\n      this.__serializing = true;\r\n      value = (arguments.length < 3) ? this[property] : value;\r\n      this._valueToNodeAttribute(/** @type {!HTMLElement} */(this), value,\r\n        attribute || this.constructor.attributeNameForProperty(property));\r\n      this.__serializing = false;\r\n    }\r\n\r\n    /**\r\n     * Sets a typed value to an HTML attribute on a node.\r\n     *\r\n     * This method calls the `_serializeValue` method to convert the typed\r\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\r\n     * the attribute will be removed (this is the default for boolean\r\n     * type `false`).\r\n     *\r\n     * @param {Element} node Element to set attribute to.\r\n     * @param {*} value Value to serialize.\r\n     * @param {string} attribute Attribute name to serialize to.\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _valueToNodeAttribute(node, value, attribute) {\r\n      const str = this._serializeValue(value);\r\n      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\r\n        node = /** @type {?Element} */(wrap(node));\r\n      }\r\n      if (str === undefined) {\r\n        node.removeAttribute(attribute);\r\n      } else {\r\n        node.setAttribute(\r\n            attribute,\r\n            // Closure's type for `setAttribute`'s second parameter incorrectly\r\n            // excludes `TrustedScript`.\r\n            (str === '' && window.trustedTypes) ?\r\n                /** @type {?} */ (window.trustedTypes.emptyScript) :\r\n                str);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Converts a typed JavaScript value to a string.\r\n     *\r\n     * This method is called when setting JS property values to\r\n     * HTML attributes.  Users may override this method to provide\r\n     * serialization for custom types.\r\n     *\r\n     * @param {*} value Property value to serialize.\r\n     * @return {string | undefined} String serialized from the provided\r\n     * property  value.\r\n     * @override\r\n     */\r\n    _serializeValue(value) {\r\n      switch (typeof value) {\r\n        case 'boolean':\r\n          return value ? '' : undefined;\r\n        default:\r\n          return value != null ? value.toString() : undefined;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Converts a string to a typed JavaScript value.\r\n     *\r\n     * This method is called when reading HTML attribute values to\r\n     * JS properties.  Users may override this method to provide\r\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\r\n     * and `Number` convert attributes to the expected types.\r\n     *\r\n     * @param {?string} value Value to deserialize.\r\n     * @param {*=} type Type to deserialize the string to.\r\n     * @return {*} Typed value deserialized from the provided string.\r\n     * @override\r\n     */\r\n    _deserializeValue(value, type) {\r\n      switch (type) {\r\n        case Boolean:\r\n          return (value !== null);\r\n        case Number:\r\n          return Number(value);\r\n        default:\r\n          return value;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  return PropertiesChanged;\r\n});\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\nimport '../utils/boot.js';\r\n\r\nimport { dedupingMixin } from '../utils/mixin.js';\r\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\r\nimport { PropertiesChanged } from './properties-changed.js';\r\n\r\n// Save map of native properties; this forms a blacklist or properties\r\n// that won't have their values \"saved\" by `saveAccessorValue`, since\r\n// reading from an HTMLElement accessor from the context of a prototype throws\r\nconst nativeProperties = {};\r\nlet proto = HTMLElement.prototype;\r\nwhile (proto) {\r\n  let props = Object.getOwnPropertyNames(proto);\r\n  for (let i=0; i<props.length; i++) {\r\n    nativeProperties[props[i]] = true;\r\n  }\r\n  proto = Object.getPrototypeOf(proto);\r\n}\r\n\r\nconst isTrustedType = (() => {\r\n  if (!window.trustedTypes) {\r\n    return () => false;\r\n  }\r\n  return (val) => trustedTypes.isHTML(val) ||\r\n        trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);\r\n})();\r\n\r\n/**\r\n * Used to save the value of a property that will be overridden with\r\n * an accessor. If the `model` is a prototype, the values will be saved\r\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\r\n * decide how/when to set these values back into the accessors.\r\n * If `model` is already an instance (it has a `__data` property), then\r\n * the value will be set as a pending property, meaning the user should\r\n * call `_invalidateProperties` or `_flushProperties` to take effect\r\n *\r\n * @param {Object} model Prototype or instance\r\n * @param {string} property Name of property\r\n * @return {void}\r\n * @private\r\n */\r\nfunction saveAccessorValue(model, property) {\r\n  // Don't read/store value for any native properties since they could throw\r\n  if (!nativeProperties[property]) {\r\n    let value = model[property];\r\n    if (value !== undefined) {\r\n      if (model.__data) {\r\n        // Adding accessor to instance; update the property\r\n        // It is the user's responsibility to call _flushProperties\r\n        model._setPendingProperty(property, value);\r\n      } else {\r\n        // Adding accessor to proto; save proto's value for instance-time use\r\n        if (!model.__dataProto) {\r\n          model.__dataProto = {};\r\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\r\n          model.__dataProto = Object.create(model.__dataProto);\r\n        }\r\n        model.__dataProto[property] = value;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Element class mixin that provides basic meta-programming for creating one\r\n * or more property accessors (getter/setter pair) that enqueue an async\r\n * (batched) `_propertiesChanged` callback.\r\n *\r\n * For basic usage of this mixin:\r\n *\r\n * -   Declare attributes to observe via the standard `static get\r\n *     observedAttributes()`. Use `dash-case` attribute names to represent\r\n *     `camelCase` property names.\r\n * -   Implement the `_propertiesChanged` callback on the class.\r\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\r\n *     generate property accessors for each observed attribute. This must be\r\n *     called before the first instance is created, for example, by calling it\r\n *     before calling `customElements.define`. It can also be called lazily from\r\n *     the element's `constructor`, as long as it's guarded so that the call is\r\n *     only made once, when the first instance is created.\r\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\r\n *     enable the accessors.\r\n *\r\n * Any `observedAttributes` will automatically be\r\n * deserialized via `attributeChangedCallback` and set to the associated\r\n * property using `dash-case`-to-`camelCase` convention.\r\n *\r\n * @mixinFunction\r\n * @polymer\r\n * @appliesMixin PropertiesChanged\r\n * @summary Element class mixin for reacting to property changes from\r\n *   generated property accessors.\r\n * @template T\r\n * @param {function(new:T)} superClass Class to apply mixin to.\r\n * @return {function(new:T)} superClass with mixin applied.\r\n */\r\nexport const PropertyAccessors = dedupingMixin(superClass => {\r\n\r\n  /**\r\n   * @constructor\r\n   * @implements {Polymer_PropertiesChanged}\r\n   * @unrestricted\r\n   * @private\r\n   */\r\n   const base = PropertiesChanged(superClass);\r\n\r\n  /**\r\n   * @polymer\r\n   * @mixinClass\r\n   * @implements {Polymer_PropertyAccessors}\r\n   * @extends {base}\r\n   * @unrestricted\r\n   */\r\n  class PropertyAccessors extends base {\r\n\r\n    /**\r\n     * Generates property accessors for all attributes in the standard\r\n     * static `observedAttributes` array.\r\n     *\r\n     * Attribute names are mapped to property names using the `dash-case` to\r\n     * `camelCase` convention\r\n     *\r\n     * @return {void}\r\n     * @nocollapse\r\n     */\r\n    static createPropertiesForAttributes() {\r\n      let a$ =  /** @type {?} */ (this).observedAttributes;\r\n      for (let i=0; i < a$.length; i++) {\r\n        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i]));\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns an attribute name that corresponds to the given property.\r\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\r\n     * @param {string} property Property to convert\r\n     * @return {string} Attribute name corresponding to the given property.\r\n     *\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static attributeNameForProperty(property) {\r\n      return camelToDashCase(property);\r\n    }\r\n\r\n    /**\r\n     * Overrides PropertiesChanged implementation to initialize values for\r\n     * accessors created for values that already existed on the element\r\n     * prototype.\r\n     *\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _initializeProperties() {\r\n      if (this.__dataProto) {\r\n        this._initializeProtoProperties(this.__dataProto);\r\n        this.__dataProto = null;\r\n      }\r\n      super._initializeProperties();\r\n    }\r\n\r\n    /**\r\n     * Called at instance time with bag of properties that were overwritten\r\n     * by accessors on the prototype when accessors were created.\r\n     *\r\n     * The default implementation sets these properties back into the\r\n     * setter at instance time.  This method is provided as an override\r\n     * point for customizing or providing more efficient initialization.\r\n     *\r\n     * @param {Object} props Bag of property values that were overwritten\r\n     *   when creating property accessors.\r\n     * @return {void}\r\n     * @protected\r\n     * @override\r\n     */\r\n    _initializeProtoProperties(props) {\r\n      for (let p in props) {\r\n        this._setProperty(p, props[p]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Ensures the element has the given attribute. If it does not,\r\n     * assigns the given value to the attribute.\r\n     *\r\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\r\n     *     element\r\n     *\r\n     * @param {string} attribute Name of attribute to ensure is set.\r\n     * @param {string} value of the attribute.\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _ensureAttribute(attribute, value) {\r\n      const el = /** @type {!HTMLElement} */(this);\r\n      if (!el.hasAttribute(attribute)) {\r\n        this._valueToNodeAttribute(el, value, attribute);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\r\n     *\r\n     * @param {*} value Property value to serialize.\r\n     * @return {string | undefined} String serialized from the provided property\r\n     *     value.\r\n     * @override\r\n     */\r\n    _serializeValue(value) {\r\n      /* eslint-disable no-fallthrough */\r\n      switch (typeof value) {\r\n        case 'object':\r\n          if (value instanceof Date) {\r\n            return value.toString();\r\n          } else if (value) {\r\n            if (isTrustedType(value)) {\r\n              /**\r\n               * Here `value` isn't actually a string, but it should be\r\n               * passed into APIs that normally expect a string, like\r\n               * elem.setAttribute.\r\n               */\r\n              return /** @type {?} */ (value);\r\n            }\r\n            try {\r\n              return JSON.stringify(value);\r\n            } catch(x) {\r\n              return '';\r\n            }\r\n          }\r\n\r\n        default:\r\n          return super._serializeValue(value);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Converts a string to a typed JavaScript value.\r\n     *\r\n     * This method is called by Polymer when reading HTML attribute values to\r\n     * JS properties.  Users may override this method on Polymer element\r\n     * prototypes to provide deserialization for custom `type`s.  Note,\r\n     * the `type` argument is the value of the `type` field provided in the\r\n     * `properties` configuration object for a given property, and is\r\n     * by convention the constructor for the type to deserialize.\r\n     *\r\n     *\r\n     * @param {?string} value Attribute value to deserialize.\r\n     * @param {*=} type Type to deserialize the string to.\r\n     * @return {*} Typed value deserialized from the provided string.\r\n     * @override\r\n     */\r\n    _deserializeValue(value, type) {\r\n      /**\r\n       * @type {*}\r\n       */\r\n      let outValue;\r\n      switch (type) {\r\n        case Object:\r\n          try {\r\n            outValue = JSON.parse(/** @type {string} */(value));\r\n          } catch(x) {\r\n            // allow non-JSON literals like Strings and Numbers\r\n            outValue = value;\r\n          }\r\n          break;\r\n        case Array:\r\n          try {\r\n            outValue = JSON.parse(/** @type {string} */(value));\r\n          } catch(x) {\r\n            outValue = null;\r\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\r\n          }\r\n          break;\r\n        case Date:\r\n          outValue = isNaN(value) ? String(value) : Number(value);\r\n          outValue = new Date(outValue);\r\n          break;\r\n        default:\r\n          outValue = super._deserializeValue(value, type);\r\n          break;\r\n      }\r\n      return outValue;\r\n    }\r\n    /* eslint-enable no-fallthrough */\r\n\r\n    /**\r\n     * Overrides PropertiesChanged implementation to save existing prototype\r\n     * property value so that it can be reset.\r\n     * @param {string} property Name of the property\r\n     * @param {boolean=} readOnly When true, no setter is created\r\n     *\r\n     * When calling on a prototype, any overwritten values are saved in\r\n     * `__dataProto`, and it is up to the subclasser to decide how/when\r\n     * to set those properties back into the accessor.  When calling on an\r\n     * instance, the overwritten value is set via `_setPendingProperty`,\r\n     * and the user should call `_invalidateProperties` or `_flushProperties`\r\n     * for the values to take effect.\r\n     * @protected\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _definePropertyAccessor(property, readOnly) {\r\n      saveAccessorValue(this, property);\r\n      super._definePropertyAccessor(property, readOnly);\r\n    }\r\n\r\n    /**\r\n     * Returns true if this library created an accessor for the given property.\r\n     *\r\n     * @param {string} property Property name\r\n     * @return {boolean} True if an accessor was created\r\n     * @override\r\n     */\r\n    _hasAccessor(property) {\r\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the specified property has a pending change.\r\n     *\r\n     * @param {string} prop Property name\r\n     * @return {boolean} True if property has a pending change\r\n     * @protected\r\n     * @override\r\n     */\r\n    _isPropertyPending(prop) {\r\n      return Boolean(this.__dataPending && (prop in this.__dataPending));\r\n    }\r\n\r\n  }\r\n\r\n  return PropertyAccessors;\r\n\r\n});\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\nimport '../utils/boot.js';\r\n\r\nimport { dedupingMixin } from '../utils/mixin.js';\r\n\r\n// 1.x backwards-compatible auto-wrapper for template type extensions\r\n// This is a clear layering violation and gives favored-nation status to\r\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\r\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\r\n// b.) to maintain if/repeat capability in parser-constrained elements\r\n//     (e.g. table, select) in lieu of native CE type extensions without\r\n//     massive new invention in this space (e.g. directive system)\r\nconst templateExtensions = {\r\n  'dom-if': true,\r\n  'dom-repeat': true\r\n};\r\n\r\nlet placeholderBugDetect = false;\r\nlet placeholderBug = false;\r\n\r\nfunction hasPlaceholderBug() {\r\n  if (!placeholderBugDetect) {\r\n    placeholderBugDetect = true;\r\n    const t = document.createElement('textarea');\r\n    t.placeholder = 'a';\r\n    placeholderBug = t.placeholder === t.textContent;\r\n  }\r\n  return placeholderBug;\r\n}\r\n\r\n/**\r\n * Some browsers have a bug with textarea, where placeholder text is copied as\r\n * a textnode child of the textarea.\r\n *\r\n * If the placeholder is a binding, this can break template stamping in two\r\n * ways.\r\n *\r\n * One issue is that when the `placeholder` attribute is removed when the\r\n * binding is processed, the textnode child of the textarea is deleted, and the\r\n * template info tries to bind into that node.\r\n *\r\n * With `legacyOptimizations` in use, when the template is stamped and the\r\n * `textarea.textContent` binding is processed, no corresponding node is found\r\n * because it was removed during parsing. An exception is generated when this\r\n * binding is updated.\r\n *\r\n * With `legacyOptimizations` not in use, the template is cloned before\r\n * processing and this changes the above behavior. The cloned template also has\r\n * a value property set to the placeholder and textContent. This prevents the\r\n * removal of the textContent when the placeholder attribute is removed.\r\n * Therefore the exception does not occur. However, there is an extra\r\n * unnecessary binding.\r\n *\r\n * @param {!Node} node Check node for placeholder bug\r\n * @return {void}\r\n */\r\nfunction fixPlaceholder(node) {\r\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder\r\n        && node.placeholder === node.textContent) {\r\n    node.textContent = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Copies an attribute from one element to another, converting the value to a\r\n * `TrustedScript` if it is named like a Polymer template event listener.\r\n *\r\n * @param {!Element} dest The element to set the attribute on\r\n * @param {!Element} src The element to read the attribute from\r\n * @param {string} name The name of the attribute\r\n */\r\nconst copyAttributeWithTemplateEventPolicy = (() => {\r\n  /**\r\n   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted\r\n   * Types API where any attribute that starts with `on` may only be set to a\r\n   * `TrustedScript` value, even if that attribute would not cause an event\r\n   * listener to be created. (See https://crbug.com/993268 for details.)\r\n   *\r\n   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be\r\n   * written using the `<template is=\"...\">` syntax, even if there is no UA\r\n   * support for custom element extensions of built-in elements. In doing so, it\r\n   * copies attributes from the original `<template>` to a newly created\r\n   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if\r\n   * any of those attributes uses Polymer's `on-` syntax for event listeners.\r\n   * (Note, the value of these `on-` listeners is not evaluated as script: it is\r\n   * the name of a member function of a component that will be used as the event\r\n   * listener.)\r\n   *\r\n   * @type {!TrustedTypePolicy|undefined}\r\n   */\r\n  const polymerTemplateEventAttributePolicy = window.trustedTypes &&\r\n      window.trustedTypes.createPolicy(\r\n          'polymer-template-event-attribute-policy', {\r\n            createScript: x => x,\r\n          });\r\n\r\n  return (dest, src, name) => {\r\n    const value = src.getAttribute(name);\r\n\r\n    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {\r\n      dest.setAttribute(\r\n          name, polymerTemplateEventAttributePolicy.createScript(value, name));\r\n      return;\r\n    }\r\n\r\n    dest.setAttribute(name, value);\r\n  };\r\n})();\r\n\r\nfunction wrapTemplateExtension(node) {\r\n  let is = node.getAttribute('is');\r\n  if (is && templateExtensions[is]) {\r\n    let t = node;\r\n    t.removeAttribute('is');\r\n    node = t.ownerDocument.createElement(is);\r\n    t.parentNode.replaceChild(node, t);\r\n    node.appendChild(t);\r\n    while(t.attributes.length) {\r\n      const {name} = t.attributes[0];\r\n      copyAttributeWithTemplateEventPolicy(node, t, name);\r\n      t.removeAttribute(name);\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\nfunction findTemplateNode(root, nodeInfo) {\r\n  // recursively ascend tree until we hit root\r\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\r\n  // unwind the stack, returning the indexed node at each level\r\n  if (parent) {\r\n    // note: marginally faster than indexing via childNodes\r\n    // (http://jsperf.com/childnodes-lookup)\r\n    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\r\n      if (nodeInfo.parentIndex === i++) {\r\n        return n;\r\n      }\r\n    }\r\n  } else {\r\n    return root;\r\n  }\r\n}\r\n\r\n// construct `$` map (from id annotations)\r\nfunction applyIdToMap(inst, map, node, nodeInfo) {\r\n  if (nodeInfo.id) {\r\n    map[nodeInfo.id] = node;\r\n  }\r\n}\r\n\r\n// install event listeners (from event annotations)\r\nfunction applyEventListener(inst, node, nodeInfo) {\r\n  if (nodeInfo.events && nodeInfo.events.length) {\r\n    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\r\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\r\n    }\r\n  }\r\n}\r\n\r\n// push configuration references at configure time\r\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\r\n  if (nodeInfo.templateInfo) {\r\n    // Give the node an instance of this templateInfo and set its parent\r\n    node._templateInfo = nodeInfo.templateInfo;\r\n    node._parentTemplateInfo = parentTemplateInfo;\r\n  }\r\n}\r\n\r\nfunction createNodeEventHandler(context, eventName, methodName) {\r\n  // Instances can optionally have a _methodHost which allows redirecting where\r\n  // to find methods. Currently used by `templatize`.\r\n  context = context._methodHost || context;\r\n  let handler = function(e) {\r\n    if (context[methodName]) {\r\n      context[methodName](e, e.detail);\r\n    } else {\r\n      console.warn('listener method `' + methodName + '` not defined');\r\n    }\r\n  };\r\n  return handler;\r\n}\r\n\r\n/**\r\n * Element mixin that provides basic template parsing and stamping, including\r\n * the following template-related features for stamped templates:\r\n *\r\n * - Declarative event listeners (`on-eventname=\"listener\"`)\r\n * - Map of node id's to stamped node instances (`this.$.id`)\r\n * - Nested template content caching/removal and re-installation (performance\r\n *   optimization)\r\n *\r\n * @mixinFunction\r\n * @polymer\r\n * @summary Element class mixin that provides basic template parsing and stamping\r\n */\r\nexport const TemplateStamp = dedupingMixin(\r\n    /**\r\n     * @template T\r\n     * @param {function(new:T)} superClass Class to apply mixin to.\r\n     * @return {function(new:T)} superClass with mixin applied.\r\n     */\r\n    (superClass) => {\r\n\r\n  /**\r\n   * @polymer\r\n   * @mixinClass\r\n   * @implements {Polymer_TemplateStamp}\r\n   */\r\n  class TemplateStamp extends superClass {\r\n\r\n    /**\r\n     * Scans a template to produce template metadata.\r\n     *\r\n     * Template-specific metadata are stored in the object returned, and node-\r\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\r\n     * array.  Only nodes in the template that were parsed as nodes of\r\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\r\n     * contains an `index` (`childNodes` index in parent) and optionally\r\n     * `parent`, which points to node info of its parent (including its index).\r\n     *\r\n     * The template metadata object returned from this method has the following\r\n     * structure (many fields optional):\r\n     *\r\n     * ```js\r\n     *   {\r\n     *     // Flattened list of node metadata (for nodes that generated metadata)\r\n     *     nodeInfoList: [\r\n     *       {\r\n     *         // `id` attribute for any nodes with id's for generating `$` map\r\n     *         id: {string},\r\n     *         // `on-event=\"handler\"` metadata\r\n     *         events: [\r\n     *           {\r\n     *             name: {string},   // event name\r\n     *             value: {string},  // handler method name\r\n     *           }, ...\r\n     *         ],\r\n     *         // Notes when the template contained a `<slot>` for shady DOM\r\n     *         // optimization purposes\r\n     *         hasInsertionPoint: {boolean},\r\n     *         // For nested `<template>`` nodes, nested template metadata\r\n     *         templateInfo: {object}, // nested template metadata\r\n     *         // Metadata to allow efficient retrieval of instanced node\r\n     *         // corresponding to this metadata\r\n     *         parentInfo: {number},   // reference to parent nodeInfo>\r\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\r\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\r\n     *       },\r\n     *       ...\r\n     *     ],\r\n     *     // When true, the template had the `strip-whitespace` attribute\r\n     *     // or was nested in a template with that setting\r\n     *     stripWhitespace: {boolean},\r\n     *     // For nested templates, nested template content is moved into\r\n     *     // a document fragment stored here; this is an optimization to\r\n     *     // avoid the cost of nested template cloning\r\n     *     content: {DocumentFragment}\r\n     *   }\r\n     * ```\r\n     *\r\n     * This method kicks off a recursive treewalk as follows:\r\n     *\r\n     * ```\r\n     *    _parseTemplate <---------------------+\r\n     *      _parseTemplateContent              |\r\n     *        _parseTemplateNode  <------------|--+\r\n     *          _parseTemplateNestedTemplate --+  |\r\n     *          _parseTemplateChildNodes ---------+\r\n     *          _parseTemplateNodeAttributes\r\n     *            _parseTemplateNodeAttribute\r\n     *\r\n     * ```\r\n     *\r\n     * These methods may be overridden to add custom metadata about templates\r\n     * to either `templateInfo` or `nodeInfo`.\r\n     *\r\n     * Note that this method may be destructive to the template, in that\r\n     * e.g. event annotations may be removed after being noted in the\r\n     * template metadata.\r\n     *\r\n     * @param {!HTMLTemplateElement} template Template to parse\r\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\r\n     *   template, for parsing nested templates\r\n     * @return {!TemplateInfo} Parsed template metadata\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplate(template, outerTemplateInfo) {\r\n      // since a template may be re-used, memo-ize metadata\r\n      if (!template._templateInfo) {\r\n        // TODO(rictic): fix typing\r\n        let /** ? */ templateInfo = template._templateInfo = {};\r\n        templateInfo.nodeInfoList = [];\r\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\r\n        templateInfo.stripWhiteSpace =\r\n          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\r\n          (template.hasAttribute && template.hasAttribute('strip-whitespace'));\r\n         // TODO(rictic): fix typing\r\n         this._parseTemplateContent(\r\n             template, templateInfo, /** @type {?} */ ({parent: null}));\r\n      }\r\n      return template._templateInfo;\r\n    }\r\n\r\n    /**\r\n     * See docs for _parseTemplateNode.\r\n     *\r\n     * @param {!HTMLTemplateElement} template .\r\n     * @param {!TemplateInfo} templateInfo .\r\n     * @param {!NodeInfo} nodeInfo .\r\n     * @return {boolean} .\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\r\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\r\n    }\r\n\r\n    /**\r\n     * Parses template node and adds template and node metadata based on\r\n     * the current node, and its `childNodes` and `attributes`.\r\n     *\r\n     * This method may be overridden to add custom node or template specific\r\n     * metadata based on this node.\r\n     *\r\n     * @param {Node} node Node to parse\r\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\r\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\r\n     * @return {boolean} `true` if the visited node added node-specific\r\n     *   metadata to `nodeInfo`\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\r\n      let noted = false;\r\n      let element = /** @type {!HTMLTemplateElement} */ (node);\r\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\r\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\r\n      } else if (element.localName === 'slot') {\r\n        // For ShadyDom optimization, indicating there is an insertion point\r\n        templateInfo.hasInsertionPoint = true;\r\n      }\r\n      fixPlaceholder(element);\r\n      if (element.firstChild) {\r\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\r\n      }\r\n      if (element.hasAttributes && element.hasAttributes()) {\r\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\r\n      }\r\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\r\n      // access to `parentInfo`) to cause the parent to be noted, which\r\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\r\n      // some optimizations)\r\n      return noted || nodeInfo.noted;\r\n    }\r\n\r\n    /**\r\n     * Parses template child nodes for the given root node.\r\n     *\r\n     * This method also wraps whitelisted legacy template extensions\r\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\r\n     * wrappers, collapses text nodes, and strips whitespace from the template\r\n     * if the `templateInfo.stripWhitespace` setting was provided.\r\n     *\r\n     * @param {Node} root Root node whose `childNodes` will be parsed\r\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\r\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\r\n     * @return {void}\r\n     */\r\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\r\n      if (root.localName === 'script' || root.localName === 'style') {\r\n        return;\r\n      }\r\n      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {\r\n        // Wrap templates\r\n        if (node.localName == 'template') {\r\n          node = wrapTemplateExtension(node);\r\n        }\r\n        // collapse adjacent textNodes: fixes an IE issue that can cause\r\n        // text nodes to be inexplicably split =(\r\n        // note that root.normalize() should work but does not so we do this\r\n        // manually.\r\n        next = node.nextSibling;\r\n        if (node.nodeType === Node.TEXT_NODE) {\r\n          let /** Node */ n = next;\r\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\r\n            node.textContent += n.textContent;\r\n            next = n.nextSibling;\r\n            root.removeChild(n);\r\n            n = next;\r\n          }\r\n          // optionally strip whitespace\r\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\r\n            root.removeChild(node);\r\n            continue;\r\n          }\r\n        }\r\n        let childInfo =\r\n            /** @type {!NodeInfo} */ ({parentIndex, parentInfo: nodeInfo});\r\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\r\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\r\n        }\r\n        // Increment if not removed\r\n        if (node.parentNode) {\r\n          parentIndex++;\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Parses template content for the given nested `<template>`.\r\n     *\r\n     * Nested template info is stored as `templateInfo` in the current node's\r\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\r\n     * It will then be the responsibility of the host to set it back to the\r\n     * template and for users stamping nested templates to use the\r\n     * `_contentForTemplate` method to retrieve the content for this template\r\n     * (an optimization to avoid the cost of cloning nested template content).\r\n     *\r\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\r\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\r\n     *   that includes the template `node`\r\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\r\n     * @return {boolean} `true` if the visited node added node-specific\r\n     *   metadata to `nodeInfo`\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\r\n      // TODO(rictic): the type of node should be non-null\r\n      let element = /** @type {!HTMLTemplateElement} */ (node);\r\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\r\n      let content = templateInfo.content =\r\n          element.content.ownerDocument.createDocumentFragment();\r\n      content.appendChild(element.content);\r\n      nodeInfo.templateInfo = templateInfo;\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Parses template node attributes and adds node metadata to `nodeInfo`\r\n     * for nodes of interest.\r\n     *\r\n     * @param {Element} node Node to parse\r\n     * @param {!TemplateInfo} templateInfo Template metadata for current\r\n     *     template\r\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\r\n     * @return {boolean} `true` if the visited node added node-specific\r\n     *   metadata to `nodeInfo`\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\r\n      // Make copy of original attribute list, since the order may change\r\n      // as attributes are added and removed\r\n      let noted = false;\r\n      let attrs = Array.from(node.attributes);\r\n      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\r\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\r\n      }\r\n      return noted;\r\n    }\r\n\r\n    /**\r\n     * Parses a single template node attribute and adds node metadata to\r\n     * `nodeInfo` for attributes of interest.\r\n     *\r\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\r\n     * and `id` attributes.\r\n     *\r\n     * @param {Element} node Node to parse\r\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\r\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\r\n     * @param {string} name Attribute name\r\n     * @param {string} value Attribute value\r\n     * @return {boolean} `true` if the visited node added node-specific\r\n     *   metadata to `nodeInfo`\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\r\n      // events (on-*)\r\n      if (name.slice(0, 3) === 'on-') {\r\n        node.removeAttribute(name);\r\n        nodeInfo.events = nodeInfo.events || [];\r\n        nodeInfo.events.push({\r\n          name: name.slice(3),\r\n          value\r\n        });\r\n        return true;\r\n      }\r\n      // static id\r\n      else if (name === 'id') {\r\n        nodeInfo.id = value;\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the `content` document fragment for a given template.\r\n     *\r\n     * For nested templates, Polymer performs an optimization to cache nested\r\n     * template content to avoid the cost of cloning deeply nested templates.\r\n     * This method retrieves the cached content for a given template.\r\n     *\r\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\r\n     * @return {DocumentFragment} Content fragment\r\n     * @nocollapse\r\n     */\r\n    static _contentForTemplate(template) {\r\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;\r\n      return (templateInfo && templateInfo.content) || template.content;\r\n    }\r\n\r\n    /**\r\n     * Clones the provided template content and returns a document fragment\r\n     * containing the cloned dom.\r\n     *\r\n     * The template is parsed (once and memoized) using this library's\r\n     * template parsing features, and provides the following value-added\r\n     * features:\r\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\r\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\r\n     *   document fragment\r\n     * * Passes template info including `content` back to templates as\r\n     *   `_templateInfo` (a performance optimization to avoid deep template\r\n     *   cloning)\r\n     *\r\n     * Note that the memoized template parsing process is destructive to the\r\n     * template: attributes for bindings and declarative event listeners are\r\n     * removed after being noted in notes, and any nested `<template>.content`\r\n     * is removed and stored in notes as well.\r\n     *\r\n     * @param {!HTMLTemplateElement} template Template to stamp\r\n     * @param {TemplateInfo=} templateInfo Optional template info associated\r\n     *   with the template to be stamped; if omitted the template will be\r\n     *   automatically parsed.\r\n     * @return {!StampedTemplate} Cloned template content\r\n     * @override\r\n     */\r\n    _stampTemplate(template, templateInfo) {\r\n      // Polyfill support: bootstrap the template if it has not already been\r\n      if (template && !template.content &&\r\n          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\r\n        HTMLTemplateElement.decorate(template);\r\n      }\r\n      // Accepting the `templateInfo` via an argument allows for creating\r\n      // instances of the `templateInfo` by the caller, useful for adding\r\n      // instance-time information to the prototypical data\r\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\r\n      let nodeInfo = templateInfo.nodeInfoList;\r\n      let content = templateInfo.content || template.content;\r\n      let dom = /** @type {DocumentFragment} */ (document.importNode(content, true));\r\n      // NOTE: ShadyDom optimization indicating there is an insertion point\r\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\r\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\r\n      dom.$ = {};\r\n      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\r\n        let node = nodes[i] = findTemplateNode(dom, info);\r\n        applyIdToMap(this, dom.$, node, info);\r\n        applyTemplateInfo(this, node, info, templateInfo);\r\n        applyEventListener(this, node, info);\r\n      }\r\n      dom = /** @type {!StampedTemplate} */(dom); // eslint-disable-line no-self-assign\r\n      return dom;\r\n    }\r\n\r\n    /**\r\n     * Adds an event listener by method name for the event provided.\r\n     *\r\n     * This method generates a handler function that looks up the method\r\n     * name at handling time.\r\n     *\r\n     * @param {!EventTarget} node Node to add listener on\r\n     * @param {string} eventName Name of event\r\n     * @param {string} methodName Name of method\r\n     * @param {*=} context Context the method will be called on (defaults\r\n     *   to `node`)\r\n     * @return {Function} Generated handler function\r\n     * @override\r\n     */\r\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\r\n      context = context || node;\r\n      let handler = createNodeEventHandler(context, eventName, methodName);\r\n      this._addEventListenerToNode(node, eventName, handler);\r\n      return handler;\r\n    }\r\n\r\n    /**\r\n     * Override point for adding custom or simulated event handling.\r\n     *\r\n     * @param {!EventTarget} node Node to add event listener to\r\n     * @param {string} eventName Name of event\r\n     * @param {function(!Event):void} handler Listener function to add\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _addEventListenerToNode(node, eventName, handler) {\r\n      node.addEventListener(eventName, handler);\r\n    }\r\n\r\n    /**\r\n     * Override point for adding custom or simulated event handling.\r\n     *\r\n     * @param {!EventTarget} node Node to remove event listener from\r\n     * @param {string} eventName Name of event\r\n     * @param {function(!Event):void} handler Listener function to remove\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _removeEventListenerFromNode(node, eventName, handler) {\r\n      node.removeEventListener(eventName, handler);\r\n    }\r\n\r\n  }\r\n\r\n  return TemplateStamp;\r\n\r\n});\r\n", "/**\r\n * @fileoverview\r\n * @suppress {checkPrototypalTypes}\r\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\r\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\r\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\r\n * Google as part of the polymer project is also subject to an additional IP\r\n * rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\nimport '../utils/boot.js';\r\nimport { wrap } from '../utils/wrap.js';\r\nimport { dedupingMixin } from '../utils/mixin.js';\r\nimport { root, isAncestor, isDescendant, get, translate, isPath, set, normalize } from '../utils/path.js';\r\n/* for notify, reflect */\r\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\r\nimport { PropertyAccessors } from './property-accessors.js';\r\n/* for annotated effects */\r\nimport { TemplateStamp } from './template-stamp.js';\r\nimport { sanitizeDOMValue, legacyUndefined, orderedComputed, removeNestedTemplates, fastDomIf } from '../utils/settings.js';\r\n\r\n// Monotonically increasing unique ID used for de-duping effects triggered\r\n// from multiple properties in the same turn\r\nlet dedupeId = 0;\r\n\r\nconst NOOP = [];\r\n\r\n/**\r\n * Property effect types; effects are stored on the prototype using these keys\r\n * @enum {string}\r\n */\r\nconst TYPES = {\r\n  COMPUTE: '__computeEffects',\r\n  REFLECT: '__reflectEffects',\r\n  NOTIFY: '__notifyEffects',\r\n  PROPAGATE: '__propagateEffects',\r\n  OBSERVE: '__observeEffects',\r\n  READ_ONLY: '__readOnly'\r\n};\r\n\r\nconst COMPUTE_INFO = '__computeInfo';\r\n\r\n/** @const {!RegExp} */\r\nconst capitalAttributeRegex = /[A-Z]/;\r\n\r\n/**\r\n * @typedef {{\r\n * name: (string | undefined),\r\n * structured: (boolean | undefined),\r\n * wildcard: (boolean | undefined)\r\n * }}\r\n */\r\nlet DataTrigger; //eslint-disable-line no-unused-vars\r\n\r\n/**\r\n * @typedef {{\r\n * info: ?,\r\n * trigger: (!DataTrigger | undefined),\r\n * fn: (!Function | undefined)\r\n * }}\r\n */\r\nlet DataEffect; //eslint-disable-line no-unused-vars\r\n\r\n/**\r\n * Ensures that the model has an own-property map of effects for the given type.\r\n * The model may be a prototype or an instance.\r\n *\r\n * Property effects are stored as arrays of effects by property in a map,\r\n * by named type on the model. e.g.\r\n *\r\n *   __computeEffects: {\r\n *     foo: [ ... ],\r\n *     bar: [ ... ]\r\n *   }\r\n *\r\n * If the model does not yet have an effect map for the type, one is created\r\n * and returned.  If it does, but it is not an own property (i.e. the\r\n * prototype had effects), the the map is deeply cloned and the copy is\r\n * set on the model and returned, ready for new effects to be added.\r\n *\r\n * @param {Object} model Prototype or instance\r\n * @param {string} type Property effect type\r\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\r\n *   extending a superclass map onto this subclass\r\n * @return {Object} The own-property map of effects for the given type\r\n * @private\r\n */\r\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\r\n  let effects = model[type];\r\n  if (!effects) {\r\n    effects = model[type] = {};\r\n  } else if (!model.hasOwnProperty(type)) {\r\n    effects = model[type] = Object.create(model[type]);\r\n    if (cloneArrays) {\r\n      for (let p in effects) {\r\n        let protoFx = effects[p];\r\n        // Perf optimization over Array.slice\r\n        let instFx = effects[p] = Array(protoFx.length);\r\n        for (let i=0; i<protoFx.length; i++) {\r\n          instFx[i] = protoFx[i];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return effects;\r\n}\r\n\r\n// -- effects ----------------------------------------------\r\n\r\n/**\r\n * Runs all effects of a given type for the given set of property changes\r\n * on an instance.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\r\n * @param {?Object} effects Object map of property-to-Array of effects\r\n * @param {?Object} props Bag of current property changes\r\n * @param {?Object=} oldProps Bag of previous values for changed properties\r\n * @param {boolean=} hasPaths True with `props` contains one or more paths\r\n * @param {*=} extraArgs Additional metadata to pass to effect function\r\n * @return {boolean} True if an effect ran for this property\r\n * @private\r\n */\r\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\r\n  if (effects) {\r\n    let ran = false;\r\n    const id = dedupeId++;\r\n    for (let prop in props) {\r\n      // Inline `runEffectsForProperty` for perf.\r\n      let rootProperty = hasPaths ? root(prop) : prop;\r\n      let fxs = effects[rootProperty];\r\n      if (fxs) {\r\n        for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\r\n          if ((!fx.info || fx.info.lastRun !== id) &&\r\n              (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\r\n            if (fx.info) {\r\n              fx.info.lastRun = id;\r\n            }\r\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\r\n            ran = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return ran;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Runs a list of effects for a given property.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\r\n * @param {!Object} effects Object map of property-to-Array of effects\r\n * @param {number} dedupeId Counter used for de-duping effects\r\n * @param {string} prop Name of changed property\r\n * @param {*} props Changed properties\r\n * @param {*} oldProps Old properties\r\n * @param {boolean=} hasPaths True with `props` contains one or more paths\r\n * @param {*=} extraArgs Additional metadata to pass to effect function\r\n * @return {boolean} True if an effect ran for this property\r\n * @private\r\n */\r\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\r\n  let ran = false;\r\n  let rootProperty = hasPaths ? root(prop) : prop;\r\n  let fxs = effects[rootProperty];\r\n  if (fxs) {\r\n    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\r\n      if ((!fx.info || fx.info.lastRun !== dedupeId) &&\r\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\r\n        if (fx.info) {\r\n          fx.info.lastRun = dedupeId;\r\n        }\r\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\r\n        ran = true;\r\n      }\r\n    }\r\n  }\r\n  return ran;\r\n}\r\n\r\n/**\r\n * Determines whether a property/path that has changed matches the trigger\r\n * criteria for an effect.  A trigger is a descriptor with the following\r\n * structure, which matches the descriptors returned from `parseArg`.\r\n * e.g. for `foo.bar.*`:\r\n * ```\r\n * trigger: {\r\n *   name: 'a.b',\r\n *   structured: true,\r\n *   wildcard: true\r\n * }\r\n * ```\r\n * If no trigger is given, the path is deemed to match.\r\n *\r\n * @param {string} path Path or property that changed\r\n * @param {?DataTrigger} trigger Descriptor\r\n * @return {boolean} Whether the path matched the trigger\r\n */\r\nfunction pathMatchesTrigger(path, trigger) {\r\n  if (trigger) {\r\n    let triggerPath = /** @type {string} */ (trigger.name);\r\n    return (triggerPath == path) ||\r\n        !!(trigger.structured && isAncestor(triggerPath, path)) ||\r\n        !!(trigger.wildcard && isDescendant(triggerPath, path));\r\n  } else {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Implements the \"observer\" effect.\r\n *\r\n * Calls the method with `info.methodName` on the instance, passing the\r\n * new and old values.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\r\n * @param {string} property Name of property\r\n * @param {Object} props Bag of current property changes\r\n * @param {Object} oldProps Bag of previous values for changed properties\r\n * @param {?} info Effect metadata\r\n * @return {void}\r\n * @private\r\n */\r\nfunction runObserverEffect(inst, property, props, oldProps, info) {\r\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\r\n  let changedProp = info.property;\r\n  if (fn) {\r\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\r\n  } else if (!info.dynamicFn) {\r\n    console.warn('observer method `' + info.method + '` not defined');\r\n  }\r\n}\r\n\r\n/**\r\n * Runs \"notify\" effects for a set of changed properties.\r\n *\r\n * This method differs from the generic `runEffects` method in that it\r\n * will dispatch path notification events in the case that the property\r\n * changed was a path and the root property for that path didn't have a\r\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\r\n * `notify: true` to ensure object sub-property notifications were\r\n * sent.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\r\n * @param {Object} notifyProps Bag of properties to notify\r\n * @param {Object} props Bag of current property changes\r\n * @param {Object} oldProps Bag of previous values for changed properties\r\n * @param {boolean} hasPaths True with `props` contains one or more paths\r\n * @return {void}\r\n * @private\r\n */\r\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\r\n  // Notify\r\n  let fxs = inst[TYPES.NOTIFY];\r\n  let notified;\r\n  let id = dedupeId++;\r\n  // Try normal notify effects; if none, fall back to try path notification\r\n  for (let prop in notifyProps) {\r\n    if (notifyProps[prop]) {\r\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\r\n        notified = true;\r\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\r\n        notified = true;\r\n      }\r\n    }\r\n  }\r\n  // Flush host if we actually notified and host was batching\r\n  // And the host has already initialized clients; this prevents\r\n  // an issue with a host observing data changes before clients are ready.\r\n  let host;\r\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\r\n    host._invalidateProperties();\r\n  }\r\n}\r\n\r\n/**\r\n * Dispatches {property}-changed events with path information in the detail\r\n * object to indicate a sub-path of the property was changed.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\r\n *     event\r\n * @param {string} path The path that was changed\r\n * @param {Object} props Bag of current property changes\r\n * @return {boolean} Returns true if the path was notified\r\n * @private\r\n */\r\nfunction notifyPath(inst, path, props) {\r\n  let rootProperty = root(path);\r\n  if (rootProperty !== path) {\r\n    let eventName = camelToDashCase(rootProperty) + '-changed';\r\n    dispatchNotifyEvent(inst, eventName, props[path], path);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Dispatches {property}-changed events to indicate a property (or path)\r\n * changed.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\r\n *     event\r\n * @param {string} eventName The name of the event to send\r\n *     ('{property}-changed')\r\n * @param {*} value The value of the changed property\r\n * @param {string | null | undefined} path If a sub-path of this property\r\n *     changed, the path that changed (optional).\r\n * @return {void}\r\n * @private\r\n * @suppress {invalidCasts}\r\n */\r\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\r\n  let detail = {\r\n    value: value,\r\n    queueProperty: true\r\n  };\r\n  if (path) {\r\n    detail.path = path;\r\n  }\r\n  // As a performance optimization, we could elide the wrap here since notifying\r\n  // events are non-bubbling and shouldn't need retargeting. However, a very\r\n  // small number of internal tests failed in obscure ways, which may indicate\r\n  // user code relied on timing differences resulting from ShadyDOM flushing\r\n  // as a result of the wrapped `dispatchEvent`.\r\n  wrap(/** @type {!HTMLElement} */(inst)).dispatchEvent(new CustomEvent(eventName, { detail }));\r\n}\r\n\r\n/**\r\n * Implements the \"notify\" effect.\r\n *\r\n * Dispatches a non-bubbling event named `info.eventName` on the instance\r\n * with a detail object containing the new `value`.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\r\n * @param {string} property Name of property\r\n * @param {Object} props Bag of current property changes\r\n * @param {Object} oldProps Bag of previous values for changed properties\r\n * @param {?} info Effect metadata\r\n * @param {boolean} hasPaths True with `props` contains one or more paths\r\n * @return {void}\r\n * @private\r\n */\r\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\r\n  let rootProperty = hasPaths ? root(property) : property;\r\n  let path = rootProperty != property ? property : null;\r\n  let value = path ? get(inst, path) : inst.__data[property];\r\n  if (path && value === undefined) {\r\n    value = props[property];  // specifically for .splices\r\n  }\r\n  dispatchNotifyEvent(inst, info.eventName, value, path);\r\n}\r\n\r\n/**\r\n * Handler function for 2-way notification events. Receives context\r\n * information captured in the `addNotifyListener` closure from the\r\n * `__notifyListeners` metadata.\r\n *\r\n * Sets the value of the notified property to the host property or path.  If\r\n * the event contained path information, translate that path to the host\r\n * scope's name for that path first.\r\n *\r\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\r\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\r\n *     notification event\r\n * @param {string} fromProp Child element property that was bound\r\n * @param {string} toPath Host property/path that was bound\r\n * @param {boolean} negate Whether the binding was negated\r\n * @return {void}\r\n * @private\r\n */\r\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\r\n  let value;\r\n  let detail = /** @type {Object} */(event.detail);\r\n  let fromPath = detail && detail.path;\r\n  if (fromPath) {\r\n    toPath = translate(fromProp, toPath, fromPath);\r\n    value = detail && detail.value;\r\n  } else {\r\n    value = event.currentTarget[fromProp];\r\n  }\r\n  value = negate ? !value : value;\r\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\r\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))\r\n      && (!detail || !detail.queueProperty)) {\r\n      inst._invalidateProperties();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Implements the \"reflect\" effect.\r\n *\r\n * Sets the attribute named `info.attrName` to the given property value.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\r\n * @param {string} property Name of property\r\n * @param {Object} props Bag of current property changes\r\n * @param {Object} oldProps Bag of previous values for changed properties\r\n * @param {?} info Effect metadata\r\n * @return {void}\r\n * @private\r\n */\r\nfunction runReflectEffect(inst, property, props, oldProps, info) {\r\n  let value = inst.__data[property];\r\n  if (sanitizeDOMValue) {\r\n    value = sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */(inst));\r\n  }\r\n  inst._propertyToAttribute(property, info.attrName, value);\r\n}\r\n\r\n/**\r\n * Runs \"computed\" effects for a set of changed properties.\r\n *\r\n * This method differs from the generic `runEffects` method in that it\r\n * continues to run computed effects based on the output of each pass until\r\n * there are no more newly computed properties.  This ensures that all\r\n * properties that will be computed by the initial set of changes are\r\n * computed before other effects (binding propagation, observers, and notify)\r\n * run.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\r\n * @param {?Object} changedProps Bag of changed properties\r\n * @param {?Object} oldProps Bag of previous values for changed properties\r\n * @param {boolean} hasPaths True with `props` contains one or more paths\r\n * @return {void}\r\n * @private\r\n */\r\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\r\n  let computeEffects = inst[TYPES.COMPUTE];\r\n  if (computeEffects) {\r\n    if (orderedComputed) {\r\n      // Runs computed effects in efficient order by keeping a topologically-\r\n      // sorted queue of compute effects to run, and inserting subsequently\r\n      // invalidated effects as they are run\r\n      dedupeId++;\r\n      const order = getComputedOrder(inst);\r\n      const queue = [];\r\n      for (let p in changedProps) {\r\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\r\n      }\r\n      let info;\r\n      while ((info = queue.shift())) {\r\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\r\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\r\n        }\r\n      }\r\n      Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\r\n      Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\r\n      inst.__dataPending = null;\r\n    } else {\r\n      // Original Polymer 2.x computed effects order, which continues running\r\n      // effects until no further computed properties have been invalidated\r\n      let inputProps = changedProps;\r\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\r\n        Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\r\n        Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\r\n        inputProps = inst.__dataPending;\r\n        inst.__dataPending = null;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Inserts a computed effect into a queue, given the specified order. Performs\r\n * the insert using a binary search.\r\n *\r\n * Used by `orderedComputed: true` computed property algorithm.\r\n *\r\n * @param {Object} info Property effects metadata\r\n * @param {Array<Object>} queue Ordered queue of effects\r\n * @param {Map<string,number>} order Map of computed property name->topological\r\n *   sort order\r\n */\r\nconst insertEffect = (info, queue, order) => {\r\n  let start = 0;\r\n  let end = queue.length - 1;\r\n  let idx = -1;\r\n  while (start <= end) {\r\n    const mid = (start + end) >> 1;\r\n    // Note `methodInfo` is where the computed property name is stored in\r\n    // the effect metadata\r\n    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\r\n    if (cmp < 0) {\r\n      start = mid + 1;\r\n    } else if (cmp > 0) {\r\n      end = mid - 1;\r\n    } else {\r\n      idx = mid;\r\n      break;\r\n    }\r\n  }\r\n  if (idx < 0) {\r\n    idx = end + 1;\r\n  }\r\n  queue.splice(idx, 0, info);\r\n};\r\n\r\n/**\r\n * Inserts all downstream computed effects invalidated by the specified property\r\n * into the topologically-sorted queue of effects to be run.\r\n *\r\n * Used by `orderedComputed: true` computed property algorithm.\r\n *\r\n * @param {string} prop Property name\r\n * @param {Object} computeEffects Computed effects for this element\r\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\r\n *   to be run\r\n * @param {Map<string,number>} order Map of computed property name->topological\r\n *   sort order\r\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\r\n */\r\nconst enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {\r\n  const rootProperty = hasPaths ? root(prop) : prop;\r\n  const fxs = computeEffects[rootProperty];\r\n  if (fxs) {\r\n    for (let i=0; i<fxs.length; i++) {\r\n      const fx = fxs[i];\r\n      if ((fx.info.lastRun !== dedupeId) &&\r\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\r\n        fx.info.lastRun = dedupeId;\r\n        insertEffect(fx.info, queue, order);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Generates and retrieves a memoized map of computed property name to its\r\n * topologically-sorted order.\r\n *\r\n * The map is generated by first assigning a \"dependency count\" to each property\r\n * (defined as number properties it depends on, including its method for\r\n * \"dynamic functions\"). Any properties that have no dependencies are added to\r\n * the `ready` queue, which are properties whose order can be added to the final\r\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\r\n * the next property in the order map, and b.) each property that it is a\r\n * dependency for has its dep count decremented (and if that property's dep\r\n * count goes to zero, it is added to the `ready` queue), until all properties\r\n * have been visited and ordered.\r\n *\r\n * Used by `orderedComputed: true` computed property algorithm.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\r\n *   effect order for.\r\n * @return {Map<string,number>} Map of computed property name->topological sort\r\n *   order\r\n */\r\nfunction getComputedOrder(inst) {\r\n  let ordered = inst.constructor.__orderedComputedDeps;\r\n  if (!ordered) {\r\n    ordered = new Map();\r\n    const effects = inst[TYPES.COMPUTE];\r\n    let {counts, ready, total} = dependencyCounts(inst);\r\n    let curr;\r\n    while ((curr = ready.shift())) {\r\n      ordered.set(curr, ordered.size);\r\n      const computedByCurr = effects[curr];\r\n      if (computedByCurr) {\r\n        computedByCurr.forEach(fx => {\r\n          // Note `methodInfo` is where the computed property name is stored\r\n          const computedProp = fx.info.methodInfo;\r\n          --total;\r\n          if (--counts[computedProp] === 0) {\r\n            ready.push(computedProp);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    if (total !== 0) {\r\n      const el = /** @type {HTMLElement} */ (inst);\r\n      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);\r\n    }\r\n    inst.constructor.__orderedComputedDeps = ordered;\r\n  }\r\n  return ordered;\r\n}\r\n\r\n/**\r\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\r\n * count\" is the number of dependencies a given property has assuming it is a\r\n * computed property, otherwise 0).  It also returns a pre-populated list of\r\n * `ready` properties that have no dependencies and a `total` count, which is\r\n * used for error-checking the graph.\r\n *\r\n * Used by `orderedComputed: true` computed property algorithm.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\r\n *   counts for.\r\n * @return {!Object} Object containing `counts` map (property-to-dependency\r\n *   count) and pre-populated `ready` array of properties that had zero\r\n *   dependencies.\r\n */\r\nfunction dependencyCounts(inst) {\r\n  const infoForComputed = inst[COMPUTE_INFO];\r\n  const counts = {};\r\n  const computedDeps = inst[TYPES.COMPUTE];\r\n  const ready = [];\r\n  let total = 0;\r\n  // Count dependencies for each computed property\r\n  for (let p in infoForComputed) {\r\n    const info = infoForComputed[p];\r\n    // Be sure to add the method name itself in case of \"dynamic functions\"\r\n    total += counts[p] =\r\n      info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);\r\n  }\r\n  // Build list of ready properties (that aren't themselves computed)\r\n  for (let p in computedDeps) {\r\n    if (!infoForComputed[p]) {\r\n      ready.push(p);\r\n    }\r\n  }\r\n  return {counts, ready, total};\r\n}\r\n\r\n/**\r\n * Implements the \"computed property\" effect by running the method with the\r\n * values of the arguments specified in the `info` object and setting the\r\n * return value to the computed property specified.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\r\n * @param {string} property Name of property\r\n * @param {?Object} changedProps Bag of current property changes\r\n * @param {?Object} oldProps Bag of previous values for changed properties\r\n * @param {?} info Effect metadata\r\n * @return {boolean} True when the property being computed changed\r\n * @private\r\n */\r\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\r\n  // Dirty check dependencies and run if any invalid\r\n  let result = runMethodEffect(inst, property, changedProps, oldProps, info);\r\n  // Abort if method returns a no-op result\r\n  if (result === NOOP) {\r\n    return false;\r\n  }\r\n  let computedProp = info.methodInfo;\r\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\r\n    return inst._setPendingProperty(computedProp, result, true);\r\n  } else {\r\n    inst[computedProp] = result;\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Computes path changes based on path links set up using the `linkPaths`\r\n * API.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\r\n * @param {string} path Path that has changed\r\n * @param {*} value Value of changed path\r\n * @return {void}\r\n * @private\r\n */\r\nfunction computeLinkedPaths(inst, path, value) {\r\n  let links = inst.__dataLinkedPaths;\r\n  if (links) {\r\n    let link;\r\n    for (let a in links) {\r\n      let b = links[a];\r\n      if (isDescendant(a, path)) {\r\n        link = translate(a, b, path);\r\n        inst._setPendingPropertyOrPath(link, value, true, true);\r\n      } else if (isDescendant(b, path)) {\r\n        link = translate(b, a, path);\r\n        inst._setPendingPropertyOrPath(link, value, true, true);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// -- bindings ----------------------------------------------\r\n\r\n/**\r\n * Adds binding metadata to the current `nodeInfo`, and binding effects\r\n * for all part dependencies to `templateInfo`.\r\n *\r\n * @param {Function} constructor Class that `_parseTemplate` is currently\r\n *   running on\r\n * @param {TemplateInfo} templateInfo Template metadata for current template\r\n * @param {NodeInfo} nodeInfo Node metadata for current template node\r\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\r\n * @param {string} target Target property name\r\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\r\n * @param {string=} literal Literal text surrounding binding parts (specified\r\n *   only for 'property' bindings, since these must be initialized as part\r\n *   of boot-up)\r\n * @return {void}\r\n * @private\r\n */\r\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\r\n  // Create binding metadata and add to nodeInfo\r\n  nodeInfo.bindings = nodeInfo.bindings || [];\r\n  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };\r\n  nodeInfo.bindings.push(binding);\r\n  // Add listener info to binding metadata\r\n  if (shouldAddListener(binding)) {\r\n    let {event, negate} = binding.parts[0];\r\n    binding.listenerEvent = event || (camelToDashCase(target) + '-changed');\r\n    binding.listenerNegate = negate;\r\n  }\r\n  // Add \"propagate\" property effects to templateInfo\r\n  let index = templateInfo.nodeInfoList.length;\r\n  for (let i=0; i<binding.parts.length; i++) {\r\n    let part = binding.parts[i];\r\n    part.compoundIndex = i;\r\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\r\n  }\r\n}\r\n\r\n/**\r\n * Adds property effects to the given `templateInfo` for the given binding\r\n * part.\r\n *\r\n * @param {Function} constructor Class that `_parseTemplate` is currently\r\n *   running on\r\n * @param {TemplateInfo} templateInfo Template metadata for current template\r\n * @param {!Binding} binding Binding metadata\r\n * @param {!BindingPart} part Binding part metadata\r\n * @param {number} index Index into `nodeInfoList` for this node\r\n * @return {void}\r\n */\r\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\r\n  if (!part.literal) {\r\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\r\n      console.warn('Cannot set attribute ' + binding.target +\r\n        ' because \"-\" is not a valid attribute starting character');\r\n    } else {\r\n      let dependencies = part.dependencies;\r\n      let info = { index, binding, part, evaluator: constructor };\r\n      for (let j=0; j<dependencies.length; j++) {\r\n        let trigger = dependencies[j];\r\n        if (typeof trigger == 'string') {\r\n          trigger = parseArg(trigger);\r\n          trigger.wildcard = true;\r\n        }\r\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\r\n          fn: runBindingEffect,\r\n          info, trigger\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Implements the \"binding\" (property/path binding) effect.\r\n *\r\n * Note that binding syntax is overridable via `_parseBindings` and\r\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\r\n * non-literal parts returned from `_parseBindings`.  However,\r\n * there is no support for _path_ bindings via custom binding parts,\r\n * as this is specific to Polymer's path binding syntax.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\r\n * @param {string} path Name of property\r\n * @param {Object} props Bag of current property changes\r\n * @param {Object} oldProps Bag of previous values for changed properties\r\n * @param {?} info Effect metadata\r\n * @param {boolean} hasPaths True with `props` contains one or more paths\r\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\r\n *   metadata\r\n * @return {void}\r\n * @private\r\n */\r\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\r\n  let node = nodeList[info.index];\r\n  let binding = info.binding;\r\n  let part = info.part;\r\n  // Subpath notification: transform path and set to client\r\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\r\n  if (hasPaths && part.source && (path.length > part.source.length) &&\r\n      (binding.kind == 'property') && !binding.isCompound &&\r\n      node.__isPropertyEffectsClient &&\r\n      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\r\n    let value = props[path];\r\n    path = translate(part.source, binding.target, path);\r\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\r\n      inst._enqueueClient(node);\r\n    }\r\n  } else {\r\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\r\n    // Propagate value to child\r\n    // Abort if value is a no-op result\r\n    if (value !== NOOP) {\r\n      applyBindingValue(inst, node, binding, part, value);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Sets the value for an \"binding\" (binding) effect to a node,\r\n * either as a property or attribute.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\r\n * @param {Node} node Target node for binding\r\n * @param {!Binding} binding Binding metadata\r\n * @param {!BindingPart} part Binding part metadata\r\n * @param {*} value Value to set\r\n * @return {void}\r\n * @private\r\n */\r\nfunction applyBindingValue(inst, node, binding, part, value) {\r\n  value = computeBindingValue(node, value, binding, part);\r\n  if (sanitizeDOMValue) {\r\n    value = sanitizeDOMValue(value, binding.target, binding.kind, node);\r\n  }\r\n  if (binding.kind == 'attribute') {\r\n    // Attribute binding\r\n    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);\r\n  } else {\r\n    // Property binding\r\n    let prop = binding.target;\r\n    if (node.__isPropertyEffectsClient &&\r\n        node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\r\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\r\n        if (node._setPendingProperty(prop, value)) {\r\n          inst._enqueueClient(node);\r\n        }\r\n      }\r\n    } else {\r\n      // In legacy no-batching mode, bindings applied before dataReady are\r\n      // equivalent to the \"apply config\" phase, which only set managed props\r\n      inst._setUnmanagedPropertyToNode(node, prop, value);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Transforms an \"binding\" effect value based on compound & negation\r\n * effect metadata, as well as handling for special-case properties\r\n *\r\n * @param {Node} node Node the value will be set to\r\n * @param {*} value Value to set\r\n * @param {!Binding} binding Binding metadata\r\n * @param {!BindingPart} part Binding part metadata\r\n * @return {*} Transformed value to set\r\n * @private\r\n */\r\nfunction computeBindingValue(node, value, binding, part) {\r\n  if (binding.isCompound) {\r\n    let storage = node.__dataCompoundStorage[binding.target];\r\n    storage[part.compoundIndex] = value;\r\n    value = storage.join('');\r\n  }\r\n  if (binding.kind !== 'attribute') {\r\n    // Some browsers serialize `undefined` to `\"undefined\"`\r\n    if (binding.target === 'textContent' ||\r\n        (binding.target === 'value' &&\r\n          (node.localName === 'input' || node.localName === 'textarea'))) {\r\n      value = value == undefined ? '' : value;\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Returns true if a binding's metadata meets all the requirements to allow\r\n * 2-way binding, and therefore a `<property>-changed` event listener should be\r\n * added:\r\n * - used curly braces\r\n * - is a property (not attribute) binding\r\n * - is not a textContent binding\r\n * - is not compound\r\n *\r\n * @param {!Binding} binding Binding metadata\r\n * @return {boolean} True if 2-way listener should be added\r\n * @private\r\n */\r\nfunction shouldAddListener(binding) {\r\n  return Boolean(binding.target) &&\r\n         binding.kind != 'attribute' &&\r\n         binding.kind != 'text' &&\r\n         !binding.isCompound &&\r\n         binding.parts[0].mode === '{';\r\n}\r\n\r\n/**\r\n * Setup compound binding storage structures, notify listeners, and dataHost\r\n * references onto the bound nodeList.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\r\n *     bound\r\n * @param {TemplateInfo} templateInfo Template metadata\r\n * @return {void}\r\n * @private\r\n */\r\nfunction setupBindings(inst, templateInfo) {\r\n  // Setup compound storage, dataHost, and notify listeners\r\n  let {nodeList, nodeInfoList} = templateInfo;\r\n  if (nodeInfoList.length) {\r\n    for (let i=0; i < nodeInfoList.length; i++) {\r\n      let info = nodeInfoList[i];\r\n      let node = nodeList[i];\r\n      let bindings = info.bindings;\r\n      if (bindings) {\r\n        for (let i=0; i<bindings.length; i++) {\r\n          let binding = bindings[i];\r\n          setupCompoundStorage(node, binding);\r\n          addNotifyListener(node, inst, binding);\r\n        }\r\n      }\r\n      // This ensures all bound elements have a host set, regardless\r\n      // of whether they upgrade synchronous to creation\r\n      node.__dataHost = inst;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes `__dataCompoundStorage` local storage on a bound node with\r\n * initial literal data for compound bindings, and sets the joined\r\n * literal parts to the bound property.\r\n *\r\n * When changes to compound parts occur, they are first set into the compound\r\n * storage array for that property, and then the array is joined to result in\r\n * the final value set to the property/attribute.\r\n *\r\n * @param {Node} node Bound node to initialize\r\n * @param {Binding} binding Binding metadata\r\n * @return {void}\r\n * @private\r\n */\r\nfunction setupCompoundStorage(node, binding) {\r\n  if (binding.isCompound) {\r\n    // Create compound storage map\r\n    let storage = node.__dataCompoundStorage ||\r\n      (node.__dataCompoundStorage = {});\r\n    let parts = binding.parts;\r\n    // Copy literals from parts into storage for this binding\r\n    let literals = new Array(parts.length);\r\n    for (let j=0; j<parts.length; j++) {\r\n      literals[j] = parts[j].literal;\r\n    }\r\n    let target = binding.target;\r\n    storage[target] = literals;\r\n    // Configure properties with their literal parts\r\n    if (binding.literal && binding.kind == 'property') {\r\n      // Note, className needs style scoping so this needs wrapping.\r\n      // We may also want to consider doing this for `textContent` and\r\n      // `innerHTML`.\r\n      if (target === 'className') {\r\n        node = wrap(node);\r\n      }\r\n      node[target] = binding.literal;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Adds a 2-way binding notification event listener to the node specified\r\n *\r\n * @param {Object} node Child element to add listener to\r\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\r\n *     notification event\r\n * @param {Binding} binding Binding metadata\r\n * @return {void}\r\n * @private\r\n */\r\nfunction addNotifyListener(node, inst, binding) {\r\n  if (binding.listenerEvent) {\r\n    let part = binding.parts[0];\r\n    node.addEventListener(binding.listenerEvent, function(e) {\r\n      handleNotification(e, inst, binding.target, part.source, part.negate);\r\n    });\r\n  }\r\n}\r\n\r\n// -- for method-based effects (complexObserver & computed) --------------\r\n\r\n/**\r\n * Adds property effects for each argument in the method signature (and\r\n * optionally, for the method name if `dynamic` is true) that calls the\r\n * provided effect function.\r\n *\r\n * @param {Element | Object} model Prototype or instance\r\n * @param {!MethodSignature} sig Method signature metadata\r\n * @param {string} type Type of property effect to add\r\n * @param {Function} effectFn Function to run when arguments change\r\n * @param {*=} methodInfo Effect-specific information to be included in\r\n *   method effect metadata\r\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\r\n *   method names should be included as a dependency to the effect. Note,\r\n *   defaults to true if the signature is static (sig.static is true).\r\n * @return {!Object} Effect metadata for this method effect\r\n * @private\r\n */\r\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\r\n  dynamicFn = sig.static || (dynamicFn &&\r\n    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));\r\n  let info = {\r\n    methodName: sig.methodName,\r\n    args: sig.args,\r\n    methodInfo,\r\n    dynamicFn\r\n  };\r\n  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\r\n    if (!arg.literal) {\r\n      model._addPropertyEffect(arg.rootProperty, type, {\r\n        fn: effectFn, info: info, trigger: arg\r\n      });\r\n    }\r\n  }\r\n  if (dynamicFn) {\r\n    model._addPropertyEffect(sig.methodName, type, {\r\n      fn: effectFn, info: info\r\n    });\r\n  }\r\n  return info;\r\n}\r\n\r\n/**\r\n * Calls a method with arguments marshaled from properties on the instance\r\n * based on the method signature contained in the effect metadata.\r\n *\r\n * Multi-property observers, computed properties, and inline computing\r\n * functions call this function to invoke the method, then use the return\r\n * value accordingly.\r\n *\r\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\r\n * @param {string} property Name of property\r\n * @param {Object} props Bag of current property changes\r\n * @param {Object} oldProps Bag of previous values for changed properties\r\n * @param {?} info Effect metadata\r\n * @return {*} Returns the return value from the method invocation\r\n * @private\r\n */\r\nfunction runMethodEffect(inst, property, props, oldProps, info) {\r\n  // Instances can optionally have a _methodHost which allows redirecting where\r\n  // to find methods. Currently used by `templatize`.\r\n  let context = inst._methodHost || inst;\r\n  let fn = context[info.methodName];\r\n  if (fn) {\r\n    let args = inst._marshalArgs(info.args, property, props);\r\n    return args === NOOP ? NOOP : fn.apply(context, args);\r\n  } else if (!info.dynamicFn) {\r\n    console.warn('method `' + info.methodName + '` not defined');\r\n  }\r\n}\r\n\r\nconst emptyArray = [];\r\n\r\n// Regular expressions used for binding\r\nconst IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\r\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\r\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\r\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\r\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\r\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\\\s*' + ')';\r\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\r\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\r\n                              '(?:' + ARGUMENTS + '?' + ')' +\r\n                            '\\\\)\\\\s*' + ')';\r\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\r\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\r\nconst CLOSE_BRACKET = '(?:]]|}})';\r\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\r\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\r\nconst bindingRegex = new RegExp(EXPRESSION, \"g\");\r\n\r\n/**\r\n * Create a string from binding parts of all the literal parts\r\n *\r\n * @param {!Array<BindingPart>} parts All parts to stringify\r\n * @return {string} String made from the literal parts\r\n */\r\nfunction literalFromParts(parts) {\r\n  let s = '';\r\n  for (let i=0; i<parts.length; i++) {\r\n    let literal = parts[i].literal;\r\n    s += literal || '';\r\n  }\r\n  return s;\r\n}\r\n\r\n/**\r\n * Parses an expression string for a method signature, and returns a metadata\r\n * describing the method in terms of `methodName`, `static` (whether all the\r\n * arguments are literals), and an array of `args`\r\n *\r\n * @param {string} expression The expression to parse\r\n * @return {?MethodSignature} The method metadata object if a method expression was\r\n *   found, otherwise `undefined`\r\n * @private\r\n */\r\nfunction parseMethod(expression) {\r\n  // tries to match valid javascript property names\r\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\r\n  if (m) {\r\n    let methodName = m[1];\r\n    let sig = { methodName, static: true, args: emptyArray };\r\n    if (m[2].trim()) {\r\n      // replace escaped commas with comma entity, split on un-escaped commas\r\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\r\n      return parseArgs(args, sig);\r\n    } else {\r\n      return sig;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Parses an array of arguments and sets the `args` property of the supplied\r\n * signature metadata object. Sets the `static` property to false if any\r\n * argument is a non-literal.\r\n *\r\n * @param {!Array<string>} argList Array of argument names\r\n * @param {!MethodSignature} sig Method signature metadata object\r\n * @return {!MethodSignature} The updated signature metadata object\r\n * @private\r\n */\r\nfunction parseArgs(argList, sig) {\r\n  sig.args = argList.map(function(rawArg) {\r\n    let arg = parseArg(rawArg);\r\n    if (!arg.literal) {\r\n      sig.static = false;\r\n    }\r\n    return arg;\r\n  }, this);\r\n  return sig;\r\n}\r\n\r\n/**\r\n * Parses an individual argument, and returns an argument metadata object\r\n * with the following fields:\r\n *\r\n *   {\r\n *     value: 'prop',        // property/path or literal value\r\n *     literal: false,       // whether argument is a literal\r\n *     structured: false,    // whether the property is a path\r\n *     rootProperty: 'prop', // the root property of the path\r\n *     wildcard: false       // whether the argument was a wildcard '.*' path\r\n *   }\r\n *\r\n * @param {string} rawArg The string value of the argument\r\n * @return {!MethodArg} Argument metadata object\r\n * @private\r\n */\r\nfunction parseArg(rawArg) {\r\n  // clean up whitespace\r\n  let arg = rawArg.trim()\r\n    // replace comma entity with comma\r\n    .replace(/&comma;/g, ',')\r\n    // repair extra escape sequences; note only commas strictly need\r\n    // escaping, but we allow any other char to be escaped since its\r\n    // likely users will do this\r\n    .replace(/\\\\(.)/g, '$1')\r\n    ;\r\n  // basic argument descriptor\r\n  let a = {\r\n    name: arg,\r\n    value: '',\r\n    literal: false\r\n  };\r\n  // detect literal value (must be String or Number)\r\n  let fc = arg[0];\r\n  if (fc === '-') {\r\n    fc = arg[1];\r\n  }\r\n  if (fc >= '0' && fc <= '9') {\r\n    fc = '#';\r\n  }\r\n  switch(fc) {\r\n    case \"'\":\r\n    case '\"':\r\n      a.value = arg.slice(1, -1);\r\n      a.literal = true;\r\n      break;\r\n    case '#':\r\n      a.value = Number(arg);\r\n      a.literal = true;\r\n      break;\r\n  }\r\n  // if not literal, look for structured path\r\n  if (!a.literal) {\r\n    a.rootProperty = root(arg);\r\n    // detect structured path (has dots)\r\n    a.structured = isPath(arg);\r\n    if (a.structured) {\r\n      a.wildcard = (arg.slice(-2) == '.*');\r\n      if (a.wildcard) {\r\n        a.name = arg.slice(0, -2);\r\n      }\r\n    }\r\n  }\r\n  return a;\r\n}\r\n\r\nfunction getArgValue(data, props, path) {\r\n  let value = get(data, path);\r\n  // when data is not stored e.g. `splices`, get the value from changedProps\r\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\r\n  // info.value could pull a stale value out of changedProps during a reentrant\r\n  // change that sets the value back to undefined.\r\n  // https://github.com/Polymer/polymer/issues/5479\r\n  if (value === undefined) {\r\n    value = props[path];\r\n  }\r\n  return value;\r\n}\r\n\r\n// data api\r\n\r\n/**\r\n * Sends array splice notifications (`.splices` and `.length`)\r\n *\r\n * Note: this implementation only accepts normalized paths\r\n *\r\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\r\n * @param {Array} array The array the mutations occurred on\r\n * @param {string} path The path to the array that was mutated\r\n * @param {Array} splices Array of splice records\r\n * @return {void}\r\n * @private\r\n */\r\nfunction notifySplices(inst, array, path, splices) {\r\n  const splicesData = { indexSplices: splices };\r\n  // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\r\n  // To match this behavior, we store splices directly on the array.\r\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\r\n    array.splices = splicesData;\r\n  }\r\n  inst.notifyPath(path + '.splices', splicesData);\r\n  inst.notifyPath(path + '.length', array.length);\r\n  // Clear splice data only when it's stored on the array.\r\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\r\n    splicesData.indexSplices = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a splice record and sends an array splice notification for\r\n * the described mutation\r\n *\r\n * Note: this implementation only accepts normalized paths\r\n *\r\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\r\n * @param {Array} array The array the mutations occurred on\r\n * @param {string} path The path to the array that was mutated\r\n * @param {number} index Index at which the array mutation occurred\r\n * @param {number} addedCount Number of added items\r\n * @param {Array} removed Array of removed items\r\n * @return {void}\r\n * @private\r\n */\r\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\r\n  notifySplices(inst, array, path, [{\r\n    index: index,\r\n    addedCount: addedCount,\r\n    removed: removed,\r\n    object: array,\r\n    type: 'splice'\r\n  }]);\r\n}\r\n\r\n/**\r\n * Returns an upper-cased version of the string.\r\n *\r\n * @param {string} name String to uppercase\r\n * @return {string} Uppercased string\r\n * @private\r\n */\r\nfunction upper(name) {\r\n  return name[0].toUpperCase() + name.substring(1);\r\n}\r\n\r\n/**\r\n * Element class mixin that provides meta-programming for Polymer's template\r\n * binding and data observation (collectively, \"property effects\") system.\r\n *\r\n * This mixin uses provides the following key static methods for adding\r\n * property effects to an element class:\r\n * - `addPropertyEffect`\r\n * - `createPropertyObserver`\r\n * - `createMethodObserver`\r\n * - `createNotifyingProperty`\r\n * - `createReadOnlyProperty`\r\n * - `createReflectedProperty`\r\n * - `createComputedProperty`\r\n * - `bindTemplate`\r\n *\r\n * Each method creates one or more property accessors, along with metadata\r\n * used by this mixin's implementation of `_propertiesChanged` to perform\r\n * the property effects.\r\n *\r\n * Underscored versions of the above methods also exist on the element\r\n * prototype for adding property effects on instances at runtime.\r\n *\r\n * Note that this mixin overrides several `PropertyAccessors` methods, in\r\n * many cases to maintain guarantees provided by the Polymer 1.x features;\r\n * notably it changes property accessors to be synchronous by default\r\n * whereas the default when using `PropertyAccessors` standalone is to be\r\n * async by default.\r\n *\r\n * @mixinFunction\r\n * @polymer\r\n * @appliesMixin TemplateStamp\r\n * @appliesMixin PropertyAccessors\r\n * @summary Element class mixin that provides meta-programming for Polymer's\r\n * template binding and data observation system.\r\n */\r\nexport const PropertyEffects = dedupingMixin(superClass => {\r\n\r\n  /**\r\n   * @constructor\r\n   * @implements {Polymer_PropertyAccessors}\r\n   * @implements {Polymer_TemplateStamp}\r\n   * @unrestricted\r\n   * @private\r\n   */\r\n  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));\r\n\r\n  /**\r\n   * @polymer\r\n   * @mixinClass\r\n   * @implements {Polymer_PropertyEffects}\r\n   * @extends {propertyEffectsBase}\r\n   * @unrestricted\r\n   */\r\n  class PropertyEffects extends propertyEffectsBase {\r\n\r\n    constructor() {\r\n      super();\r\n      /** @type {boolean} */\r\n      // Used to identify users of this mixin, ala instanceof\r\n      this.__isPropertyEffectsClient = true;\r\n      /** @type {boolean} */\r\n      this.__dataClientsReady;\r\n      /** @type {Array} */\r\n      this.__dataPendingClients;\r\n      /** @type {Object} */\r\n      this.__dataToNotify;\r\n      /** @type {Object} */\r\n      this.__dataLinkedPaths;\r\n      /** @type {boolean} */\r\n      this.__dataHasPaths;\r\n      /** @type {Object} */\r\n      this.__dataCompoundStorage;\r\n      /** @type {Polymer_PropertyEffects} */\r\n      this.__dataHost;\r\n      /** @type {!Object} */\r\n      this.__dataTemp;\r\n      /** @type {boolean} */\r\n      this.__dataClientsInitialized;\r\n      /** @type {!Object} */\r\n      this.__data;\r\n      /** @type {!Object|null} */\r\n      this.__dataPending;\r\n      /** @type {!Object} */\r\n      this.__dataOld;\r\n      /** @type {Object} */\r\n      this.__computeEffects;\r\n      /** @type {Object} */\r\n      this.__computeInfo;\r\n      /** @type {Object} */\r\n      this.__reflectEffects;\r\n      /** @type {Object} */\r\n      this.__notifyEffects;\r\n      /** @type {Object} */\r\n      this.__propagateEffects;\r\n      /** @type {Object} */\r\n      this.__observeEffects;\r\n      /** @type {Object} */\r\n      this.__readOnly;\r\n      /** @type {!TemplateInfo} */\r\n      this.__templateInfo;\r\n      /** @type {boolean} */\r\n      this._overrideLegacyUndefined;\r\n    }\r\n\r\n    get PROPERTY_EFFECT_TYPES() {\r\n      return TYPES;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     * @return {void}\r\n     */\r\n    _initializeProperties() {\r\n      super._initializeProperties();\r\n      this._registerHost();\r\n      this.__dataClientsReady = false;\r\n      this.__dataPendingClients = null;\r\n      this.__dataToNotify = null;\r\n      this.__dataLinkedPaths = null;\r\n      this.__dataHasPaths = false;\r\n      // May be set on instance prior to upgrade\r\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\r\n      this.__dataHost = this.__dataHost || null;\r\n      this.__dataTemp = {};\r\n      this.__dataClientsInitialized = false;\r\n    }\r\n\r\n    _registerHost() {\r\n      if (hostStack.length) {\r\n        let host = hostStack[hostStack.length-1];\r\n        host._enqueueClient(this);\r\n        // This ensures even non-bound elements have a host set, as\r\n        // long as they upgrade synchronously\r\n        this.__dataHost = host;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Overrides `PropertyAccessors` implementation to provide a\r\n     * more efficient implementation of initializing properties from\r\n     * the prototype on the instance.\r\n     *\r\n     * @override\r\n     * @param {Object} props Properties to initialize on the prototype\r\n     * @return {void}\r\n     */\r\n    _initializeProtoProperties(props) {\r\n      this.__data = Object.create(props);\r\n      this.__dataPending = Object.create(props);\r\n      this.__dataOld = {};\r\n    }\r\n\r\n    /**\r\n     * Overrides `PropertyAccessors` implementation to avoid setting\r\n     * `_setProperty`'s `shouldNotify: true`.\r\n     *\r\n     * @override\r\n     * @param {Object} props Properties to initialize on the instance\r\n     * @return {void}\r\n     */\r\n    _initializeInstanceProperties(props) {\r\n      let readOnly = this[TYPES.READ_ONLY];\r\n      for (let prop in props) {\r\n        if (!readOnly || !readOnly[prop]) {\r\n          this.__dataPending = this.__dataPending || {};\r\n          this.__dataOld = this.__dataOld || {};\r\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\r\n        }\r\n      }\r\n    }\r\n\r\n    // Prototype setup ----------------------------------------\r\n\r\n    /**\r\n     * Equivalent to static `addPropertyEffect` API but can be called on\r\n     * an instance to add effects at runtime.  See that method for\r\n     * full API docs.\r\n     *\r\n     * @override\r\n     * @param {string} property Property that should trigger the effect\r\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\r\n     * @param {Object=} effect Effect metadata object\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _addPropertyEffect(property, type, effect) {\r\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\r\n      // effects are accumulated into arrays per property based on type\r\n      let effects = ensureOwnEffectMap(this, type, true)[property];\r\n      if (!effects) {\r\n        effects = this[type][property] = [];\r\n      }\r\n      effects.push(effect);\r\n    }\r\n\r\n    /**\r\n     * Removes the given property effect.\r\n     *\r\n     * @override\r\n     * @param {string} property Property the effect was associated with\r\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\r\n     * @param {Object=} effect Effect metadata object to remove\r\n     * @return {void}\r\n     */\r\n    _removePropertyEffect(property, type, effect) {\r\n      let effects = ensureOwnEffectMap(this, type, true)[property];\r\n      let idx = effects.indexOf(effect);\r\n      if (idx >= 0) {\r\n        effects.splice(idx, 1);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns whether the current prototype/instance has a property effect\r\n     * of a certain type.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\r\n     * @return {boolean} True if the prototype/instance has an effect of this\r\n     *     type\r\n     * @protected\r\n     */\r\n    _hasPropertyEffect(property, type) {\r\n      let effects = this[type];\r\n      return Boolean(effects && effects[property]);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the current prototype/instance has a \"read only\"\r\n     * accessor for the given property.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @return {boolean} True if the prototype/instance has an effect of this\r\n     *     type\r\n     * @protected\r\n     */\r\n    _hasReadOnlyEffect(property) {\r\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the current prototype/instance has a \"notify\"\r\n     * property effect for the given property.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @return {boolean} True if the prototype/instance has an effect of this\r\n     *     type\r\n     * @protected\r\n     */\r\n    _hasNotifyEffect(property) {\r\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the current prototype/instance has a \"reflect to\r\n     * attribute\" property effect for the given property.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @return {boolean} True if the prototype/instance has an effect of this\r\n     *     type\r\n     * @protected\r\n     */\r\n    _hasReflectEffect(property) {\r\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the current prototype/instance has a \"computed\"\r\n     * property effect for the given property.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @return {boolean} True if the prototype/instance has an effect of this\r\n     *     type\r\n     * @protected\r\n     */\r\n    _hasComputedEffect(property) {\r\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\r\n    }\r\n\r\n    // Runtime ----------------------------------------\r\n\r\n    /**\r\n     * Sets a pending property or path.  If the root property of the path in\r\n     * question had no accessor, the path is set, otherwise it is enqueued\r\n     * via `_setPendingProperty`.\r\n     *\r\n     * This function isolates relatively expensive functionality necessary\r\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\r\n     * change listeners via {{...}} bindings), such that it is only done\r\n     * when paths enter the system, and not at every propagation step.  It\r\n     * also sets a `__dataHasPaths` flag on the instance which is used to\r\n     * fast-path slower path-matching code in the property effects host paths.\r\n     *\r\n     * `path` can be a path string or array of path parts as accepted by the\r\n     * public API.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<number|string>} path Path to set\r\n     * @param {*} value Value to set\r\n     * @param {boolean=} shouldNotify Set to true if this change should\r\n     *  cause a property notification event dispatch\r\n     * @param {boolean=} isPathNotification If the path being set is a path\r\n     *   notification of an already changed value, as opposed to a request\r\n     *   to set and notify the change.  In the latter `false` case, a dirty\r\n     *   check is performed and then the value is set to the path before\r\n     *   enqueuing the pending property change.\r\n     * @return {boolean} Returns true if the property/path was enqueued in\r\n     *   the pending changes bag.\r\n     * @protected\r\n     */\r\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\r\n      if (isPathNotification ||\r\n          root(Array.isArray(path) ? path[0] : path) !== path) {\r\n        // Dirty check changes being set to a path against the actual object,\r\n        // since this is the entry point for paths into the system; from here\r\n        // the only dirty checks are against the `__dataTemp` cache to prevent\r\n        // duplicate work in the same turn only. Note, if this was a notification\r\n        // of a change already set to a path (isPathNotification: true),\r\n        // we always let the change through and skip the `set` since it was\r\n        // already dirty checked at the point of entry and the underlying\r\n        // object has already been updated\r\n        if (!isPathNotification) {\r\n          let old = get(this, path);\r\n          path = /** @type {string} */ (set(this, path, value));\r\n          // Use property-accessor's simpler dirty check\r\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\r\n            return false;\r\n          }\r\n        }\r\n        this.__dataHasPaths = true;\r\n        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {\r\n          computeLinkedPaths(this, /**@type{string}*/ (path), value);\r\n          return true;\r\n        }\r\n      } else {\r\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\r\n          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);\r\n        } else {\r\n          this[path] = value;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Applies a value to a non-Polymer element/node's property.\r\n     *\r\n     * The implementation makes a best-effort at binding interop:\r\n     * Some native element properties have side-effects when\r\n     * re-setting the same value (e.g. setting `<input>.value` resets the\r\n     * cursor position), so we do a dirty-check before setting the value.\r\n     * However, for better interop with non-Polymer custom elements that\r\n     * accept objects, we explicitly re-set object changes coming from the\r\n     * Polymer world (which may include deep object changes without the\r\n     * top reference changing), erring on the side of providing more\r\n     * information.\r\n     *\r\n     * Users may override this method to provide alternate approaches.\r\n     *\r\n     * @override\r\n     * @param {!Node} node The node to set a property on\r\n     * @param {string} prop The property to set\r\n     * @param {*} value The value to set\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _setUnmanagedPropertyToNode(node, prop, value) {\r\n      // It is a judgment call that resetting primitives is\r\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\r\n      // implement a whitelist of tag & property values that should never\r\n      // be reset (e.g. <input>.value && <select>.value)\r\n      if (value !== node[prop] || typeof value == 'object') {\r\n        // Note, className needs style scoping so this needs wrapping.\r\n        if (prop === 'className') {\r\n          node = /** @type {!Node} */(wrap(node));\r\n        }\r\n        node[prop] = value;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Overrides the `PropertiesChanged` implementation to introduce special\r\n     * dirty check logic depending on the property & value being set:\r\n     *\r\n     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\r\n     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\r\n     * 2. Object set to simple property (e.g. 'prop': {...})\r\n     *    Stored in `__dataTemp` and `__data`, dirty checked against\r\n     *    `__dataTemp` by default implementation of `_shouldPropertyChange`\r\n     * 3. Primitive value set to simple property (e.g. 'prop': 42)\r\n     *    Stored in `__data`, dirty checked against `__data`\r\n     *\r\n     * The dirty-check is important to prevent cycles due to two-way\r\n     * notification, but paths and objects are only dirty checked against any\r\n     * previous value set during this turn via a \"temporary cache\" that is\r\n     * cleared when the last `_propertiesChanged` exits. This is so:\r\n     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\r\n     *    due to array mutations like shift/unshift/splice; this is fine\r\n     *    since path changes are dirty-checked at user entry points like `set`\r\n     * b. dirty-checking for objects only lasts one turn to allow the user\r\n     *    to mutate the object in-place and re-set it with the same identity\r\n     *    and have all sub-properties re-propagated in a subsequent turn.\r\n     *\r\n     * The temp cache is not necessarily sufficient to prevent invalid array\r\n     * paths, since a splice can happen during the same turn (with pathological\r\n     * user code); we could introduce a \"fixup\" for temporarily cached array\r\n     * paths if needed: https://github.com/Polymer/polymer/issues/4227\r\n     *\r\n     * @override\r\n     * @param {string} property Name of the property\r\n     * @param {*} value Value to set\r\n     * @param {boolean=} shouldNotify True if property should fire notification\r\n     *   event (applies only for `notify: true` properties)\r\n     * @return {boolean} Returns true if the property changed\r\n     */\r\n    _setPendingProperty(property, value, shouldNotify) {\r\n      let propIsPath = this.__dataHasPaths && isPath(property);\r\n      let prevProps = propIsPath ? this.__dataTemp : this.__data;\r\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\r\n        if (!this.__dataPending) {\r\n          this.__dataPending = {};\r\n          this.__dataOld = {};\r\n        }\r\n        // Ensure old is captured from the last turn\r\n        if (!(property in this.__dataOld)) {\r\n          this.__dataOld[property] = this.__data[property];\r\n        }\r\n        // Paths are stored in temporary cache (cleared at end of turn),\r\n        // which is used for dirty-checking, all others stored in __data\r\n        if (propIsPath) {\r\n          this.__dataTemp[property] = value;\r\n        } else {\r\n          this.__data[property] = value;\r\n        }\r\n        // All changes go into pending property bag, passed to _propertiesChanged\r\n        this.__dataPending[property] = value;\r\n        // Track properties that should notify separately\r\n        if (propIsPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {\r\n          this.__dataToNotify = this.__dataToNotify || {};\r\n          this.__dataToNotify[property] = shouldNotify;\r\n        }\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Overrides base implementation to ensure all accessors set `shouldNotify`\r\n     * to true, for per-property notification tracking.\r\n     *\r\n     * @override\r\n     * @param {string} property Name of the property\r\n     * @param {*} value Value to set\r\n     * @return {void}\r\n     */\r\n    _setProperty(property, value) {\r\n      if (this._setPendingProperty(property, value, true)) {\r\n        this._invalidateProperties();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Overrides `PropertyAccessor`'s default async queuing of\r\n     * `_propertiesChanged`: if `__dataReady` is false (has not yet been\r\n     * manually flushed), the function no-ops; otherwise flushes\r\n     * `_propertiesChanged` synchronously.\r\n     *\r\n     * @override\r\n     * @return {void}\r\n     */\r\n    _invalidateProperties() {\r\n      if (this.__dataReady) {\r\n        this._flushProperties();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Enqueues the given client on a list of pending clients, whose\r\n     * pending property changes can later be flushed via a call to\r\n     * `_flushClients`.\r\n     *\r\n     * @override\r\n     * @param {Object} client PropertyEffects client to enqueue\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _enqueueClient(client) {\r\n      this.__dataPendingClients = this.__dataPendingClients || [];\r\n      if (client !== this) {\r\n        this.__dataPendingClients.push(client);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Flushes any clients previously enqueued via `_enqueueClient`, causing\r\n     * their `_flushProperties` method to run.\r\n     *\r\n     * @override\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _flushClients() {\r\n      if (!this.__dataClientsReady) {\r\n        this.__dataClientsReady = true;\r\n        this._readyClients();\r\n        // Override point where accessors are turned on; importantly,\r\n        // this is after clients have fully readied, providing a guarantee\r\n        // that any property effects occur only after all clients are ready.\r\n        this.__dataReady = true;\r\n      } else {\r\n        this.__enableOrFlushClients();\r\n      }\r\n    }\r\n\r\n    // NOTE: We ensure clients either enable or flush as appropriate. This\r\n    // handles two corner cases:\r\n    // (1) clients flush properly when connected/enabled before the host\r\n    // enables; e.g.\r\n    //   (a) Templatize stamps with no properties and does not flush and\r\n    //   (b) the instance is inserted into dom and\r\n    //   (c) then the instance flushes.\r\n    // (2) clients enable properly when not connected/enabled when the host\r\n    // flushes; e.g.\r\n    //   (a) a template is runtime stamped and not yet connected/enabled\r\n    //   (b) a host sets a property, causing stamped dom to flush\r\n    //   (c) the stamped dom enables.\r\n    __enableOrFlushClients() {\r\n      let clients = this.__dataPendingClients;\r\n      if (clients) {\r\n        this.__dataPendingClients = null;\r\n        for (let i=0; i < clients.length; i++) {\r\n          let client = clients[i];\r\n          if (!client.__dataEnabled) {\r\n            client._enableProperties();\r\n          } else if (client.__dataPending) {\r\n            client._flushProperties();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Perform any initial setup on client dom. Called before the first\r\n     * `_flushProperties` call on client dom and before any element\r\n     * observers are called.\r\n     *\r\n     * @override\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _readyClients() {\r\n      this.__enableOrFlushClients();\r\n    }\r\n\r\n    /**\r\n     * Sets a bag of property changes to this instance, and\r\n     * synchronously processes all effects of the properties as a batch.\r\n     *\r\n     * Property names must be simple properties, not paths.  Batched\r\n     * path propagation is not supported.\r\n     *\r\n     * @override\r\n     * @param {Object} props Bag of one or more key-value pairs whose key is\r\n     *   a property and value is the new value to set for that property.\r\n     * @param {boolean=} setReadOnly When true, any private values set in\r\n     *   `props` will be set. By default, `setProperties` will not set\r\n     *   `readOnly: true` root properties.\r\n     * @return {void}\r\n     * @public\r\n     */\r\n    setProperties(props, setReadOnly) {\r\n      for (let path in props) {\r\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\r\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\r\n          // wildcard observers currently only pass the first changed path\r\n          // in the `info` object, and you could do some odd things batching\r\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\r\n          this._setPendingPropertyOrPath(path, props[path], true);\r\n        }\r\n      }\r\n      this._invalidateProperties();\r\n    }\r\n\r\n    /**\r\n     * Overrides `PropertyAccessors` so that property accessor\r\n     * side effects are not enabled until after client dom is fully ready.\r\n     * Also calls `_flushClients` callback to ensure client dom is enabled\r\n     * that was not enabled as a result of flushing properties.\r\n     *\r\n     * @override\r\n     * @return {void}\r\n     */\r\n    ready() {\r\n      // It is important that `super.ready()` is not called here as it\r\n      // immediately turns on accessors. Instead, we wait until `readyClients`\r\n      // to enable accessors to provide a guarantee that clients are ready\r\n      // before processing any accessors side effects.\r\n      this._flushProperties();\r\n      // If no data was pending, `_flushProperties` will not `flushClients`\r\n      // so ensure this is done.\r\n      if (!this.__dataClientsReady) {\r\n        this._flushClients();\r\n      }\r\n      // Before ready, client notifications do not trigger _flushProperties.\r\n      // Therefore a flush is necessary here if data has been set.\r\n      if (this.__dataPending) {\r\n        this._flushProperties();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Implements `PropertyAccessors`'s properties changed callback.\r\n     *\r\n     * Runs each class of effects for the batch of changed properties in\r\n     * a specific order (compute, propagate, reflect, observe, notify).\r\n     *\r\n     * @override\r\n     * @param {!Object} currentProps Bag of all current accessor values\r\n     * @param {?Object} changedProps Bag of properties changed since the last\r\n     *   call to `_propertiesChanged`\r\n     * @param {?Object} oldProps Bag of previous values for each property\r\n     *   in `changedProps`\r\n     * @return {void}\r\n     */\r\n    _propertiesChanged(currentProps, changedProps, oldProps) {\r\n      // ----------------------------\r\n      // let c = Object.getOwnPropertyNames(changedProps || {});\r\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\r\n      // if (window.debug) { debugger; }\r\n      // ----------------------------\r\n      let hasPaths = this.__dataHasPaths;\r\n      this.__dataHasPaths = false;\r\n      let notifyProps;\r\n      // Compute properties\r\n      runComputedEffects(this, changedProps, oldProps, hasPaths);\r\n      // Clear notify properties prior to possible reentry (propagate, observe),\r\n      // but after computing effects have a chance to add to them\r\n      notifyProps = this.__dataToNotify;\r\n      this.__dataToNotify = null;\r\n      // Propagate properties to clients\r\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\r\n      // Flush clients\r\n      this._flushClients();\r\n      // Reflect properties\r\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\r\n      // Observe properties\r\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\r\n      // Notify properties to host\r\n      if (notifyProps) {\r\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\r\n      }\r\n      // Clear temporary cache at end of turn\r\n      if (this.__dataCounter == 1) {\r\n        this.__dataTemp = {};\r\n      }\r\n      // ----------------------------\r\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\r\n      // ----------------------------\r\n    }\r\n\r\n    /**\r\n     * Called to propagate any property changes to stamped template nodes\r\n     * managed by this element.\r\n     *\r\n     * @override\r\n     * @param {Object} changedProps Bag of changed properties\r\n     * @param {Object} oldProps Bag of previous values for changed properties\r\n     * @param {boolean} hasPaths True with `props` contains one or more paths\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\r\n      if (this[TYPES.PROPAGATE]) {\r\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\r\n      }\r\n      if (this.__templateInfo) {\r\n        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\r\n      }\r\n    }\r\n\r\n    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\r\n      const baseRunEffects = (changedProps, hasPaths) => {\r\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,\r\n          hasPaths, templateInfo.nodeList);\r\n        for (let info=templateInfo.firstChild; info; info=info.nextSibling) {\r\n          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\r\n        }\r\n      };\r\n      if (templateInfo.runEffects) {\r\n        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\r\n      } else {\r\n        baseRunEffects(changedProps, hasPaths);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Aliases one data path as another, such that path notifications from one\r\n     * are routed to the other.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<string|number>} to Target path to link.\r\n     * @param {string | !Array<string|number>} from Source path to link.\r\n     * @return {void}\r\n     * @public\r\n     */\r\n    linkPaths(to, from) {\r\n      to = normalize(to);\r\n      from = normalize(from);\r\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\r\n      this.__dataLinkedPaths[to] = from;\r\n    }\r\n\r\n    /**\r\n     * Removes a data path alias previously established with `_linkPaths`.\r\n     *\r\n     * Note, the path to unlink should be the target (`to`) used when\r\n     * linking the paths.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<string|number>} path Target path to unlink.\r\n     * @return {void}\r\n     * @public\r\n     */\r\n    unlinkPaths(path) {\r\n      path = normalize(path);\r\n      if (this.__dataLinkedPaths) {\r\n        delete this.__dataLinkedPaths[path];\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Notify that an array has changed.\r\n     *\r\n     * Example:\r\n     *\r\n     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\r\n     *     ...\r\n     *     this.items.splice(1, 1, {name: 'Sam'});\r\n     *     this.items.push({name: 'Bob'});\r\n     *     this.notifySplices('items', [\r\n     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\r\n     *         object: this.items, type: 'splice' },\r\n     *       { index: 3, removed: [], addedCount: 1,\r\n     *         object: this.items, type: 'splice'}\r\n     *     ]);\r\n     *\r\n     * @param {string} path Path that should be notified.\r\n     * @param {Array} splices Array of splice records indicating ordered\r\n     *   changes that occurred to the array. Each record should have the\r\n     *   following fields:\r\n     *    * index: index at which the change occurred\r\n     *    * removed: array of items that were removed from this index\r\n     *    * addedCount: number of new items added at this index\r\n     *    * object: a reference to the array in question\r\n     *    * type: the string literal 'splice'\r\n     *\r\n     *   Note that splice records _must_ be normalized such that they are\r\n     *   reported in index order (raw results from `Object.observe` are not\r\n     *   ordered and must be normalized/merged before notifying).\r\n     *\r\n     * @override\r\n     * @return {void}\r\n     * @public\r\n     */\r\n    notifySplices(path, splices) {\r\n      let info = {path: ''};\r\n      let array = /** @type {Array} */(get(this, path, info));\r\n      notifySplices(this, array, info.path, splices);\r\n    }\r\n\r\n    /**\r\n     * Convenience method for reading a value from a path.\r\n     *\r\n     * Note, if any part in the path is undefined, this method returns\r\n     * `undefined` (this method does not throw when dereferencing undefined\r\n     * paths).\r\n     *\r\n     * @override\r\n     * @param {(string|!Array<(string|number)>)} path Path to the value\r\n     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\r\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\r\n     *   bracketed expressions are not supported; string-based path parts\r\n     *   *must* be separated by dots.  Note that when dereferencing array\r\n     *   indices, the index may be used as a dotted part directly\r\n     *   (e.g. `users.12.name` or `['users', 12, 'name']`).\r\n     * @param {Object=} root Root object from which the path is evaluated.\r\n     * @return {*} Value at the path, or `undefined` if any part of the path\r\n     *   is undefined.\r\n     * @public\r\n     */\r\n    get(path, root) {\r\n      return get(root || this, path);\r\n    }\r\n\r\n    /**\r\n     * Convenience method for setting a value to a path and notifying any\r\n     * elements bound to the same path.\r\n     *\r\n     * Note, if any part in the path except for the last is undefined,\r\n     * this method does nothing (this method does not throw when\r\n     * dereferencing undefined paths).\r\n     *\r\n     * @override\r\n     * @param {(string|!Array<(string|number)>)} path Path to the value\r\n     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\r\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\r\n     *   bracketed expressions are not supported; string-based path parts\r\n     *   *must* be separated by dots.  Note that when dereferencing array\r\n     *   indices, the index may be used as a dotted part directly\r\n     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\r\n     * @param {*} value Value to set at the specified path.\r\n     * @param {Object=} root Root object from which the path is evaluated.\r\n     *   When specified, no notification will occur.\r\n     * @return {void}\r\n     * @public\r\n     */\r\n    set(path, value, root) {\r\n      if (root) {\r\n        set(root, path, value);\r\n      } else {\r\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {\r\n          if (this._setPendingPropertyOrPath(path, value, true)) {\r\n            this._invalidateProperties();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Adds items onto the end of the array at the path specified.\r\n     *\r\n     * The arguments after `path` and return value match that of\r\n     * `Array.prototype.push`.\r\n     *\r\n     * This method notifies other paths to the same array that a\r\n     * splice occurred to the array.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<string|number>} path Path to array.\r\n     * @param {...*} items Items to push onto array\r\n     * @return {number} New length of the array.\r\n     * @public\r\n     */\r\n    push(path, ...items) {\r\n      let info = {path: ''};\r\n      let array = /** @type {Array}*/(get(this, path, info));\r\n      let len = array.length;\r\n      let ret = array.push(...items);\r\n      if (items.length) {\r\n        notifySplice(this, array, info.path, len, items.length, []);\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * Removes an item from the end of array at the path specified.\r\n     *\r\n     * The arguments after `path` and return value match that of\r\n     * `Array.prototype.pop`.\r\n     *\r\n     * This method notifies other paths to the same array that a\r\n     * splice occurred to the array.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<string|number>} path Path to array.\r\n     * @return {*} Item that was removed.\r\n     * @public\r\n     */\r\n    pop(path) {\r\n      let info = {path: ''};\r\n      let array = /** @type {Array} */(get(this, path, info));\r\n      let hadLength = Boolean(array.length);\r\n      let ret = array.pop();\r\n      if (hadLength) {\r\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * Starting from the start index specified, removes 0 or more items\r\n     * from the array and inserts 0 or more new items in their place.\r\n     *\r\n     * The arguments after `path` and return value match that of\r\n     * `Array.prototype.splice`.\r\n     *\r\n     * This method notifies other paths to the same array that a\r\n     * splice occurred to the array.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<string|number>} path Path to array.\r\n     * @param {number} start Index from which to start removing/inserting.\r\n     * @param {number=} deleteCount Number of items to remove.\r\n     * @param {...*} items Items to insert into array.\r\n     * @return {!Array} Array of removed items.\r\n     * @public\r\n     */\r\n    splice(path, start, deleteCount, ...items) {\r\n      let info = {path : ''};\r\n      let array = /** @type {Array} */(get(this, path, info));\r\n      // Normalize fancy native splice handling of crazy start values\r\n      if (start < 0) {\r\n        start = array.length - Math.floor(-start);\r\n      } else if (start) {\r\n        start = Math.floor(start);\r\n      }\r\n      // array.splice does different things based on the number of arguments\r\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\r\n      // do different things. In the former, the whole array is cleared. In the\r\n      // latter, no items are removed.\r\n      // This means that we need to detect whether 1. one of the arguments\r\n      // is actually passed in and then 2. determine how many arguments\r\n      // we should pass on to the native array.splice\r\n      //\r\n      let ret;\r\n      // Omit any additional arguments if they were not passed in\r\n      if (arguments.length === 2) {\r\n        ret = array.splice(start);\r\n      // Either start was undefined and the others were defined, but in this\r\n      // case we can safely pass on all arguments\r\n      //\r\n      // Note: this includes the case where none of the arguments were passed in,\r\n      // e.g. this.splice('array'). However, if both start and deleteCount\r\n      // are undefined, array.splice will not modify the array (as expected)\r\n      } else {\r\n        ret = array.splice(start, deleteCount, ...items);\r\n      }\r\n      // At the end, check whether any items were passed in (e.g. insertions)\r\n      // or if the return array contains items (e.g. deletions).\r\n      // Only notify if items were added or deleted.\r\n      if (items.length || ret.length) {\r\n        notifySplice(this, array, info.path, start, items.length, ret);\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * Removes an item from the beginning of array at the path specified.\r\n     *\r\n     * The arguments after `path` and return value match that of\r\n     * `Array.prototype.pop`.\r\n     *\r\n     * This method notifies other paths to the same array that a\r\n     * splice occurred to the array.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<string|number>} path Path to array.\r\n     * @return {*} Item that was removed.\r\n     * @public\r\n     */\r\n    shift(path) {\r\n      let info = {path: ''};\r\n      let array = /** @type {Array} */(get(this, path, info));\r\n      let hadLength = Boolean(array.length);\r\n      let ret = array.shift();\r\n      if (hadLength) {\r\n        notifySplice(this, array, info.path, 0, 0, [ret]);\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * Adds items onto the beginning of the array at the path specified.\r\n     *\r\n     * The arguments after `path` and return value match that of\r\n     * `Array.prototype.push`.\r\n     *\r\n     * This method notifies other paths to the same array that a\r\n     * splice occurred to the array.\r\n     *\r\n     * @override\r\n     * @param {string | !Array<string|number>} path Path to array.\r\n     * @param {...*} items Items to insert info array\r\n     * @return {number} New length of the array.\r\n     * @public\r\n     */\r\n    unshift(path, ...items) {\r\n      let info = {path: ''};\r\n      let array = /** @type {Array} */(get(this, path, info));\r\n      let ret = array.unshift(...items);\r\n      if (items.length) {\r\n        notifySplice(this, array, info.path, 0, items.length, []);\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * Notify that a path has changed.\r\n     *\r\n     * Example:\r\n     *\r\n     *     this.item.user.name = 'Bob';\r\n     *     this.notifyPath('item.user.name');\r\n     *\r\n     * @override\r\n     * @param {string} path Path that should be notified.\r\n     * @param {*=} value Value at the path (optional).\r\n     * @return {void}\r\n     * @public\r\n     */\r\n    notifyPath(path, value) {\r\n      /** @type {string} */\r\n      let propPath;\r\n      if (arguments.length == 1) {\r\n        // Get value if not supplied\r\n        let info = {path: ''};\r\n        value = get(this, path, info);\r\n        propPath = info.path;\r\n      } else if (Array.isArray(path)) {\r\n        // Normalize path if needed\r\n        propPath = normalize(path);\r\n      } else {\r\n        propPath = /** @type{string} */(path);\r\n      }\r\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\r\n        this._invalidateProperties();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Equivalent to static `createReadOnlyProperty` API but can be called on\r\n     * an instance to add effects at runtime.  See that method for\r\n     * full API docs.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @param {boolean=} protectedSetter Creates a custom protected setter\r\n     *   when `true`.\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _createReadOnlyProperty(property, protectedSetter) {\r\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\r\n      if (protectedSetter) {\r\n        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {\r\n          this._setProperty(property, value);\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Equivalent to static `createPropertyObserver` API but can be called on\r\n     * an instance to add effects at runtime.  See that method for\r\n     * full API docs.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @param {string|function(*,*)} method Function or name of observer method\r\n     *     to call\r\n     * @param {boolean=} dynamicFn Whether the method name should be included as\r\n     *   a dependency to the effect.\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _createPropertyObserver(property, method, dynamicFn) {\r\n      let info = { property, method, dynamicFn: Boolean(dynamicFn) };\r\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\r\n        fn: runObserverEffect, info, trigger: {name: property}\r\n      });\r\n      if (dynamicFn) {\r\n        this._addPropertyEffect(/** @type {string} */(method), TYPES.OBSERVE, {\r\n          fn: runObserverEffect, info, trigger: {name: method}\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Equivalent to static `createMethodObserver` API but can be called on\r\n     * an instance to add effects at runtime.  See that method for\r\n     * full API docs.\r\n     *\r\n     * @override\r\n     * @param {string} expression Method expression\r\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\r\n     *   whether method names should be included as a dependency to the effect.\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _createMethodObserver(expression, dynamicFn) {\r\n      let sig = parseMethod(expression);\r\n      if (!sig) {\r\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\r\n      }\r\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\r\n    }\r\n\r\n    /**\r\n     * Equivalent to static `createNotifyingProperty` API but can be called on\r\n     * an instance to add effects at runtime.  See that method for\r\n     * full API docs.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _createNotifyingProperty(property) {\r\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\r\n        fn: runNotifyEffect,\r\n        info: {\r\n          eventName: camelToDashCase(property) + '-changed',\r\n          property: property\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Equivalent to static `createReflectedProperty` API but can be called on\r\n     * an instance to add effects at runtime.  See that method for\r\n     * full API docs.\r\n     *\r\n     * @override\r\n     * @param {string} property Property name\r\n     * @return {void}\r\n     * @protected\r\n     * @suppress {missingProperties} go/missingfnprops\r\n     */\r\n    _createReflectedProperty(property) {\r\n      let attr = this.constructor.attributeNameForProperty(property);\r\n      if (attr[0] === '-') {\r\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' +\r\n          attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\r\n      } else {\r\n        this._addPropertyEffect(property, TYPES.REFLECT, {\r\n          fn: runReflectEffect,\r\n          info: {\r\n            attrName: attr\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Equivalent to static `createComputedProperty` API but can be called on\r\n     * an instance to add effects at runtime.  See that method for\r\n     * full API docs.\r\n     *\r\n     * @override\r\n     * @param {string} property Name of computed property to set\r\n     * @param {string} expression Method expression\r\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\r\n     *   whether method names should be included as a dependency to the effect.\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _createComputedProperty(property, expression, dynamicFn) {\r\n      let sig = parseMethod(expression);\r\n      if (!sig) {\r\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\r\n      }\r\n      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\r\n      // Effects are normally stored as map of dependency->effect, but for\r\n      // ordered computation, we also need tree of computedProp->dependencies\r\n      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\r\n    }\r\n\r\n    /**\r\n     * Gather the argument values for a method specified in the provided array\r\n     * of argument metadata.\r\n     *\r\n     * The `path` and `value` arguments are used to fill in wildcard descriptor\r\n     * when the method is being called as a result of a path notification.\r\n     *\r\n     * @param {!Array<!MethodArg>} args Array of argument metadata\r\n     * @param {string} path Property/path name that triggered the method effect\r\n     * @param {Object} props Bag of current property changes\r\n     * @return {!Array<*>} Array of argument values\r\n     * @private\r\n     */\r\n    _marshalArgs(args, path, props) {\r\n      const data = this.__data;\r\n      const values = [];\r\n      for (let i=0, l=args.length; i<l; i++) {\r\n        let {name, structured, wildcard, value, literal} = args[i];\r\n        if (!literal) {\r\n          if (wildcard) {\r\n            const matches = isDescendant(name, path);\r\n            const pathValue = getArgValue(data, props, matches ? path : name);\r\n            value = {\r\n              path: matches ? path : name,\r\n              value: pathValue,\r\n              base: matches ? get(data, name) : pathValue\r\n            };\r\n          } else {\r\n            value = structured ? getArgValue(data, props, name) : data[name];\r\n          }\r\n        }\r\n        // When the `legacyUndefined` flag is enabled, pass a no-op value\r\n        // so that the observer, computed property, or compound binding is aborted.\r\n        if (legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\r\n          return NOOP;\r\n        }\r\n        values[i] = value;\r\n      }\r\n      return values;\r\n    }\r\n\r\n    // -- static class methods ------------\r\n\r\n    /**\r\n     * Ensures an accessor exists for the specified property, and adds\r\n     * to a list of \"property effects\" that will run when the accessor for\r\n     * the specified property is set.  Effects are grouped by \"type\", which\r\n     * roughly corresponds to a phase in effect processing.  The effect\r\n     * metadata should be in the following form:\r\n     *\r\n     *     {\r\n     *       fn: effectFunction, // Reference to function to call to perform effect\r\n     *       info: { ... }       // Effect metadata passed to function\r\n     *       trigger: {          // Optional triggering metadata; if not provided\r\n     *         name: string      // the property is treated as a wildcard\r\n     *         structured: boolean\r\n     *         wildcard: boolean\r\n     *       }\r\n     *     }\r\n     *\r\n     * Effects are called from `_propertiesChanged` in the following order by\r\n     * type:\r\n     *\r\n     * 1. COMPUTE\r\n     * 2. PROPAGATE\r\n     * 3. REFLECT\r\n     * 4. OBSERVE\r\n     * 5. NOTIFY\r\n     *\r\n     * Effect functions are called with the following signature:\r\n     *\r\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\r\n     *\r\n     * @param {string} property Property that should trigger the effect\r\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\r\n     * @param {Object=} effect Effect metadata object\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static addPropertyEffect(property, type, effect) {\r\n      this.prototype._addPropertyEffect(property, type, effect);\r\n    }\r\n\r\n    /**\r\n     * Creates a single-property observer for the given property.\r\n     *\r\n     * @param {string} property Property name\r\n     * @param {string|function(*,*)} method Function or name of observer method to call\r\n     * @param {boolean=} dynamicFn Whether the method name should be included as\r\n     *   a dependency to the effect.\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createPropertyObserver(property, method, dynamicFn) {\r\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\r\n    }\r\n\r\n    /**\r\n     * Creates a multi-property \"method observer\" based on the provided\r\n     * expression, which should be a string in the form of a normal JavaScript\r\n     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\r\n     * should correspond to a property or path in the context of this\r\n     * prototype (or instance), or may be a literal string or number.\r\n     *\r\n     * @param {string} expression Method expression\r\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\r\n     * @return {void}\r\n     *   whether method names should be included as a dependency to the effect.\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createMethodObserver(expression, dynamicFn) {\r\n      this.prototype._createMethodObserver(expression, dynamicFn);\r\n    }\r\n\r\n    /**\r\n     * Causes the setter for the given property to dispatch `<property>-changed`\r\n     * events to notify of changes to the property.\r\n     *\r\n     * @param {string} property Property name\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createNotifyingProperty(property) {\r\n      this.prototype._createNotifyingProperty(property);\r\n    }\r\n\r\n    /**\r\n     * Creates a read-only accessor for the given property.\r\n     *\r\n     * To set the property, use the protected `_setProperty` API.\r\n     * To create a custom protected setter (e.g. `_setMyProp()` for\r\n     * property `myProp`), pass `true` for `protectedSetter`.\r\n     *\r\n     * Note, if the property will have other property effects, this method\r\n     * should be called first, before adding other effects.\r\n     *\r\n     * @param {string} property Property name\r\n     * @param {boolean=} protectedSetter Creates a custom protected setter\r\n     *   when `true`.\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createReadOnlyProperty(property, protectedSetter) {\r\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\r\n    }\r\n\r\n    /**\r\n     * Causes the setter for the given property to reflect the property value\r\n     * to a (dash-cased) attribute of the same name.\r\n     *\r\n     * @param {string} property Property name\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createReflectedProperty(property) {\r\n      this.prototype._createReflectedProperty(property);\r\n    }\r\n\r\n    /**\r\n     * Creates a computed property whose value is set to the result of the\r\n     * method described by the given `expression` each time one or more\r\n     * arguments to the method changes.  The expression should be a string\r\n     * in the form of a normal JavaScript function signature:\r\n     * `'methodName(arg1, [..., argn])'`\r\n     *\r\n     * @param {string} property Name of computed property to set\r\n     * @param {string} expression Method expression\r\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\r\n     *   method names should be included as a dependency to the effect.\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createComputedProperty(property, expression, dynamicFn) {\r\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\r\n    }\r\n\r\n    /**\r\n     * Parses the provided template to ensure binding effects are created\r\n     * for them, and then ensures property accessors are created for any\r\n     * dependent properties in the template.  Binding effects for bound\r\n     * templates are stored in a linked list on the instance so that\r\n     * templates can be efficiently stamped and unstamped.\r\n     *\r\n     * @param {!HTMLTemplateElement} template Template containing binding\r\n     *   bindings\r\n     * @return {!TemplateInfo} Template metadata object\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static bindTemplate(template) {\r\n      return this.prototype._bindTemplate(template);\r\n    }\r\n\r\n    // -- binding ----------------------------------------------\r\n\r\n    /*\r\n     * Overview of binding flow:\r\n     *\r\n     * During finalization (`instanceBinding==false`, `wasPreBound==false`):\r\n     *  `_bindTemplate(t, false)` called directly during finalization - parses\r\n     *  the template (for the first time), and then assigns that _prototypical_\r\n     *  template info to `__preboundTemplateInfo` _on the prototype_; note in\r\n     *  this case `wasPreBound` is false; this is the first time we're binding\r\n     *  it, thus we create accessors.\r\n     *\r\n     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\r\n     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\r\n     *   returned matches the prebound one, and so this is `wasPreBound == true`\r\n     *   state; thus we _skip_ creating accessors, but _do_ create an instance\r\n     *   of the template info to serve as the start of our linked list (needs to\r\n     *   be an instance, not the prototypical one, so that we can add `nodeList`\r\n     *   to it to contain the `nodeInfo`-ordered list of instance nodes for\r\n     *   bindings, and so we can chain runtime-stamped template infos off of\r\n     *   it). At this point, the call to `_stampTemplate` calls\r\n     *   `applyTemplateInfo` for each nested `<template>` found during parsing\r\n     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\r\n     *   `templateInfo` to the `<template>` so that we have the instance-time\r\n     *   parent to link the `templateInfo` under in the case it was\r\n     *   runtime-stamped.\r\n     *\r\n     * During subsequent runtime stamping (`instanceBinding==true`,\r\n     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\r\n     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\r\n     *   because it was either a different template altogether, or even if it\r\n     *   was the same template, the step above created a instance of the info;\r\n     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\r\n     *   link a instance into the linked list.\r\n     */\r\n\r\n    /**\r\n     * Equivalent to static `bindTemplate` API but can be called on an instance\r\n     * to add effects at runtime.  See that method for full API docs.\r\n     *\r\n     * This method may be called on the prototype (for prototypical template\r\n     * binding, to avoid creating accessors every instance) once per prototype,\r\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\r\n     * create and link an instance of the template metadata associated with a\r\n     * particular stamping.\r\n     *\r\n     * @override\r\n     * @param {!HTMLTemplateElement} template Template containing binding\r\n     * bindings\r\n     * @param {boolean=} instanceBinding When false (default), performs\r\n     * \"prototypical\" binding of the template and overwrites any previously\r\n     * bound template for the class. When true (as passed from\r\n     * `_stampTemplate`), the template info is instanced and linked into the\r\n     * list of bound templates.\r\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\r\n     * this is an instance of the prototypical template info\r\n     * @protected\r\n     * @suppress {missingProperties} go/missingfnprops\r\n     */\r\n    _bindTemplate(template, instanceBinding) {\r\n      let templateInfo = this.constructor._parseTemplate(template);\r\n      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;\r\n      // Optimization: since this is called twice for proto-bound templates,\r\n      // don't attempt to recreate accessors if this template was pre-bound\r\n      if (!wasPreBound) {\r\n        for (let prop in templateInfo.propertyEffects) {\r\n          this._createPropertyAccessor(prop);\r\n        }\r\n      }\r\n      if (instanceBinding) {\r\n        // For instance-time binding, create instance of template metadata\r\n        // and link into tree of templates if necessary\r\n        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));\r\n        templateInfo.wasPreBound = wasPreBound;\r\n        if (!this.__templateInfo) {\r\n          // Set the info to the root of the tree\r\n          this.__templateInfo = templateInfo;\r\n        } else {\r\n          // Append this template info onto the end of its parent template's\r\n          // list, which will determine the tree structure via which property\r\n          // effects are run; if this template was not nested in another\r\n          // template, use the root template (the first stamped one) as the\r\n          // parent. Note, `parent` is the `templateInfo` instance for this\r\n          // template's parent (containing) template, which was set up in\r\n          // `applyTemplateInfo`.  While a given template's `parent` is set\r\n          // apriori, it is only added to the parent's child list at the point\r\n          // that it is being bound, since a template may or may not ever be\r\n          // stamped, and may be stamped more than once (in which case instances\r\n          // of the template info will be in the tree under its parent more than\r\n          // once).\r\n          const parent = template._parentTemplateInfo || this.__templateInfo;\r\n          const previous = parent.lastChild;\r\n          templateInfo.parent = parent;\r\n          parent.lastChild = templateInfo;\r\n          templateInfo.previousSibling = previous;\r\n          if (previous) {\r\n            previous.nextSibling = templateInfo;\r\n          } else {\r\n            parent.firstChild = templateInfo;\r\n          }\r\n        }\r\n      } else {\r\n        this.__preBoundTemplateInfo = templateInfo;\r\n      }\r\n      return templateInfo;\r\n    }\r\n\r\n    /**\r\n     * Adds a property effect to the given template metadata, which is run\r\n     * at the \"propagate\" stage of `_propertiesChanged` when the template\r\n     * has been bound to the element via `_bindTemplate`.\r\n     *\r\n     * The `effect` object should match the format in `_addPropertyEffect`.\r\n     *\r\n     * @param {Object} templateInfo Template metadata to add effect to\r\n     * @param {string} prop Property that should trigger the effect\r\n     * @param {Object=} effect Effect metadata object\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\r\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\r\n      hostProps[prop] = true;\r\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\r\n      let propEffects = effects[prop] = effects[prop] || [];\r\n      propEffects.push(effect);\r\n    }\r\n\r\n    /**\r\n     * Stamps the provided template and performs instance-time setup for\r\n     * Polymer template features, including data bindings, declarative event\r\n     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\r\n     * is returned containing the stamped DOM, ready for insertion into the\r\n     * DOM.\r\n     *\r\n     * This method may be called more than once; however note that due to\r\n     * `shadycss` polyfill limitations, only styles from templates prepared\r\n     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\r\n     * to the shadow root and support CSS custom properties), and note that\r\n     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\r\n     * any styles required by in runtime-stamped templates must be included\r\n     * in the main element template.\r\n     *\r\n     * @param {!HTMLTemplateElement} template Template to stamp\r\n     * @param {TemplateInfo=} templateInfo Optional bound template info associated\r\n     *   with the template to be stamped; if omitted the template will be\r\n     *   automatically bound.\r\n     * @return {!StampedTemplate} Cloned template content\r\n     * @override\r\n     * @protected\r\n     */\r\n    _stampTemplate(template, templateInfo) {\r\n      templateInfo =  templateInfo || /** @type {!TemplateInfo} */(this._bindTemplate(template, true));\r\n      // Ensures that created dom is `_enqueueClient`'d to this element so\r\n      // that it can be flushed on next call to `_flushProperties`\r\n      hostStack.push(this);\r\n      let dom = super._stampTemplate(template, templateInfo);\r\n      hostStack.pop();\r\n      // Add template-instance-specific data to instanced templateInfo\r\n      templateInfo.nodeList = dom.nodeList;\r\n      // Capture child nodes to allow unstamping of non-prototypical templates\r\n      if (!templateInfo.wasPreBound) {\r\n        let nodes = templateInfo.childNodes = [];\r\n        for (let n=dom.firstChild; n; n=n.nextSibling) {\r\n          nodes.push(n);\r\n        }\r\n      }\r\n      dom.templateInfo = templateInfo;\r\n      // Setup compound storage, 2-way listeners, and dataHost for bindings\r\n      setupBindings(this, templateInfo);\r\n      // Flush properties into template nodes; the check on `__dataClientsReady`\r\n      // ensures we don't needlessly run effects for an element's initial\r\n      // prototypical template stamping since they will happen as a part of the\r\n      // first call to `_propertiesChanged`. This flag is set to true\r\n      // after running the initial propagate effects, and immediately before\r\n      // flushing clients. Since downstream clients could cause stamping on\r\n      // this host (e.g. a fastDomIf `dom-if` being forced to render\r\n      // synchronously), this flag ensures effects for runtime-stamped templates\r\n      // are run at this point during the initial element boot-up.\r\n      if (this.__dataClientsReady) {\r\n        this._runEffectsForTemplate(templateInfo, this.__data, null, false);\r\n        this._flushClients();\r\n      }\r\n      return dom;\r\n    }\r\n\r\n    /**\r\n     * Removes and unbinds the nodes previously contained in the provided\r\n     * DocumentFragment returned from `_stampTemplate`.\r\n     *\r\n     * @override\r\n     * @param {!StampedTemplate} dom DocumentFragment previously returned\r\n     *   from `_stampTemplate` associated with the nodes to be removed\r\n     * @return {void}\r\n     * @protected\r\n     */\r\n    _removeBoundDom(dom) {\r\n      // Unlink template info; Note that while the child is unlinked from its\r\n      // parent list, a template's `parent` reference is never removed, since\r\n      // this is is determined by the tree structure and applied at\r\n      // `applyTemplateInfo` time.\r\n      const templateInfo = dom.templateInfo;\r\n      const {previousSibling, nextSibling, parent} = templateInfo;\r\n      if (previousSibling) {\r\n        previousSibling.nextSibling = nextSibling;\r\n      } else if (parent) {\r\n        parent.firstChild = nextSibling;\r\n      }\r\n      if (nextSibling) {\r\n        nextSibling.previousSibling = previousSibling;\r\n      } else if (parent) {\r\n        parent.lastChild = previousSibling;\r\n      }\r\n      templateInfo.nextSibling = templateInfo.previousSibling = null;\r\n      // Remove stamped nodes\r\n      let nodes = templateInfo.childNodes;\r\n      for (let i=0; i<nodes.length; i++) {\r\n        let node = nodes[i];\r\n        wrap(wrap(node).parentNode).removeChild(node);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Overrides default `TemplateStamp` implementation to add support for\r\n     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\r\n     * array is added to `nodeInfo` and populated with binding metadata\r\n     * with information capturing the binding target, and a `parts` array\r\n     * with one or more metadata objects capturing the source(s) of the\r\n     * binding.\r\n     *\r\n     * @param {Node} node Node to parse\r\n     * @param {TemplateInfo} templateInfo Template metadata for current template\r\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\r\n     * @return {boolean} `true` if the visited node added node-specific\r\n     *   metadata to `nodeInfo`\r\n     * @protected\r\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\r\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\r\n      //     Change back to just super.methodCall()\r\n      let noted = propertyEffectsBase._parseTemplateNode.call(\r\n        this, node, templateInfo, nodeInfo);\r\n      if (node.nodeType === Node.TEXT_NODE) {\r\n        let parts = this._parseBindings(node.textContent, templateInfo);\r\n        if (parts) {\r\n          // Initialize the textContent with any literal parts\r\n          // NOTE: default to a space here so the textNode remains; some browsers\r\n          // (IE) omit an empty textNode following cloneNode/importNode.\r\n          node.textContent = literalFromParts(parts) || ' ';\r\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\r\n          noted = true;\r\n        }\r\n      }\r\n      return noted;\r\n    }\r\n\r\n    /**\r\n     * Overrides default `TemplateStamp` implementation to add support for\r\n     * parsing bindings from attributes.  A `bindings`\r\n     * array is added to `nodeInfo` and populated with binding metadata\r\n     * with information capturing the binding target, and a `parts` array\r\n     * with one or more metadata objects capturing the source(s) of the\r\n     * binding.\r\n     *\r\n     * @param {Element} node Node to parse\r\n     * @param {TemplateInfo} templateInfo Template metadata for current template\r\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\r\n     * @param {string} name Attribute name\r\n     * @param {string} value Attribute value\r\n     * @return {boolean} `true` if the visited node added node-specific\r\n     *   metadata to `nodeInfo`\r\n     * @protected\r\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\r\n      let parts = this._parseBindings(value, templateInfo);\r\n      if (parts) {\r\n        // Attribute or property\r\n        let origName = name;\r\n        let kind = 'property';\r\n        // The only way we see a capital letter here is if the attr has\r\n        // a capital letter in it per spec. In this case, to make sure\r\n        // this binding works, we go ahead and make the binding to the attribute.\r\n        if (capitalAttributeRegex.test(name)) {\r\n          kind = 'attribute';\r\n        } else if (name[name.length-1] == '$') {\r\n          name = name.slice(0, -1);\r\n          kind = 'attribute';\r\n        }\r\n        // Initialize attribute bindings with any literal parts\r\n        let literal = literalFromParts(parts);\r\n        if (literal && kind == 'attribute') {\r\n          // Ensure a ShadyCSS template scoped style is not removed\r\n          // when a class$ binding's initial literal value is set.\r\n          if (name == 'class' && node.hasAttribute('class')) {\r\n            literal += ' ' + node.getAttribute(name);\r\n          }\r\n          node.setAttribute(name, literal);\r\n        }\r\n        // support disable-upgrade\r\n        if (kind == 'attribute' && origName == 'disable-upgrade$') {\r\n          node.setAttribute(name, '');\r\n        }\r\n        // Clear attribute before removing, since IE won't allow removing\r\n        // `value` attribute if it previously had a value (can't\r\n        // unconditionally set '' before removing since attributes with `$`\r\n        // can't be set using setAttribute)\r\n        if (node.localName === 'input' && origName === 'value') {\r\n          node.setAttribute(origName, '');\r\n        }\r\n        // Remove annotation\r\n        node.removeAttribute(origName);\r\n        // Case hackery: attributes are lower-case, but bind targets\r\n        // (properties) are case sensitive. Gambit is to map dash-case to\r\n        // camel-case: `foo-bar` becomes `fooBar`.\r\n        // Attribute bindings are excepted.\r\n        if (kind === 'property') {\r\n          name = dashToCamelCase(name);\r\n        }\r\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\r\n        return true;\r\n      } else {\r\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\r\n        //     Change back to just super.methodCall()\r\n        return propertyEffectsBase._parseTemplateNodeAttribute.call(\r\n          this, node, templateInfo, nodeInfo, name, value);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Overrides default `TemplateStamp` implementation to add support for\r\n     * binding the properties that a nested template depends on to the template\r\n     * as `_host_<property>`.\r\n     *\r\n     * @param {Node} node Node to parse\r\n     * @param {TemplateInfo} templateInfo Template metadata for current template\r\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\r\n     * @return {boolean} `true` if the visited node added node-specific\r\n     *   metadata to `nodeInfo`\r\n     * @protected\r\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\r\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\r\n      //     Change back to just super.methodCall()\r\n      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(\r\n        this, node, templateInfo, nodeInfo);\r\n      const parent = node.parentNode;\r\n      const nestedTemplateInfo = nodeInfo.templateInfo;\r\n      const isDomIf = parent.localName === 'dom-if';\r\n      const isDomRepeat = parent.localName === 'dom-repeat';\r\n      // Remove nested template and redirect its host bindings & templateInfo\r\n      // onto the parent (dom-if/repeat element)'s nodeInfo\r\n      if (removeNestedTemplates && (isDomIf || isDomRepeat)) {\r\n        parent.removeChild(node);\r\n        // Use the parent's nodeInfo (for the dom-if/repeat) to record the\r\n        // templateInfo, and use that for any host property bindings below\r\n        nodeInfo = nodeInfo.parentInfo;\r\n        nodeInfo.templateInfo = nestedTemplateInfo;\r\n        // Ensure the parent dom-if/repeat is noted since it now may have host\r\n        // bindings; it may not have been if it did not have its own bindings\r\n        nodeInfo.noted = true;\r\n        noted = false;\r\n      }\r\n      // Merge host props into outer template and add bindings\r\n      let hostProps = nestedTemplateInfo.hostProps;\r\n      if (fastDomIf && isDomIf) {\r\n        // `fastDomIf` mode uses runtime-template stamping to add accessors/\r\n        // effects to properties used in its template; as such we don't need to\r\n        // tax the host element with `_host_` bindings for the `dom-if`.\r\n        // However, in the event it is nested in a `dom-repeat`, it is still\r\n        // important that its host properties are added to the\r\n        // TemplateInstance's `hostProps` so that they are forwarded to the\r\n        // TemplateInstance.\r\n        if (hostProps) {\r\n          templateInfo.hostProps =\r\n            Object.assign(templateInfo.hostProps || {}, hostProps);\r\n          // Ensure the dom-if is noted so that it has a __dataHost, since\r\n          // `fastDomIf` uses the host for runtime template stamping; note this\r\n          // was already ensured above in the `removeNestedTemplates` case\r\n          if (!removeNestedTemplates) {\r\n            nodeInfo.parentInfo.noted = true;\r\n          }\r\n        }\r\n      } else {\r\n        let mode = '{';\r\n        for (let source in hostProps) {\r\n          let parts = [{ mode, source, dependencies: [source], hostProp: true }];\r\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\r\n        }\r\n      }\r\n      return noted;\r\n    }\r\n\r\n    /**\r\n     * Called to parse text in a template (either attribute values or\r\n     * textContent) into binding metadata.\r\n     *\r\n     * Any overrides of this method should return an array of binding part\r\n     * metadata  representing one or more bindings found in the provided text\r\n     * and any \"literal\" text in between.  Any non-literal parts will be passed\r\n     * to `_evaluateBinding` when any dependencies change.  The only required\r\n     * fields of each \"part\" in the returned array are as follows:\r\n     *\r\n     * - `dependencies` - Array containing trigger metadata for each property\r\n     *   that should trigger the binding to update\r\n     * - `literal` - String containing text if the part represents a literal;\r\n     *   in this case no `dependencies` are needed\r\n     *\r\n     * Additional metadata for use by `_evaluateBinding` may be provided in\r\n     * each part object as needed.\r\n     *\r\n     * The default implementation handles the following types of bindings\r\n     * (one or more may be intermixed with literal strings):\r\n     * - Property binding: `[[prop]]`\r\n     * - Path binding: `[[object.prop]]`\r\n     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\r\n     * - Two-way property or path bindings (supports negation):\r\n     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\r\n     * - Inline computed method (supports negation):\r\n     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\r\n     *\r\n     * The default implementation uses a regular expression for best\r\n     * performance. However, the regular expression uses a white-list of\r\n     * allowed characters in a data-binding, which causes problems for\r\n     * data-bindings that do use characters not in this white-list.\r\n     *\r\n     * Instead of updating the white-list with all allowed characters,\r\n     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\r\n     * that uses a state machine instead. This state machine is able to handle\r\n     * all characters. However, it is slightly less performant, therefore we\r\n     * extracted it into a separate optional mixin.\r\n     *\r\n     * @param {string} text Text to parse from attribute or textContent\r\n     * @param {Object} templateInfo Current template metadata\r\n     * @return {Array<!BindingPart>} Array of binding part metadata\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static _parseBindings(text, templateInfo) {\r\n      let parts = [];\r\n      let lastIndex = 0;\r\n      let m;\r\n      // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\r\n      // Regex matches:\r\n      //        Iteration 1:  Iteration 2:\r\n      // m[1]: '{{'          '[['\r\n      // m[2]: ''            '!'\r\n      // m[3]: 'prop'        'compute(foo,bar)'\r\n      while ((m = bindingRegex.exec(text)) !== null) {\r\n        // Add literal part\r\n        if (m.index > lastIndex) {\r\n          parts.push({literal: text.slice(lastIndex, m.index)});\r\n        }\r\n        // Add binding part\r\n        let mode = m[1][0];\r\n        let negate = Boolean(m[2]);\r\n        let source = m[3].trim();\r\n        let customEvent = false, notifyEvent = '', colon = -1;\r\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\r\n          notifyEvent = source.substring(colon + 2);\r\n          source = source.substring(0, colon);\r\n          customEvent = true;\r\n        }\r\n        let signature = parseMethod(source);\r\n        let dependencies = [];\r\n        if (signature) {\r\n          // Inline computed function\r\n          let {args, methodName} = signature;\r\n          for (let i=0; i<args.length; i++) {\r\n            let arg = args[i];\r\n            if (!arg.literal) {\r\n              dependencies.push(arg);\r\n            }\r\n          }\r\n          let dynamicFns = templateInfo.dynamicFns;\r\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\r\n            dependencies.push(methodName);\r\n            signature.dynamicFn = true;\r\n          }\r\n        } else {\r\n          // Property or path\r\n          dependencies.push(source);\r\n        }\r\n        parts.push({\r\n          source, mode, negate, customEvent, signature, dependencies,\r\n          event: notifyEvent\r\n        });\r\n        lastIndex = bindingRegex.lastIndex;\r\n      }\r\n      // Add a final literal part\r\n      if (lastIndex && lastIndex < text.length) {\r\n        let literal = text.substring(lastIndex);\r\n        if (literal) {\r\n          parts.push({\r\n            literal: literal\r\n          });\r\n        }\r\n      }\r\n      if (parts.length) {\r\n        return parts;\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Called to evaluate a previously parsed binding part based on a set of\r\n     * one or more changed dependencies.\r\n     *\r\n     * @param {!Polymer_PropertyEffects} inst Element that should be used as\r\n     *     scope for binding dependencies\r\n     * @param {BindingPart} part Binding part metadata\r\n     * @param {string} path Property/path that triggered this effect\r\n     * @param {Object} props Bag of current property changes\r\n     * @param {Object} oldProps Bag of previous values for changed properties\r\n     * @param {boolean} hasPaths True with `props` contains one or more paths\r\n     * @return {*} Value the binding part evaluated to\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\r\n      let value;\r\n      if (part.signature) {\r\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\r\n      } else if (path != part.source) {\r\n        value = get(inst, part.source);\r\n      } else {\r\n        if (hasPaths && isPath(path)) {\r\n          value = get(inst, path);\r\n        } else {\r\n          value = inst.__data[path];\r\n        }\r\n      }\r\n      if (part.negate) {\r\n        value = !value;\r\n      }\r\n      return value;\r\n    }\r\n\r\n  }\r\n\r\n  return PropertyEffects;\r\n});\r\n\r\n/**\r\n * Stack for enqueuing client dom created by a host element.\r\n *\r\n * By default elements are flushed via `_flushProperties` when\r\n * `connectedCallback` is called. Elements attach their client dom to\r\n * themselves at `ready` time which results from this first flush.\r\n * This provides an ordering guarantee that the client dom an element\r\n * creates is flushed before the element itself (i.e. client `ready`\r\n * fires before host `ready`).\r\n *\r\n * However, if `_flushProperties` is called *before* an element is connected,\r\n * as for example `Templatize` does, this ordering guarantee cannot be\r\n * satisfied because no elements are connected. (Note: Bound elements that\r\n * receive data do become enqueued clients and are properly ordered but\r\n * unbound elements are not.)\r\n *\r\n * To maintain the desired \"client before host\" ordering guarantee for this\r\n * case we rely on the \"host stack. Client nodes registers themselves with\r\n * the creating host element when created. This ensures that all client dom\r\n * is readied in the proper order, maintaining the desired guarantee.\r\n *\r\n * @private\r\n */\r\nconst hostStack = [];\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/**\r\n * Total number of Polymer element instances created.\r\n * @type {number}\r\n */\r\nexport let instanceCount = 0;\r\n\r\nexport function incrementInstanceCount() {\r\n  instanceCount++;\r\n}\r\n\r\n/**\r\n * Array of Polymer element classes that have been finalized.\r\n * @type {!Array<!PolymerElementConstructor>}\r\n */\r\nexport const registrations = [];\r\n\r\n/**\r\n * @param {!PolymerElementConstructor} prototype Element prototype to log\r\n * @private\r\n */\r\nfunction _regLog(prototype) {\r\n  console.log('[' + /** @type {?} */(prototype).is + ']: registered');\r\n}\r\n\r\n/**\r\n * Registers a class prototype for telemetry purposes.\r\n * @param {!PolymerElementConstructor} prototype Element prototype to register\r\n * @protected\r\n */\r\nexport function register(prototype) {\r\n  registrations.push(prototype);\r\n}\r\n\r\n/**\r\n * Logs all elements registered with an `is` to the console.\r\n * @public\r\n */\r\nexport function dumpRegistrations() {\r\n  registrations.forEach(_regLog);\r\n}", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\nimport '../utils/boot.js';\r\n\r\nimport { dedupingMixin } from '../utils/mixin.js';\r\nimport { register, incrementInstanceCount } from '../utils/telemetry.js';\r\nimport { PropertiesChanged } from './properties-changed.js';\r\n\r\n/**\r\n * Creates a copy of `props` with each property normalized such that\r\n * upgraded it is an object with at least a type property { type: Type}.\r\n *\r\n * @param {!Object} props Properties to normalize\r\n * @return {!Object} Copy of input `props` with normalized properties that\r\n * are in the form {type: Type}\r\n * @private\r\n */\r\nfunction normalizeProperties(props) {\r\n  const output = {};\r\n  for (let p in props) {\r\n    const o = props[p];\r\n    output[p] = (typeof o === 'function') ? {type: o} : o;\r\n  }\r\n  return output;\r\n}\r\n\r\n/**\r\n * Mixin that provides a minimal starting point to using the PropertiesChanged\r\n * mixin by providing a mechanism to declare properties in a static\r\n * getter (e.g. static get properties() { return { foo: String } }). Changes\r\n * are reported via the `_propertiesChanged` method.\r\n *\r\n * This mixin provides no specific support for rendering. Users are expected\r\n * to create a ShadowRoot and put content into it and update it in whatever\r\n * way makes sense. This can be done in reaction to properties changing by\r\n * implementing `_propertiesChanged`.\r\n *\r\n * @mixinFunction\r\n * @polymer\r\n * @appliesMixin PropertiesChanged\r\n * @summary Mixin that provides a minimal starting point for using\r\n * the PropertiesChanged mixin by providing a declarative `properties` object.\r\n * @template T\r\n * @param {function(new:T)} superClass Class to apply mixin to.\r\n * @return {function(new:T)} superClass with mixin applied.\r\n */\r\nexport const PropertiesMixin = dedupingMixin(superClass => {\r\n\r\n /**\r\n  * @constructor\r\n  * @implements {Polymer_PropertiesChanged}\r\n  * @private\r\n  */\r\n const base = PropertiesChanged(superClass);\r\n\r\n /**\r\n  * Returns the super class constructor for the given class, if it is an\r\n  * instance of the PropertiesMixin.\r\n  *\r\n  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor\r\n  * @return {?PropertiesMixinConstructor} Super class constructor\r\n  */\r\n function superPropertiesClass(constructor) {\r\n   const superCtor = Object.getPrototypeOf(constructor);\r\n\r\n   // Note, the `PropertiesMixin` class below only refers to the class\r\n   // generated by this call to the mixin; the instanceof test only works\r\n   // because the mixin is deduped and guaranteed only to apply once, hence\r\n   // all constructors in a proto chain will see the same `PropertiesMixin`\r\n   return (superCtor.prototype instanceof PropertiesMixin) ?\r\n     /** @type {!PropertiesMixinConstructor} */ (superCtor) : null;\r\n }\r\n\r\n /**\r\n  * Returns a memoized version of the `properties` object for the\r\n  * given class. Properties not in object format are converted to at\r\n  * least {type}.\r\n  *\r\n  * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor\r\n  * @return {Object} Memoized properties object\r\n  */\r\n function ownProperties(constructor) {\r\n   if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {\r\n     let props = null;\r\n\r\n     if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {\r\n       const properties = constructor.properties;\r\n\r\n       if (properties) {\r\n        props = normalizeProperties(properties);\r\n       }\r\n     }\r\n\r\n     constructor.__ownProperties = props;\r\n   }\r\n   return constructor.__ownProperties;\r\n }\r\n\r\n /**\r\n  * @polymer\r\n  * @mixinClass\r\n  * @extends {base}\r\n  * @implements {Polymer_PropertiesMixin}\r\n  * @unrestricted\r\n  */\r\n class PropertiesMixin extends base {\r\n\r\n   /**\r\n    * Implements standard custom elements getter to observes the attributes\r\n    * listed in `properties`.\r\n    * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\r\n    * @nocollapse\r\n    */\r\n   static get observedAttributes() {\r\n     if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\r\n       register(this.prototype);\r\n       const props = this._properties;\r\n       this.__observedAttributes = props ? Object.keys(props).map(p => this.prototype._addPropertyToAttributeMap(p)) : [];\r\n     }\r\n     return this.__observedAttributes;\r\n   }\r\n\r\n   /**\r\n    * Finalizes an element definition, including ensuring any super classes\r\n    * are also finalized. This includes ensuring property\r\n    * accessors exist on the element prototype. This method calls\r\n    * `_finalizeClass` to finalize each constructor in the prototype chain.\r\n    * @return {void}\r\n    * @nocollapse\r\n    */\r\n   static finalize() {\r\n     if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {\r\n       const superCtor = superPropertiesClass(/** @type {!PropertiesMixinConstructor} */(this));\r\n       if (superCtor) {\r\n         superCtor.finalize();\r\n       }\r\n       this.__finalized = true;\r\n       this._finalizeClass();\r\n     }\r\n   }\r\n\r\n   /**\r\n    * Finalize an element class. This includes ensuring property\r\n    * accessors exist on the element prototype. This method is called by\r\n    * `finalize` and finalizes the class constructor.\r\n    *\r\n    * @protected\r\n    * @nocollapse\r\n    */\r\n   static _finalizeClass() {\r\n     const props = ownProperties(/** @type {!PropertiesMixinConstructor} */(this));\r\n     if (props) {\r\n       /** @type {?} */ (this).createProperties(props);\r\n     }\r\n   }\r\n\r\n   /**\r\n    * Returns a memoized version of all properties, including those inherited\r\n    * from super classes. Properties not in object format are converted to\r\n    * at least {type}.\r\n    *\r\n    * @return {Object} Object containing properties for this class\r\n    * @protected\r\n    * @nocollapse\r\n    */\r\n   static get _properties() {\r\n     if (!this.hasOwnProperty(\r\n       JSCompiler_renameProperty('__properties', this))) {\r\n       const superCtor = superPropertiesClass(/** @type {!PropertiesMixinConstructor} */(this));\r\n       this.__properties = Object.assign({},\r\n         superCtor && superCtor._properties,\r\n         ownProperties(/** @type {PropertiesMixinConstructor} */(this)));\r\n     }\r\n     return this.__properties;\r\n   }\r\n\r\n   /**\r\n    * Overrides `PropertiesChanged` method to return type specified in the\r\n    * static `properties` object for the given property.\r\n    * @param {string} name Name of property\r\n    * @return {*} Type to which to deserialize attribute\r\n    *\r\n    * @protected\r\n    * @nocollapse\r\n    */\r\n   static typeForProperty(name) {\r\n     const info = this._properties[name];\r\n     return info && info.type;\r\n   }\r\n\r\n   /**\r\n    * Overrides `PropertiesChanged` method and adds a call to\r\n    * `finalize` which lazily configures the element's property accessors.\r\n    * @override\r\n    * @return {void}\r\n    */\r\n   _initializeProperties() {\r\n     incrementInstanceCount();\r\n     this.constructor.finalize();\r\n     super._initializeProperties();\r\n   }\r\n\r\n   /**\r\n    * Called when the element is added to a document.\r\n    * Calls `_enableProperties` to turn on property system from\r\n    * `PropertiesChanged`.\r\n    * @suppress {missingProperties} Super may or may not implement the callback\r\n    * @return {void}\r\n    * @override\r\n    */\r\n   connectedCallback() {\r\n     if (super.connectedCallback) {\r\n       super.connectedCallback();\r\n     }\r\n     this._enableProperties();\r\n   }\r\n\r\n   /**\r\n    * Called when the element is removed from a document\r\n    * @suppress {missingProperties} Super may or may not implement the callback\r\n    * @return {void}\r\n    * @override\r\n    */\r\n   disconnectedCallback() {\r\n     if (super.disconnectedCallback) {\r\n       super.disconnectedCallback();\r\n     }\r\n   }\r\n\r\n }\r\n\r\n return PropertiesMixin;\r\n\r\n});\r\n", "/**\r\n * @fileoverview\r\n * @suppress {checkPrototypalTypes}\r\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\r\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\r\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\r\n * Google as part of the polymer project is also subject to an additional IP\r\n * rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\nimport '../utils/boot.js';\r\n\r\nimport { rootPath, strictTemplatePolicy, allowTemplateFromDomModule, legacyOptimizations, legacyWarnings, syncInitialRender, supportsAdoptingStyleSheets, useAdoptedStyleSheetsWithBuiltCSS } from '../utils/settings.js';\r\nimport { dedupingMixin } from '../utils/mixin.js';\r\nimport { stylesFromTemplate, stylesFromModuleImports } from '../utils/style-gather.js';\r\nimport { pathFromUrl, resolveCss, resolveUrl } from '../utils/resolve-url.js';\r\nimport { DomModule } from '../elements/dom-module.js';\r\nimport { PropertyEffects } from './property-effects.js';\r\nimport { PropertiesMixin } from './properties-mixin.js';\r\nimport { wrap } from '../utils/wrap.js';\r\n\r\n/**\r\n * Current Polymer version in Semver notation.\r\n * @type {string} Semver notation of the current version of Polymer.\r\n */\r\nexport const version = '3.5.2';\r\n\r\nexport const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\r\n\r\n/**\r\n * Element class mixin that provides the core API for Polymer's meta-programming\r\n * features including template stamping, data-binding, attribute deserialization,\r\n * and property change observation.\r\n *\r\n * Subclassers may provide the following static getters to return metadata\r\n * used to configure Polymer's features for the class:\r\n *\r\n * - `static get is()`: When the template is provided via a `dom-module`,\r\n *   users should return the `dom-module` id from a static `is` getter.  If\r\n *   no template is needed or the template is provided directly via the\r\n *   `template` getter, there is no need to define `is` for the element.\r\n *\r\n * - `static get template()`: Users may provide the template directly (as\r\n *   opposed to via `dom-module`) by implementing a static `template` getter.\r\n *   The getter must return an `HTMLTemplateElement`.\r\n *\r\n * - `static get properties()`: Should return an object describing\r\n *   property-related metadata used by Polymer features (key: property name\r\n *   value: object containing property metadata). Valid keys in per-property\r\n *   metadata include:\r\n *   - `type` (String|Number|Object|Array|...): Used by\r\n *     `attributeChangedCallback` to determine how string-based attributes\r\n *     are deserialized to JavaScript property values.\r\n *   - `notify` (boolean): Causes a change in the property to fire a\r\n *     non-bubbling event called `<property>-changed`. Elements that have\r\n *     enabled two-way binding to the property use this event to observe changes.\r\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\r\n *     To set a read-only property, use the private setter method\r\n *     `_setProperty(property, value)`.\r\n *   - `observer` (string): Observer method name that will be called when\r\n *     the property changes. The arguments of the method are\r\n *     `(value, previousValue)`.\r\n *   - `computed` (string): String describing method and dependent properties\r\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\r\n *     Computed properties are read-only by default and can only be changed\r\n *     via the return value of the computing method.\r\n *\r\n * - `static get observers()`: Array of strings describing multi-property\r\n *   observer methods and their dependent properties (e.g.\r\n *   `'observeABC(a, b, c)'`).\r\n *\r\n * The base class provides default implementations for the following standard\r\n * custom element lifecycle callbacks; users may override these, but should\r\n * call the super method to ensure\r\n * - `constructor`: Run when the element is created or upgraded\r\n * - `connectedCallback`: Run each time the element is connected to the\r\n *   document\r\n * - `disconnectedCallback`: Run each time the element is disconnected from\r\n *   the document\r\n * - `attributeChangedCallback`: Run each time an attribute in\r\n *   `observedAttributes` is set or removed (note: this element's default\r\n *   `observedAttributes` implementation will automatically return an array\r\n *   of dash-cased attributes based on `properties`)\r\n *\r\n * @mixinFunction\r\n * @polymer\r\n * @appliesMixin PropertyEffects\r\n * @appliesMixin PropertiesMixin\r\n * @property rootPath {string} Set to the value of `rootPath`,\r\n *   which defaults to the main document path\r\n * @property importPath {string} Set to the value of the class's static\r\n *   `importPath` property, which defaults to the path of this element's\r\n *   `dom-module` (when `is` is used), but can be overridden for other\r\n *   import strategies.\r\n * @summary Element class mixin that provides the core API for Polymer's\r\n * meta-programming features.\r\n * @template T\r\n * @param {function(new:T)} superClass Class to apply mixin to.\r\n * @return {function(new:T)} superClass with mixin applied.\r\n */\r\nexport const ElementMixin = dedupingMixin(base => {\r\n  /**\r\n   * @constructor\r\n   * @implements {Polymer_PropertyEffects}\r\n   * @implements {Polymer_PropertiesMixin}\r\n   * @extends {HTMLElement}\r\n   * @private\r\n   */\r\n  const polymerElementBase = PropertiesMixin(PropertyEffects(base));\r\n\r\n  /**\r\n   * Returns a list of properties with default values.\r\n   * This list is created as an optimization since it is a subset of\r\n   * the list returned from `_properties`.\r\n   * This list is used in `_initializeProperties` to set property defaults.\r\n   *\r\n   * @param {PolymerElementConstructor} constructor Element class\r\n   * @return {PolymerElementProperties} Flattened properties for this class\r\n   *   that have default values\r\n   * @private\r\n   */\r\n  function propertyDefaults(constructor) {\r\n    if (!constructor.hasOwnProperty(\r\n      JSCompiler_renameProperty('__propertyDefaults', constructor))) {\r\n      constructor.__propertyDefaults = null;\r\n      let props = constructor._properties;\r\n      for (let p in props) {\r\n        let info = props[p];\r\n        if ('value' in info) {\r\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\r\n          constructor.__propertyDefaults[p] = info;\r\n        }\r\n      }\r\n    }\r\n    return constructor.__propertyDefaults;\r\n  }\r\n\r\n  /**\r\n   * Returns a memoized version of the `observers` array.\r\n   * @param {PolymerElementConstructor} constructor Element class\r\n   * @return {Array} Array containing own observers for the given class\r\n   * @protected\r\n   */\r\n  function ownObservers(constructor) {\r\n    if (!constructor.hasOwnProperty(\r\n      JSCompiler_renameProperty('__ownObservers', constructor))) {\r\n      constructor.__ownObservers =\r\n          constructor.hasOwnProperty(\r\n              JSCompiler_renameProperty('observers', constructor)) ?\r\n          /** @type {PolymerElementConstructor} */ (constructor).observers :\r\n          null;\r\n    }\r\n    return constructor.__ownObservers;\r\n  }\r\n\r\n  /**\r\n   * Creates effects for a property.\r\n   *\r\n   * Note, once a property has been set to\r\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\r\n   * these values may not be changed. For example, a subclass cannot\r\n   * alter these settings. However, additional `observers` may be added\r\n   * by subclasses.\r\n   *\r\n   * The info object should contain property metadata as follows:\r\n   *\r\n   * * `type`: {function} type to which an attribute matching the property\r\n   * is deserialized. Note the property is camel-cased from a dash-cased\r\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\r\n   * property named 'fooBar'.\r\n   *\r\n   * * `readOnly`: {boolean} creates a readOnly property and\r\n   * makes a private setter for the private of the form '_setFoo' for a\r\n   * property 'foo',\r\n   *\r\n   * * `computed`: {string} creates a computed property. A computed property\r\n   * is also automatically set to `readOnly: true`. The value is calculated\r\n   * by running a method and arguments parsed from the given string. For\r\n   * example 'compute(foo)' will compute a given property when the\r\n   * 'foo' property changes by executing the 'compute' method. This method\r\n   * must return the computed value.\r\n   *\r\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\r\n   * to an attribute of the same name. Note, the attribute is dash-cased\r\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\r\n   *\r\n   * * `notify`: {boolean} sends a non-bubbling notification event when\r\n   * the property changes. For example, a property named 'foo' sends an\r\n   * event named 'foo-changed' with `event.detail` set to the value of\r\n   * the property.\r\n   *\r\n   * * observer: {string} name of a method that runs when the property\r\n   * changes. The arguments of the method are (value, previousValue).\r\n   *\r\n   * Note: Users may want control over modifying property\r\n   * effects via subclassing. For example, a user might want to make a\r\n   * reflectToAttribute property not do so in a subclass. We've chosen to\r\n   * disable this because it leads to additional complication.\r\n   * For example, a readOnly effect generates a special setter. If a subclass\r\n   * disables the effect, the setter would fail unexpectedly.\r\n   * Based on feedback, we may want to try to make effects more malleable\r\n   * and/or provide an advanced api for manipulating them.\r\n   *\r\n   * @param {!PolymerElement} proto Element class prototype to add accessors\r\n   *   and effects to\r\n   * @param {string} name Name of the property.\r\n   * @param {Object} info Info object from which to create property effects.\r\n   * Supported keys:\r\n   * @param {Object} allProps Flattened map of all properties defined in this\r\n   *   element (including inherited properties)\r\n   * @return {void}\r\n   * @private\r\n   */\r\n  function createPropertyFromConfig(proto, name, info, allProps) {\r\n    // computed forces readOnly...\r\n    if (info.computed) {\r\n      info.readOnly = true;\r\n    }\r\n    // Note, since all computed properties are readOnly, this prevents\r\n    // adding additional computed property effects (which leads to a confusing\r\n    // setup where multiple triggers for setting a property)\r\n    // While we do have `hasComputedEffect` this is set on the property's\r\n    // dependencies rather than itself.\r\n    if (info.computed) {\r\n      if (proto._hasReadOnlyEffect(name)) {\r\n        console.warn(`Cannot redefine computed property '${name}'.`);\r\n      } else {\r\n        proto._createComputedProperty(name, info.computed, allProps);\r\n      }\r\n    }\r\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\r\n      proto._createReadOnlyProperty(name, !info.computed);\r\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\r\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\r\n    }\r\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\r\n      proto._createReflectedProperty(name);\r\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\r\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\r\n    }\r\n    if (info.notify && !proto._hasNotifyEffect(name)) {\r\n      proto._createNotifyingProperty(name);\r\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\r\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\r\n    }\r\n    // always add observer\r\n    if (info.observer) {\r\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\r\n    }\r\n    // always create the mapping from attribute back to property for deserialization.\r\n    proto._addPropertyToAttributeMap(name);\r\n  }\r\n\r\n  /**\r\n   * Process all style elements in the element template. Styles with the\r\n   * `include` attribute are processed such that any styles in\r\n   * the associated \"style modules\" are included in the element template.\r\n   * @param {PolymerElementConstructor} klass Element class\r\n   * @param {!HTMLTemplateElement} template Template to process\r\n   * @param {string} is Name of element\r\n   * @param {string} baseURI Base URI for element\r\n   * @private\r\n   */\r\n  function processElementStyles(klass, template, is, baseURI) {\r\n    if (!builtCSS) {\r\n      const templateStyles = template.content.querySelectorAll('style');\r\n      const stylesWithImports = stylesFromTemplate(template);\r\n      // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\r\n      const linkedStyles = stylesFromModuleImports(is);\r\n      const firstTemplateChild = template.content.firstElementChild;\r\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\r\n        let s = linkedStyles[idx];\r\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\r\n        template.content.insertBefore(s, firstTemplateChild);\r\n      }\r\n      // keep track of the last \"concrete\" style in the template we have encountered\r\n      let templateStyleIndex = 0;\r\n      // ensure all gathered styles are actually in this template.\r\n      for (let i = 0; i < stylesWithImports.length; i++) {\r\n        let s = stylesWithImports[i];\r\n        let templateStyle = templateStyles[templateStyleIndex];\r\n        // if the style is not in this template, it's been \"included\" and\r\n        // we put a clone of it in the template before the style that included it\r\n        if (templateStyle !== s) {\r\n          s = s.cloneNode(true);\r\n          templateStyle.parentNode.insertBefore(s, templateStyle);\r\n        } else {\r\n          templateStyleIndex++;\r\n        }\r\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\r\n      }\r\n    }\r\n    if (window.ShadyCSS) {\r\n      window.ShadyCSS.prepareTemplate(template, is);\r\n    }\r\n    // Support for `adoptedStylesheets` relies on using native Shadow DOM\r\n    // and built CSS. Built CSS is required because runtime transformation of\r\n    // `@apply` is not supported. This is because ShadyCSS relies on being able\r\n    // to update a `style` element in the element template and this is\r\n    // removed when using `adoptedStyleSheets`.\r\n    // Note, it would be more efficient to allow style includes to become\r\n    // separate stylesheets; however, because of `@apply` these are\r\n    // potentially not shareable and sharing the ones that could be shared\r\n    // would require some coordination. To keep it simple, all the includes\r\n    // and styles are collapsed into a single shareable stylesheet.\r\n    if (useAdoptedStyleSheetsWithBuiltCSS && builtCSS &&\r\n        supportsAdoptingStyleSheets) {\r\n      // Remove styles in template and make a shareable stylesheet\r\n      const styles = template.content.querySelectorAll('style');\r\n      if (styles) {\r\n        let css = '';\r\n        Array.from(styles).forEach(s => {\r\n          css += s.textContent;\r\n          s.parentNode.removeChild(s);\r\n        });\r\n        klass._styleSheet = new CSSStyleSheet();\r\n        klass._styleSheet.replaceSync(css);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Look up template from dom-module for element\r\n   *\r\n   * @param {string} is Element name to look up\r\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\r\n   *   undefined if not found\r\n   * @protected\r\n   */\r\n  function getTemplateFromDomModule(is) {\r\n    let template = null;\r\n    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\r\n    // when opted-in via allowTemplateFromDomModule\r\n    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {\r\n      template = /** @type {?HTMLTemplateElement} */ (\r\n          DomModule.import(is, 'template'));\r\n      // Under strictTemplatePolicy, require any element with an `is`\r\n      // specified to have a dom-module\r\n      if (strictTemplatePolicy && !template) {\r\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\r\n      }\r\n    }\r\n    return template;\r\n  }\r\n\r\n  /**\r\n   * @polymer\r\n   * @mixinClass\r\n   * @unrestricted\r\n   * @implements {Polymer_ElementMixin}\r\n   * @extends {polymerElementBase}\r\n   */\r\n  class PolymerElement extends polymerElementBase {\r\n\r\n    /**\r\n     * Current Polymer version in Semver notation.\r\n     * @type {string} Semver notation of the current version of Polymer.\r\n     * @nocollapse\r\n     */\r\n    static get polymerElementVersion() {\r\n      return version;\r\n    }\r\n\r\n    /**\r\n     * Override of PropertiesMixin _finalizeClass to create observers and\r\n     * find the template.\r\n     * @return {void}\r\n     * @protected\r\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\r\n     * @nocollapse\r\n     */\r\n    static _finalizeClass() {\r\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\r\n      //     Change back to just super.methodCall()\r\n      polymerElementBase._finalizeClass.call(this);\r\n      const observers = ownObservers(this);\r\n      if (observers) {\r\n        this.createObservers(observers, this._properties);\r\n      }\r\n      this._prepareTemplate();\r\n    }\r\n\r\n    /** @nocollapse */\r\n    static _prepareTemplate() {\r\n      // note: create \"working\" template that is finalized at instance time\r\n      let template = /** @type {PolymerElementConstructor} */ (this).template;\r\n      if (template) {\r\n        if (typeof template === 'string') {\r\n          console.error('template getter must return HTMLTemplateElement');\r\n          template = null;\r\n        } else if (!legacyOptimizations) {\r\n          template = template.cloneNode(true);\r\n        }\r\n      }\r\n\r\n      /** @override */\r\n      this.prototype._template = template;\r\n    }\r\n\r\n    /**\r\n     * Override of PropertiesChanged createProperties to create accessors\r\n     * and property effects for all of the properties.\r\n     * @param {!Object} props .\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createProperties(props) {\r\n      for (let p in props) {\r\n        createPropertyFromConfig(\r\n            /** @type {?} */ (this.prototype), p, props[p], props);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Creates observers for the given `observers` array.\r\n     * Leverages `PropertyEffects` to create observers.\r\n     * @param {Object} observers Array of observer descriptors for\r\n     *   this class\r\n     * @param {Object} dynamicFns Object containing keys for any properties\r\n     *   that are functions and should trigger the effect when the function\r\n     *   reference is changed\r\n     * @return {void}\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static createObservers(observers, dynamicFns) {\r\n      const proto = this.prototype;\r\n      for (let i=0; i < observers.length; i++) {\r\n        proto._createMethodObserver(observers[i], dynamicFns);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns the template that will be stamped into this element's shadow root.\r\n     *\r\n     * If a `static get is()` getter is defined, the default implementation will\r\n     * return the first `<template>` in a `dom-module` whose `id` matches this\r\n     * element's `is` (note that a `_template` property on the class prototype\r\n     * takes precedence over the `dom-module` template, to maintain legacy\r\n     * element semantics; a subclass will subsequently fall back to its super\r\n     * class template if neither a `prototype._template` or a `dom-module` for\r\n     * the class's `is` was found).\r\n     *\r\n     * Users may override this getter to return an arbitrary template\r\n     * (in which case the `is` getter is unnecessary). The template returned\r\n     * must be an `HTMLTemplateElement`.\r\n     *\r\n     * Note that when subclassing, if the super class overrode the default\r\n     * implementation and the subclass would like to provide an alternate\r\n     * template via a `dom-module`, it should override this getter and\r\n     * return `DomModule.import(this.is, 'template')`.\r\n     *\r\n     * If a subclass would like to modify the super class template, it should\r\n     * clone it rather than modify it in place.  If the getter does expensive\r\n     * work such as cloning/modifying a template, it should memoize the\r\n     * template for maximum performance:\r\n     *\r\n     *   let memoizedTemplate;\r\n     *   class MySubClass extends MySuperClass {\r\n     *     static get template() {\r\n     *       if (!memoizedTemplate) {\r\n     *         memoizedTemplate = super.template.cloneNode(true);\r\n     *         let subContent = document.createElement('div');\r\n     *         subContent.textContent = 'This came from MySubClass';\r\n     *         memoizedTemplate.content.appendChild(subContent);\r\n     *       }\r\n     *       return memoizedTemplate;\r\n     *     }\r\n     *   }\r\n     *\r\n     * @return {!HTMLTemplateElement|string} Template to be stamped\r\n     * @nocollapse\r\n     */\r\n    static get template() {\r\n      // Explanation of template-related properties:\r\n      // - constructor.template (this getter): the template for the class.\r\n      //     This can come from the prototype (for legacy elements), from a\r\n      //     dom-module, or from the super class's template (or can be overridden\r\n      //     altogether by the user)\r\n      // - constructor._template: memoized version of constructor.template\r\n      // - prototype._template: working template for the element, which will be\r\n      //     parsed and modified in place. It is a cloned version of\r\n      //     constructor.template, saved in _finalizeClass(). Note that before\r\n      //     this getter is called, for legacy elements this could be from a\r\n      //     _template field on the info object passed to Polymer(), a behavior,\r\n      //     or set in registered(); once the static getter runs, a clone of it\r\n      //     will overwrite it on the prototype as the working template.\r\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\r\n        let protoTemplate = this.prototype.hasOwnProperty(\r\n          JSCompiler_renameProperty('_template', this.prototype)) ?\r\n          this.prototype._template : undefined;\r\n        // Accept a function for the legacy Polymer({_template:...}) field for\r\n        // lazy parsing\r\n        if (typeof protoTemplate === 'function') {\r\n          protoTemplate = protoTemplate();\r\n        }\r\n        this._template =\r\n          // If user has put template on prototype (e.g. in legacy via registered\r\n          // callback or info object), prefer that first. Note that `null` is\r\n          // used as a sentinel to indicate \"no template\" and can be used to\r\n          // override a super template, whereas `undefined` is used as a\r\n          // sentinel to mean \"fall-back to default template lookup\" via\r\n          // dom-module and/or super.template.\r\n          protoTemplate !== undefined ? protoTemplate :\r\n          // Look in dom-module associated with this element's is\r\n          ((this.hasOwnProperty(JSCompiler_renameProperty('is', this)) &&\r\n          (getTemplateFromDomModule(/** @type {PolymerElementConstructor}*/ (this).is))) ||\r\n          // Next look for superclass template (call the super impl this\r\n          // way so that `this` points to the superclass)\r\n          Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.template);\r\n      }\r\n      return this._template;\r\n    }\r\n\r\n    /**\r\n     * Set the template.\r\n     *\r\n     * @param {!HTMLTemplateElement|string} value Template to set.\r\n     * @nocollapse\r\n     */\r\n    static set template(value) {\r\n      this._template = value;\r\n    }\r\n\r\n    /**\r\n     * Path matching the url from which the element was imported.\r\n     *\r\n     * This path is used to resolve url's in template style cssText.\r\n     * The `importPath` property is also set on element instances and can be\r\n     * used to create bindings relative to the import path.\r\n     *\r\n     * For elements defined in ES modules, users should implement\r\n     * `static get importMeta() { return import.meta; }`, and the default\r\n     * implementation of `importPath` will  return `import.meta.url`'s path.\r\n     * For elements defined in HTML imports, this getter will return the path\r\n     * to the document containing a `dom-module` element matching this\r\n     * element's static `is` property.\r\n     *\r\n     * Note, this path should contain a trailing `/`.\r\n     *\r\n     * @return {string} The import path for this element class\r\n     * @suppress {missingProperties}\r\n     * @nocollapse\r\n     */\r\n    static get importPath() {\r\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\r\n        const meta = this.importMeta;\r\n        if (meta) {\r\n          this._importPath = pathFromUrl(meta.url);\r\n        } else {\r\n          const module = DomModule.import(/** @type {PolymerElementConstructor} */ (this).is);\r\n          this._importPath = (module && module.assetpath) ||\r\n            Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.importPath;\r\n        }\r\n      }\r\n      return this._importPath;\r\n    }\r\n\r\n    constructor() {\r\n      super();\r\n      /** @type {HTMLTemplateElement} */\r\n      this._template;\r\n      /** @type {string} */\r\n      this._importPath;\r\n      /** @type {string} */\r\n      this.rootPath;\r\n      /** @type {string} */\r\n      this.importPath;\r\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\r\n      this.root;\r\n      /** @type {!Object<string, !Element>} */\r\n      this.$;\r\n    }\r\n\r\n    /**\r\n     * Overrides the default `PropertyAccessors` to ensure class\r\n     * metaprogramming related to property accessors and effects has\r\n     * completed (calls `finalize`).\r\n     *\r\n     * It also initializes any property defaults provided via `value` in\r\n     * `properties` metadata.\r\n     *\r\n     * @return {void}\r\n     * @override\r\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\r\n     */\r\n    _initializeProperties() {\r\n      this.constructor.finalize();\r\n      // note: finalize template when we have access to `localName` to\r\n      // avoid dependence on `is` for polyfilling styling.\r\n      this.constructor._finalizeTemplate(/** @type {!HTMLElement} */(this).localName);\r\n      super._initializeProperties();\r\n      // set path defaults\r\n      this.rootPath = rootPath;\r\n      this.importPath = this.constructor.importPath;\r\n      // apply property defaults...\r\n      let p$ = propertyDefaults(this.constructor);\r\n      if (!p$) {\r\n        return;\r\n      }\r\n      for (let p in p$) {\r\n        let info = p$[p];\r\n        if (this._canApplyPropertyDefault(p)) {\r\n          let value = typeof info.value == 'function' ?\r\n            info.value.call(this) :\r\n            info.value;\r\n          // Set via `_setProperty` if there is an accessor, to enable\r\n          // initializing readOnly property defaults\r\n          if (this._hasAccessor(p)) {\r\n            this._setPendingProperty(p, value, true);\r\n          } else {\r\n            this[p] = value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Determines if a property dfeault can be applied. For example, this\r\n     * prevents a default from being applied when a property that has no\r\n     * accessor is overridden by its host before upgrade (e.g. via a binding).\r\n     * @override\r\n     * @param {string} property Name of the property\r\n     * @return {boolean} Returns true if the property default can be applied.\r\n     */\r\n    _canApplyPropertyDefault(property) {\r\n      return !this.hasOwnProperty(property);\r\n    }\r\n\r\n    /**\r\n     * Gather style text for a style element in the template.\r\n     *\r\n     * @param {string} cssText Text containing styling to process\r\n     * @param {string} baseURI Base URI to rebase CSS paths against\r\n     * @return {string} The processed CSS text\r\n     * @protected\r\n     * @nocollapse\r\n     */\r\n    static _processStyleText(cssText, baseURI) {\r\n      return resolveCss(cssText, baseURI);\r\n    }\r\n\r\n    /**\r\n    * Configures an element `proto` to function with a given `template`.\r\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\r\n    * style scoping.\r\n    *\r\n    * @param {string} is Tag name (or type extension name) for this element\r\n    * @return {void}\r\n    * @protected\r\n    * @nocollapse\r\n    */\r\n    static _finalizeTemplate(is) {\r\n      /** @const {HTMLTemplateElement} */\r\n      const template = this.prototype._template;\r\n      if (template && !template.__polymerFinalized) {\r\n        template.__polymerFinalized = true;\r\n        const importPath = this.importPath;\r\n        const baseURI = importPath ? resolveUrl(importPath) : '';\r\n        // e.g. support `include=\"module-name\"`, and ShadyCSS\r\n        processElementStyles(this, template, is, baseURI);\r\n        this.prototype._bindTemplate(template);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Provides a default implementation of the standard Custom Elements\r\n     * `connectedCallback`.\r\n     *\r\n     * The default implementation enables the property effects system and\r\n     * flushes any pending properties, and updates shimmed CSS properties\r\n     * when using the ShadyCSS scoping/custom properties polyfill.\r\n     *\r\n     * @override\r\n     * @suppress {missingProperties, invalidCasts} Super may or may not\r\n     *     implement the callback\r\n     * @return {void}\r\n     */\r\n    connectedCallback() {\r\n      if (window.ShadyCSS && this._template) {\r\n        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));\r\n      }\r\n      super.connectedCallback();\r\n    }\r\n\r\n    /**\r\n     * Stamps the element template.\r\n     *\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    ready() {\r\n      if (this._template) {\r\n        this.root = this._stampTemplate(this._template);\r\n        this.$ = this.root.$;\r\n      }\r\n      super.ready();\r\n    }\r\n\r\n    /**\r\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\r\n     * element dom by calling `_attachDom` with the dom stamped from the\r\n     * element's template via `_stampTemplate`. Note that this allows\r\n     * client dom to be attached to the element prior to any observers\r\n     * running.\r\n     *\r\n     * @return {void}\r\n     * @override\r\n     */\r\n    _readyClients() {\r\n      if (this._template) {\r\n        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));\r\n      }\r\n      // The super._readyClients here sets the clients initialized flag.\r\n      // We must wait to do this until after client dom is created/attached\r\n      // so that this flag can be checked to prevent notifications fired\r\n      // during this process from being handled before clients are ready.\r\n      super._readyClients();\r\n    }\r\n\r\n\r\n    /**\r\n     * Attaches an element's stamped dom to itself. By default,\r\n     * this method creates a `shadowRoot` and adds the dom to it.\r\n     * However, this method may be overridden to allow an element\r\n     * to put its dom in another location.\r\n     *\r\n     * @override\r\n     * @throws {Error}\r\n     * @suppress {missingReturn}\r\n     * @param {StampedTemplate} dom to attach to the element.\r\n     * @return {ShadowRoot} node to which the dom has been attached.\r\n     */\r\n    _attachDom(dom) {\r\n      const n = wrap(this);\r\n      if (n.attachShadow) {\r\n        if (dom) {\r\n          if (!n.shadowRoot) {\r\n            n.attachShadow({mode: 'open', shadyUpgradeFragment: dom});\r\n            n.shadowRoot.appendChild(dom);\r\n            // When `adoptedStyleSheets` is supported a stylesheet is made\r\n            // available on the element constructor.\r\n            if (this.constructor._styleSheet) {\r\n              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];\r\n            }\r\n          }\r\n          if (syncInitialRender && window.ShadyDOM) {\r\n            window.ShadyDOM.flushInitial(n.shadowRoot);\r\n          }\r\n          return n.shadowRoot;\r\n        }\r\n        return null;\r\n      } else {\r\n        throw new Error('ShadowDOM not available. ' +\r\n          // TODO(sorvell): move to compile-time conditional when supported\r\n        'PolymerElement can create dom as children instead of in ' +\r\n        'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\r\n      }\r\n    }\r\n\r\n    /**\r\n     * When using the ShadyCSS scoping and custom property shim, causes all\r\n     * shimmed styles in this element (and its subtree) to be updated\r\n     * based on current custom property values.\r\n     *\r\n     * The optional parameter overrides inline custom property styles with an\r\n     * object of properties where the keys are CSS properties, and the values\r\n     * are strings.\r\n     *\r\n     * Example: `this.updateStyles({'--color': 'blue'})`\r\n     *\r\n     * These properties are retained unless a value of `null` is set.\r\n     *\r\n     * Note: This function does not support updating CSS mixins.\r\n     * You can not dynamically change the value of an `@apply`.\r\n     *\r\n     * @override\r\n     * @param {Object=} properties Bag of custom property key/values to\r\n     *   apply to this element.\r\n     * @return {void}\r\n     * @suppress {invalidCasts}\r\n     */\r\n    updateStyles(properties) {\r\n      if (window.ShadyCSS) {\r\n        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\r\n     * the original location of the document containing the `dom-module` for\r\n     * this element. This method will return the same URL before and after\r\n     * bundling.\r\n     *\r\n     * Note that this function performs no resolution for URLs that start\r\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\r\n     * URL resolution, use `window.URL`.\r\n     *\r\n     * @override\r\n     * @param {string} url URL to resolve.\r\n     * @param {string=} base Optional base URL to resolve against, defaults\r\n     * to the element's `importPath`\r\n     * @return {string} Rewritten URL relative to base\r\n     */\r\n    resolveUrl(url, base) {\r\n      if (!base && this.importPath) {\r\n        base = resolveUrl(this.importPath);\r\n      }\r\n      return resolveUrl(url, base);\r\n    }\r\n\r\n    /**\r\n     * Overrides `PropertyEffects` to add map of dynamic functions on\r\n     * template info, for consumption by `PropertyEffects` template binding\r\n     * code. This map determines which method templates should have accessors\r\n     * created for them.\r\n     *\r\n     * @param {!HTMLTemplateElement} template Template\r\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\r\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\r\n     * @return {boolean} .\r\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\r\n     * @nocollapse\r\n     */\r\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\r\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\r\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\r\n      //     Change back to just super.methodCall()\r\n      return polymerElementBase._parseTemplateContent.call(\r\n        this, template, templateInfo, nodeInfo);\r\n    }\r\n\r\n    /**\r\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\r\n     * template.\r\n     *\r\n     * @param {Object} templateInfo Template metadata to add effect to\r\n     * @param {string} prop Property that should trigger the effect\r\n     * @param {Object=} effect Effect metadata object\r\n     * @return {void}\r\n     * @protected\r\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\r\n     * @nocollapse\r\n     */\r\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\r\n      // Warn if properties are used in template without being declared.\r\n      // Properties must be listed in `properties` to be included in\r\n      // `observedAttributes` since CE V1 reads that at registration time, and\r\n      // since we want to keep template parsing lazy, we can't automatically\r\n      // add undeclared properties used in templates to `observedAttributes`.\r\n      // The warning is only enabled in `legacyOptimizations` mode, since\r\n      // we don't want to spam existing users who might have adopted the\r\n      // shorthand when attribute deserialization is not important.\r\n      if (legacyWarnings && !(prop in this._properties) &&\r\n          // Methods used in templates with no dependencies (or only literal\r\n          // dependencies) become accessors with template effects; ignore these\r\n          !(effect.info.part.signature && effect.info.part.signature.static) &&\r\n          // Warnings for bindings added to nested templates are handled by\r\n          // templatizer so ignore both the host-to-template bindings\r\n          // (`hostProp`) and TemplateInstance-to-child bindings\r\n          // (`nestedTemplate`)\r\n          !effect.info.part.hostProp && !templateInfo.nestedTemplate) {\r\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` +\r\n          `attribute will not be observed.`);\r\n      }\r\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\r\n      //     Change back to just super.methodCall()\r\n      return polymerElementBase._addTemplatePropertyEffect.call(\r\n        this, templateInfo, prop, effect);\r\n    }\r\n\r\n  }\r\n\r\n  return PolymerElement;\r\n});\r\n\r\n/**\r\n * When using the ShadyCSS scoping and custom property shim, causes all\r\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\r\n * to be updated based on current custom property values.\r\n *\r\n * The optional parameter overrides inline custom property styles with an\r\n * object of properties where the keys are CSS properties, and the values\r\n * are strings.\r\n *\r\n * Example: `updateStyles({'--color': 'blue'})`\r\n *\r\n * These properties are retained unless a value of `null` is set.\r\n *\r\n * @param {Object=} props Bag of custom property key/values to\r\n *   apply to the document.\r\n * @return {void}\r\n */\r\nexport const updateStyles = function(props) {\r\n  if (window.ShadyCSS) {\r\n    window.ShadyCSS.styleDocument(props);\r\n  }\r\n};\r\n", "/**\r\n@license\r\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\nimport { ElementMixin, version } from './lib/mixins/element-mixin.js';\r\nexport { html } from './lib/utils/html-tag.js';\r\n\r\nexport { version };\r\n\r\n/**\r\n * Base class that provides the core API for Polymer's meta-programming\r\n * features including template stamping, data-binding, attribute deserialization,\r\n * and property change observation.\r\n *\r\n * @customElement\r\n * @polymer\r\n * @constructor\r\n * @implements {Polymer_ElementMixin}\r\n * @extends HTMLElement\r\n * @appliesMixin ElementMixin\r\n * @summary Custom element base class that provides the core API for Polymer's\r\n *   key meta-programming features including template stamping, data-binding,\r\n *   attribute deserialization, and property change observation\r\n */\r\nexport const PolymerElement = ElementMixin(HTMLElement);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBO,IAAM,OAAQ,OAAO,UAAU,KAAK,OAAO,UAAU,EAAE,SAAS,KAAK,OAAO,UAAU,EAAE,MAAM,IACnG,OAAO,UAAU,EAAE,MAAM,IACxB,OAAO,UAAU,IAAI,CAAC,MAAM,SAAS,OAAO,EAAE,CAAC,IAAI,CAAC,MAAM;;;ACQtD,SAAS,OAAO,MAAM;AAC3B,SAAO,KAAK,QAAQ,GAAG,KAAK;AAC9B;AAeO,SAAS,KAAK,MAAM;AACzB,MAAI,WAAW,KAAK,QAAQ,GAAG;AAC/B,MAAI,aAAa,IAAI;AACnB,WAAO;AAAA,EACT;AACA,SAAO,KAAK,MAAM,GAAG,QAAQ;AAC/B;AAkBO,SAAS,WAAW,MAAM,MAAM;AAErC,SAAO,KAAK,QAAQ,OAAO,GAAG,MAAM;AACtC;AAiBO,SAAS,aAAa,MAAM,MAAM;AAEvC,SAAO,KAAK,QAAQ,OAAO,GAAG,MAAM;AACtC;AAmBO,SAAS,UAAU,MAAM,SAAS,MAAM;AAC7C,SAAO,UAAU,KAAK,MAAM,KAAK,MAAM;AACzC;AAOO,SAAS,QAAQ,MAAM,MAAM;AAClC,SAAQ,SAAS,QACV,WAAW,MAAM,IAAI,KACrB,aAAa,MAAM,IAAI;AAChC;AAgBO,SAAS,UAAU,MAAM;AAC9B,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,QAAI,QAAQ,CAAC;AACb,aAAS,IAAE,GAAG,IAAE,KAAK,QAAQ,KAAK;AAChC,UAAI,OAAO,KAAK,CAAC,EAAE,SAAS,EAAE,MAAM,GAAG;AACvC,eAAS,IAAE,GAAG,IAAE,KAAK,QAAQ,KAAK;AAChC,cAAM,KAAK,KAAK,CAAC,CAAC;AAAA,MACpB;AAAA,IACF;AACA,WAAO,MAAM,KAAK,GAAG;AAAA,EACvB,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAiBO,SAAS,MAAM,MAAM;AAC1B,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,WAAO,UAAU,IAAI,EAAE,MAAM,GAAG;AAAA,EAClC;AACA,SAAO,KAAK,SAAS,EAAE,MAAM,GAAG;AAClC;AAaO,SAAS,IAAIA,OAAM,MAAM,MAAM;AACpC,MAAI,OAAOA;AACX,MAAI,QAAQ,MAAM,IAAI;AAEtB,WAAS,IAAE,GAAG,IAAE,MAAM,QAAQ,KAAK;AACjC,QAAI,CAAC,MAAM;AACT;AAAA,IACF;AACA,QAAI,OAAO,MAAM,CAAC;AAClB,WAAO,KAAK,IAAI;AAAA,EAClB;AACA,MAAI,MAAM;AACR,SAAK,OAAO,MAAM,KAAK,GAAG;AAAA,EAC5B;AACA,SAAO;AACT;AAWO,SAAS,IAAIA,OAAM,MAAM,OAAO;AACrC,MAAI,OAAOA;AACX,MAAI,QAAQ,MAAM,IAAI;AACtB,MAAI,OAAO,MAAM,MAAM,SAAO,CAAC;AAC/B,MAAI,MAAM,SAAS,GAAG;AAEpB,aAAS,IAAE,GAAG,IAAE,MAAM,SAAO,GAAG,KAAK;AACnC,UAAI,OAAO,MAAM,CAAC;AAClB,aAAO,KAAK,IAAI;AAChB,UAAI,CAAC,MAAM;AACT;AAAA,MACF;AAAA,IACF;AAEA,SAAK,IAAI,IAAI;AAAA,EACf,OAAO;AAEL,SAAK,IAAI,IAAI;AAAA,EACf;AACA,SAAO,MAAM,KAAK,GAAG;AACvB;;;ACjOA,IAAM,UAAU,CAAC;AACjB,IAAM,gBAAgB;AACtB,IAAM,gBAAgB;AAcf,SAAS,gBAAgB,MAAM;AACpC,SAAO,QAAQ,IAAI,MACjB,QAAQ,IAAI,IAAI,KAAK,QAAQ,GAAG,IAAI,IAAI,OAAO,KAAK;AAAA,IAAQ;AAAA,IAC1D,CAAC,MAAM,EAAE,CAAC,EAAE,YAAY;AAAA,EAC1B;AAEJ;AASO,SAAS,gBAAgB,OAAO;AACrC,SAAO,QAAQ,KAAK,MAClB,QAAQ,KAAK,IAAI,MAAM,QAAQ,eAAe,KAAK,EAAE,YAAY;AAErE;;;AC9BA,IAAM,YAAY;AAuBX,IAAM,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM7B,CAAC,eAAe;AAAA,IAQlB,MAAMC,2BAA0B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASzC,OAAO,iBAAiB,OAAO;AAC7B,cAAMC,SAAQ,KAAK;AACnB,iBAAS,QAAQ,OAAO;AAEtB,cAAI,EAAE,QAAQA,SAAQ;AACpB,YAAAA,OAAM,wBAAwB,IAAI;AAAA,UACpC;AAAA,QACF;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYA,OAAO,yBAAyB,UAAU;AACxC,eAAO,SAAS,YAAY;AAAA,MAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUA,OAAO,gBAAgB,MAAM;AAAA,MAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAmB/B,wBAAwB,UAAU,UAAU;AAC1C,aAAK,2BAA2B,QAAQ;AACxC,YAAI,CAAC,KAAK,eAAe,0BAA0B,qBAAqB,IAAI,CAAC,GAAG;AAC9E,eAAK,oBAAoB,OAAO,OAAO,CAAC,GAAG,KAAK,iBAAiB;AAAA,QACnE;AACA,YAAI,CAAC,KAAK,kBAAkB,QAAQ,GAAG;AACrC,eAAK,kBAAkB,QAAQ,IAAI;AACnC,eAAK,wBAAwB,UAAU,QAAQ;AAAA,QACjD;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUA,2BAA2B,UAAU;AACnC,YAAI,CAAC,KAAK,eAAe,0BAA0B,oBAAoB,IAAI,CAAC,GAAG;AAC7E,eAAK,mBAAmB,OAAO,OAAO,CAAC,GAAG,KAAK,gBAAgB;AAAA,QACjE;AAOA,YAAI,OAAO,KAAK,iBAAiB,QAAQ;AACzC,YAAI,CAAC,MAAM;AACT,iBAAO,KAAK,YAAY,yBAAyB,QAAQ;AACzD,eAAK,iBAAiB,IAAI,IAAI;AAAA,QAChC;AACA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASC,wBAAwB,UAAU,UAAU;AAC3C,eAAO,eAAe,MAAM,UAAU;AAAA;AAAA;AAAA,UAGpC,MAAM;AAEJ,mBAAO,KAAK,OAAO,QAAQ;AAAA,UAC7B;AAAA;AAAA,UAEA,KAAK,WAAW,WAAY;AAAA,UAAC,IAAI,SAAU,OAAO;AAEhD,gBAAI,KAAK,oBAAoB,UAAU,OAAO,IAAI,GAAG;AACnD,mBAAK,sBAAsB;AAAA,YAC7B;AAAA,UACF;AAAA;AAAA,QAEF,CAAC;AAAA,MACH;AAAA,MAEA,cAAc;AACZ,cAAM;AAEN,aAAK,gBAAgB;AACrB,aAAK,cAAc;AACnB,aAAK,gBAAgB;AACrB,aAAK,SAAS,CAAC;AACf,aAAK,gBAAgB;AACrB,aAAK,YAAY;AACjB,aAAK,sBAAsB;AAG3B,aAAK,gBAAgB;AACrB,aAAK,gBAAgB;AACrB,aAAK,sBAAsB;AAAA,MAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAiBA,QAAQ;AACN,aAAK,cAAc;AACnB,aAAK,iBAAiB;AAAA,MACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYA,wBAAwB;AAItB,iBAAS,KAAK,KAAK,mBAAmB;AACpC,cAAI,KAAK,eAAe,CAAC,GAAG;AAC1B,iBAAK,sBAAsB,KAAK,uBAAuB,CAAC;AACxD,iBAAK,oBAAoB,CAAC,IAAI,KAAK,CAAC;AACpC,mBAAO,KAAK,CAAC;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAgBA,8BAA8B,OAAO;AACnC,eAAO,OAAO,MAAM,KAAK;AAAA,MAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYA,aAAa,UAAU,OAAO;AAC5B,YAAI,KAAK,oBAAoB,UAAU,KAAK,GAAG;AAC7C,eAAK,sBAAsB;AAAA,QAC7B;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASA,aAAa,UAAU;AACrB,eAAO,KAAK,OAAO,QAAQ;AAAA,MAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAgBA,oBAAoB,UAAU,OAAO,KAAK;AACxC,YAAI,MAAM,KAAK,OAAO,QAAQ;AAC9B,YAAI,UAAU,KAAK,sBAAsB,UAAU,OAAO,GAAG;AAC7D,YAAI,SAAS;AACX,cAAI,CAAC,KAAK,eAAe;AACvB,iBAAK,gBAAgB,CAAC;AACtB,iBAAK,YAAY,CAAC;AAAA,UACpB;AAEA,cAAI,KAAK,aAAa,EAAE,YAAY,KAAK,YAAY;AACnD,iBAAK,UAAU,QAAQ,IAAI;AAAA,UAC7B;AACA,eAAK,OAAO,QAAQ,IAAI;AACxB,eAAK,cAAc,QAAQ,IAAI;AAAA,QACjC;AACA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,mBAAmB,UAAU;AAC3B,eAAO,CAAC,EAAE,KAAK,iBAAiB,KAAK,cAAc,eAAe,QAAQ;AAAA,MAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUA,wBAAwB;AACtB,YAAI,CAAC,KAAK,iBAAiB,KAAK,aAAa;AAC3C,eAAK,gBAAgB;AACrB,oBAAU,IAAI,MAAM;AAClB,gBAAI,KAAK,eAAe;AACtB,mBAAK,gBAAgB;AACrB,mBAAK,iBAAiB;AAAA,YACxB;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAcA,oBAAoB;AAClB,YAAI,CAAC,KAAK,eAAe;AACvB,eAAK,gBAAgB;AACrB,cAAI,KAAK,qBAAqB;AAC5B,iBAAK,8BAA8B,KAAK,mBAAmB;AAC3D,iBAAK,sBAAsB;AAAA,UAC7B;AACA,eAAK,MAAM;AAAA,QACb;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYA,mBAAmB;AACjB,aAAK;AACL,cAAM,QAAQ,KAAK;AACnB,cAAM,eAAe,KAAK;AAC1B,cAAM,MAAM,KAAK;AACjB,YAAI,KAAK,wBAAwB,OAAO,cAAc,GAAG,GAAG;AAC1D,eAAK,gBAAgB;AACrB,eAAK,YAAY;AACjB,eAAK,mBAAmB,OAAO,cAAc,GAAG;AAAA,QAClD;AACA,aAAK;AAAA,MACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAeA,wBAAwB,cAAc,cAAc,UAAU;AAC5D,eAAO,QAAQ,YAAY;AAAA,MAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAeA,mBAAmB,cAAc,cAAc,UAAU;AAAA,MACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAqBA,sBAAsB,UAAU,OAAO,KAAK;AAC1C;AAAA;AAAA,UAEG,QAAQ;AAAA,WAEN,QAAQ,OAAO,UAAU;AAAA;AAAA,MAEhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAcA,yBAAyB,MAAM,KAAK,OAAO,WAAW;AACpD,YAAI,QAAQ,OAAO;AACjB,eAAK,qBAAqB,MAAM,KAAK;AAAA,QACvC;AACA,YAAI,MAAM,0BAA0B;AAClC,gBAAM,yBAAyB,MAAM,KAAK,OAAO,SAAS;AAAA,QAC5D;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAeA,qBAAqB,WAAW,OAAO,MAAM;AAC3C,YAAI,CAAC,KAAK,eAAe;AACvB,gBAAM,MAAM,KAAK;AACjB,gBAAM,WAAW,OAAO,IAAI,SAAS,KAAK;AAC1C,eAAK,QAAQ,IAAI,KAAK,kBAAkB,OAAO,QAC7C,KAAK,YAAY,gBAAgB,QAAQ,CAAC;AAAA,QAC9C;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAaA,qBAAqB,UAAU,WAAW,OAAO;AAC/C,aAAK,gBAAgB;AACrB,gBAAS,UAAU,SAAS,IAAK,KAAK,QAAQ,IAAI;AAClD,aAAK;AAAA;AAAA,UAAkD;AAAA,UAAO;AAAA,UAC5D,aAAa,KAAK,YAAY,yBAAyB,QAAQ;AAAA,QAAC;AAClE,aAAK,gBAAgB;AAAA,MACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAgBA,sBAAsB,MAAM,OAAO,WAAW;AAC5C,cAAM,MAAM,KAAK,gBAAgB,KAAK;AACtC,YAAI,cAAc,WAAW,cAAc,UAAU,cAAc,QAAQ;AACzE;AAAA,UAA+B,KAAK,IAAI;AAAA,QAC1C;AACA,YAAI,QAAQ,QAAW;AACrB,eAAK,gBAAgB,SAAS;AAAA,QAChC,OAAO;AACL,eAAK;AAAA,YACD;AAAA;AAAA;AAAA,YAGC,QAAQ,MAAM,OAAO;AAAA;AAAA,cACA,OAAO,aAAa;AAAA,gBACtC;AAAA,UAAG;AAAA,QACb;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAcA,gBAAgB,OAAO;AACrB,gBAAQ,OAAO,OAAO;AAAA,UACpB,KAAK;AACH,mBAAO,QAAQ,KAAK;AAAA,UACtB;AACE,mBAAO,SAAS,OAAO,MAAM,SAAS,IAAI;AAAA,QAC9C;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAeA,kBAAkB,OAAO,MAAM;AAC7B,gBAAQ,MAAM;AAAA,UACZ,KAAK;AACH,mBAAQ,UAAU;AAAA,UACpB,KAAK;AACH,mBAAO,OAAO,KAAK;AAAA,UACrB;AACE,mBAAO;AAAA,QACX;AAAA,MACF;AAAA,IAEF;AAEA,WAAOD;AAAA,EACT;AAAC;;;AC7jBD,IAAM,mBAAmB,CAAC;AAC1B,IAAI,QAAQ,YAAY;AACxB,OAAO,OAAO;AACZ,MAAI,QAAQ,OAAO,oBAAoB,KAAK;AAC5C,WAAS,IAAE,GAAG,IAAE,MAAM,QAAQ,KAAK;AACjC,qBAAiB,MAAM,CAAC,CAAC,IAAI;AAAA,EAC/B;AACA,UAAQ,OAAO,eAAe,KAAK;AACrC;AAEA,IAAM,iBAAiB,MAAM;AAC3B,MAAI,CAAC,OAAO,cAAc;AACxB,WAAO,MAAM;AAAA,EACf;AACA,SAAO,CAAC,QAAQ,aAAa,OAAO,GAAG,KACjC,aAAa,SAAS,GAAG,KAAK,aAAa,YAAY,GAAG;AAClE,GAAG;AAgBH,SAAS,kBAAkB,OAAO,UAAU;AAE1C,MAAI,CAAC,iBAAiB,QAAQ,GAAG;AAC/B,QAAI,QAAQ,MAAM,QAAQ;AAC1B,QAAI,UAAU,QAAW;AACvB,UAAI,MAAM,QAAQ;AAGhB,cAAM,oBAAoB,UAAU,KAAK;AAAA,MAC3C,OAAO;AAEL,YAAI,CAAC,MAAM,aAAa;AACtB,gBAAM,cAAc,CAAC;AAAA,QACvB,WAAW,CAAC,MAAM,eAAe,0BAA0B,eAAe,KAAK,CAAC,GAAG;AACjF,gBAAM,cAAc,OAAO,OAAO,MAAM,WAAW;AAAA,QACrD;AACA,cAAM,YAAY,QAAQ,IAAI;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AACF;AAmCO,IAAM,oBAAoB,cAAc,gBAAc;AAQ1D,QAAM,OAAO,kBAAkB,UAAU;AAAA,EAS1C,MAAME,2BAA0B,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYnC,OAAO,gCAAgC;AACrC,UAAI;AAAA;AAAA,QAAwB,KAAM;AAAA;AAClC,eAAS,IAAE,GAAG,IAAI,GAAG,QAAQ,KAAK;AAChC,aAAK,UAAU,wBAAwB,gBAAgB,GAAG,CAAC,CAAC,CAAC;AAAA,MAC/D;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,OAAO,yBAAyB,UAAU;AACxC,aAAO,gBAAgB,QAAQ;AAAA,IACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,wBAAwB;AACtB,UAAI,KAAK,aAAa;AACpB,aAAK,2BAA2B,KAAK,WAAW;AAChD,aAAK,cAAc;AAAA,MACrB;AACA,YAAM,sBAAsB;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,2BAA2B,OAAO;AAChC,eAAS,KAAK,OAAO;AACnB,aAAK,aAAa,GAAG,MAAM,CAAC,CAAC;AAAA,MAC/B;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,iBAAiB,WAAW,OAAO;AACjC,YAAM;AAAA;AAAA,QAAiC;AAAA;AACvC,UAAI,CAAC,GAAG,aAAa,SAAS,GAAG;AAC/B,aAAK,sBAAsB,IAAI,OAAO,SAAS;AAAA,MACjD;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,gBAAgB,OAAO;AAErB,cAAQ,OAAO,OAAO;AAAA,QACpB,KAAK;AACH,cAAI,iBAAiB,MAAM;AACzB,mBAAO,MAAM,SAAS;AAAA,UACxB,WAAW,OAAO;AAChB,gBAAI,cAAc,KAAK,GAAG;AAMxB;AAAA;AAAA,gBAAyB;AAAA;AAAA,YAC3B;AACA,gBAAI;AACF,qBAAO,KAAK,UAAU,KAAK;AAAA,YAC7B,SAAQ,GAAG;AACT,qBAAO;AAAA,YACT;AAAA,UACF;AAAA,QAEF;AACE,iBAAO,MAAM,gBAAgB,KAAK;AAAA,MACtC;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBA,kBAAkB,OAAO,MAAM;AAI7B,UAAI;AACJ,cAAQ,MAAM;AAAA,QACZ,KAAK;AACH,cAAI;AACF,uBAAW,KAAK;AAAA;AAAA,cAA4B;AAAA,YAAM;AAAA,UACpD,SAAQ,GAAG;AAET,uBAAW;AAAA,UACb;AACA;AAAA,QACF,KAAK;AACH,cAAI;AACF,uBAAW,KAAK;AAAA;AAAA,cAA4B;AAAA,YAAM;AAAA,UACpD,SAAQ,GAAG;AACT,uBAAW;AACX,oBAAQ,KAAK,uDAAuD,KAAK,EAAE;AAAA,UAC7E;AACA;AAAA,QACF,KAAK;AACH,qBAAW,MAAM,KAAK,IAAI,OAAO,KAAK,IAAI,OAAO,KAAK;AACtD,qBAAW,IAAI,KAAK,QAAQ;AAC5B;AAAA,QACF;AACE,qBAAW,MAAM,kBAAkB,OAAO,IAAI;AAC9C;AAAA,MACJ;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmBA,wBAAwB,UAAU,UAAU;AAC1C,wBAAkB,MAAM,QAAQ;AAChC,YAAM,wBAAwB,UAAU,QAAQ;AAAA,IAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASA,aAAa,UAAU;AACrB,aAAO,KAAK,qBAAqB,KAAK,kBAAkB,QAAQ;AAAA,IAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,mBAAmB,MAAM;AACvB,aAAO,QAAQ,KAAK,iBAAkB,QAAQ,KAAK,aAAc;AAAA,IACnE;AAAA,EAEF;AAEA,SAAOA;AAET,CAAC;;;ACnUD,IAAM,qBAAqB;AAAA,EACzB,UAAU;AAAA,EACV,cAAc;AAChB;AAEA,IAAI,uBAAuB;AAC3B,IAAI,iBAAiB;AAErB,SAAS,oBAAoB;AAC3B,MAAI,CAAC,sBAAsB;AACzB,2BAAuB;AACvB,UAAM,IAAI,SAAS,cAAc,UAAU;AAC3C,MAAE,cAAc;AAChB,qBAAiB,EAAE,gBAAgB,EAAE;AAAA,EACvC;AACA,SAAO;AACT;AA4BA,SAAS,eAAe,MAAM;AAC5B,MAAI,kBAAkB,KAAK,KAAK,cAAc,cAAc,KAAK,eACxD,KAAK,gBAAgB,KAAK,aAAa;AAC9C,SAAK,cAAc;AAAA,EACrB;AACF;AAUA,IAAM,wCAAwC,MAAM;AAmBlD,QAAM,sCAAsC,OAAO,gBAC/C,OAAO,aAAa;AAAA,IAChB;AAAA,IAA2C;AAAA,MACzC,cAAc,OAAK;AAAA,IACrB;AAAA,EAAC;AAET,SAAO,CAAC,MAAM,KAAK,SAAS;AAC1B,UAAM,QAAQ,IAAI,aAAa,IAAI;AAEnC,QAAI,uCAAuC,KAAK,WAAW,KAAK,GAAG;AACjE,WAAK;AAAA,QACD;AAAA,QAAM,oCAAoC,aAAa,OAAO,IAAI;AAAA,MAAC;AACvE;AAAA,IACF;AAEA,SAAK,aAAa,MAAM,KAAK;AAAA,EAC/B;AACF,GAAG;AAEH,SAAS,sBAAsB,MAAM;AACnC,MAAI,KAAK,KAAK,aAAa,IAAI;AAC/B,MAAI,MAAM,mBAAmB,EAAE,GAAG;AAChC,QAAI,IAAI;AACR,MAAE,gBAAgB,IAAI;AACtB,WAAO,EAAE,cAAc,cAAc,EAAE;AACvC,MAAE,WAAW,aAAa,MAAM,CAAC;AACjC,SAAK,YAAY,CAAC;AAClB,WAAM,EAAE,WAAW,QAAQ;AACzB,YAAM,EAAC,KAAI,IAAI,EAAE,WAAW,CAAC;AAC7B,2CAAqC,MAAM,GAAG,IAAI;AAClD,QAAE,gBAAgB,IAAI;AAAA,IACxB;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,iBAAiBC,OAAM,UAAU;AAExC,MAAI,SAAS,SAAS,cAAc,iBAAiBA,OAAM,SAAS,UAAU;AAE9E,MAAI,QAAQ;AAGV,aAAS,IAAE,OAAO,YAAY,IAAE,GAAG,GAAG,IAAE,EAAE,aAAa;AACrD,UAAI,SAAS,gBAAgB,KAAK;AAChC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,OAAO;AACL,WAAOA;AAAA,EACT;AACF;AAGA,SAAS,aAAa,MAAM,KAAK,MAAM,UAAU;AAC/C,MAAI,SAAS,IAAI;AACf,QAAI,SAAS,EAAE,IAAI;AAAA,EACrB;AACF;AAGA,SAAS,mBAAmB,MAAM,MAAM,UAAU;AAChD,MAAI,SAAS,UAAU,SAAS,OAAO,QAAQ;AAC7C,aAAS,IAAE,GAAG,KAAG,SAAS,QAAQ,GAAI,IAAE,GAAG,WAAY,IAAE,GAAG,CAAC,IAAI,KAAK;AACpE,WAAK,8BAA8B,MAAM,EAAE,MAAM,EAAE,OAAO,IAAI;AAAA,IAChE;AAAA,EACF;AACF;AAGA,SAAS,kBAAkB,MAAM,MAAM,UAAU,oBAAoB;AACnE,MAAI,SAAS,cAAc;AAEzB,SAAK,gBAAgB,SAAS;AAC9B,SAAK,sBAAsB;AAAA,EAC7B;AACF;AAEA,SAAS,uBAAuB,SAAS,WAAW,YAAY;AAG9D,YAAU,QAAQ,eAAe;AACjC,MAAI,UAAU,SAAS,GAAG;AACxB,QAAI,QAAQ,UAAU,GAAG;AACvB,cAAQ,UAAU,EAAE,GAAG,EAAE,MAAM;AAAA,IACjC,OAAO;AACL,cAAQ,KAAK,sBAAsB,aAAa,eAAe;AAAA,IACjE;AAAA,EACF;AACA,SAAO;AACT;AAeO,IAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzB,CAAC,eAAe;AAAA,IAOlB,MAAMC,uBAAsB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA8ErC,OAAO,eAAe,UAAU,mBAAmB;AAEjD,YAAI,CAAC,SAAS,eAAe;AAE3B,cAAa,eAAe,SAAS,gBAAgB,CAAC;AACtD,uBAAa,eAAe,CAAC;AAC7B,uBAAa,iBAAiB,QAAQ,iBAAiB;AACvD,uBAAa,kBACV,qBAAqB,kBAAkB,mBACvC,SAAS,gBAAgB,SAAS,aAAa,kBAAkB;AAEnE,eAAK;AAAA,YACD;AAAA,YAAU;AAAA;AAAA,YAAgC,EAAC,QAAQ,KAAI;AAAA,UAAE;AAAA,QAChE;AACA,eAAO,SAAS;AAAA,MAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAWA,OAAO,sBAAsB,UAAU,cAAc,UAAU;AAC7D,eAAO,KAAK,mBAAmB,SAAS,SAAS,cAAc,QAAQ;AAAA,MACzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAgBA,OAAO,mBAAmB,MAAM,cAAc,UAAU;AACtD,YAAI,QAAQ;AACZ,YAAI;AAAA;AAAA,UAA+C;AAAA;AACnD,YAAI,QAAQ,aAAa,cAAc,CAAC,QAAQ,aAAa,kBAAkB,GAAG;AAChF,kBAAQ,KAAK,6BAA6B,SAAS,cAAc,QAAQ,KAAK;AAAA,QAChF,WAAW,QAAQ,cAAc,QAAQ;AAEvC,uBAAa,oBAAoB;AAAA,QACnC;AACA,uBAAe,OAAO;AACtB,YAAI,QAAQ,YAAY;AACtB,eAAK,yBAAyB,SAAS,cAAc,QAAQ;AAAA,QAC/D;AACA,YAAI,QAAQ,iBAAiB,QAAQ,cAAc,GAAG;AACpD,kBAAQ,KAAK,6BAA6B,SAAS,cAAc,QAAQ,KAAK;AAAA,QAChF;AAKA,eAAO,SAAS,SAAS;AAAA,MAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAeA,OAAO,yBAAyBD,OAAM,cAAc,UAAU;AAC5D,YAAIA,MAAK,cAAc,YAAYA,MAAK,cAAc,SAAS;AAC7D;AAAA,QACF;AACA,iBAAS,OAAKA,MAAK,YAAY,cAAY,GAAG,MAAM,MAAM,OAAK,MAAM;AAEnE,cAAI,KAAK,aAAa,YAAY;AAChC,mBAAO,sBAAsB,IAAI;AAAA,UACnC;AAKA,iBAAO,KAAK;AACZ,cAAI,KAAK,aAAa,KAAK,WAAW;AACpC,gBAAgB,IAAI;AACpB,mBAAO,KAAM,EAAE,aAAa,KAAK,WAAY;AAC3C,mBAAK,eAAe,EAAE;AACtB,qBAAO,EAAE;AACT,cAAAA,MAAK,YAAY,CAAC;AAClB,kBAAI;AAAA,YACN;AAEA,gBAAI,aAAa,mBAAmB,CAAC,KAAK,YAAY,KAAK,GAAG;AAC5D,cAAAA,MAAK,YAAY,IAAI;AACrB;AAAA,YACF;AAAA,UACF;AACA,cAAI;AAAA;AAAA,YAC0B,EAAC,aAAa,YAAY,SAAQ;AAAA;AAChE,cAAI,KAAK,mBAAmB,MAAM,cAAc,SAAS,GAAG;AAC1D,sBAAU,YAAY,aAAa,aAAa,KAAK,SAAS,IAAI;AAAA,UACpE;AAEA,cAAI,KAAK,YAAY;AACnB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAoBA,OAAO,6BAA6B,MAAM,mBAAmB,UAAU;AAErE,YAAI;AAAA;AAAA,UAA+C;AAAA;AACnD,YAAI,eAAe,KAAK,eAAe,SAAS,iBAAiB;AACjE,YAAI,UAAU,aAAa,UACvB,QAAQ,QAAQ,cAAc,uBAAuB;AACzD,gBAAQ,YAAY,QAAQ,OAAO;AACnC,iBAAS,eAAe;AACxB,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAcA,OAAO,6BAA6B,MAAM,cAAc,UAAU;AAGhE,YAAI,QAAQ;AACZ,YAAI,QAAQ,MAAM,KAAK,KAAK,UAAU;AACtC,iBAAS,IAAE,MAAM,SAAO,GAAG,GAAI,IAAE,MAAM,CAAC,GAAI,KAAK;AAC/C,kBAAQ,KAAK,4BAA4B,MAAM,cAAc,UAAU,EAAE,MAAM,EAAE,KAAK,KAAK;AAAA,QAC7F;AACA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAkBA,OAAO,4BAA4B,MAAM,cAAc,UAAU,MAAM,OAAO;AAE5E,YAAI,KAAK,MAAM,GAAG,CAAC,MAAM,OAAO;AAC9B,eAAK,gBAAgB,IAAI;AACzB,mBAAS,SAAS,SAAS,UAAU,CAAC;AACtC,mBAAS,OAAO,KAAK;AAAA,YACnB,MAAM,KAAK,MAAM,CAAC;AAAA,YAClB;AAAA,UACF,CAAC;AACD,iBAAO;AAAA,QACT,WAES,SAAS,MAAM;AACtB,mBAAS,KAAK;AACd,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAaA,OAAO,oBAAoB,UAAU;AACnC,YAAI;AAAA;AAAA,UAA2D,SAAU;AAAA;AACzE,eAAQ,gBAAgB,aAAa,WAAY,SAAS;AAAA,MAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA4BA,eAAe,UAAU,cAAc;AAErC,YAAI,YAAY,CAAC,SAAS,WACtB,OAAO,uBAAuB,oBAAoB,UAAU;AAC9D,8BAAoB,SAAS,QAAQ;AAAA,QACvC;AAIA,uBAAe,gBAAgB,KAAK,YAAY,eAAe,QAAQ;AACvE,YAAI,WAAW,aAAa;AAC5B,YAAI,UAAU,aAAa,WAAW,SAAS;AAC/C,YAAI;AAAA;AAAA,UAAuC,SAAS,WAAW,SAAS,IAAI;AAAA;AAE5E,YAAI,qBAAqB,CAAC,aAAa;AACvC,YAAI,QAAQ,IAAI,WAAW,IAAI,MAAM,SAAS,MAAM;AACpD,YAAI,IAAI,CAAC;AACT,iBAAS,IAAE,GAAG,IAAE,SAAS,QAAQ,MAAO,IAAE,MAAO,OAAK,SAAS,CAAC,IAAI,KAAK;AACvE,cAAI,OAAO,MAAM,CAAC,IAAI,iBAAiB,KAAK,IAAI;AAChD,uBAAa,MAAM,IAAI,GAAG,MAAM,IAAI;AACpC,4BAAkB,MAAM,MAAM,MAAM,YAAY;AAChD,6BAAmB,MAAM,MAAM,IAAI;AAAA,QACrC;AACA;AAAA,QAAsC;AACtC,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAgBA,8BAA8B,MAAM,WAAW,YAAY,SAAS;AAClE,kBAAU,WAAW;AACrB,YAAI,UAAU,uBAAuB,SAAS,WAAW,UAAU;AACnE,aAAK,wBAAwB,MAAM,WAAW,OAAO;AACrD,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAWA,wBAAwB,MAAM,WAAW,SAAS;AAChD,aAAK,iBAAiB,WAAW,OAAO;AAAA,MAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAWA,6BAA6B,MAAM,WAAW,SAAS;AACrD,aAAK,oBAAoB,WAAW,OAAO;AAAA,MAC7C;AAAA,IAEF;AAEA,WAAOC;AAAA,EAET;AAAC;;;ACplBD,IAAI,WAAW;AAEf,IAAM,OAAO,CAAC;AAMd,IAAM,QAAQ;AAAA,EACZ,SAAS;AAAA,EACT,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,SAAS;AAAA,EACT,WAAW;AACb;AAEA,IAAM,eAAe;AAGrB,IAAM,wBAAwB;AA4C9B,SAAS,mBAAmB,OAAO,MAAM,aAAa;AACpD,MAAI,UAAU,MAAM,IAAI;AACxB,MAAI,CAAC,SAAS;AACZ,cAAU,MAAM,IAAI,IAAI,CAAC;AAAA,EAC3B,WAAW,CAAC,MAAM,eAAe,IAAI,GAAG;AACtC,cAAU,MAAM,IAAI,IAAI,OAAO,OAAO,MAAM,IAAI,CAAC;AACjD,QAAI,aAAa;AACf,eAAS,KAAK,SAAS;AACrB,YAAI,UAAU,QAAQ,CAAC;AAEvB,YAAI,SAAS,QAAQ,CAAC,IAAI,MAAM,QAAQ,MAAM;AAC9C,iBAAS,IAAE,GAAG,IAAE,QAAQ,QAAQ,KAAK;AACnC,iBAAO,CAAC,IAAI,QAAQ,CAAC;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAiBA,SAAS,WAAW,MAAM,SAAS,OAAO,UAAU,UAAU,WAAW;AACvE,MAAI,SAAS;AACX,QAAI,MAAM;AACV,UAAM,KAAK;AACX,aAAS,QAAQ,OAAO;AAEtB,UAAI,eAAe,WAAW,KAAK,IAAI,IAAI;AAC3C,UAAI,MAAM,QAAQ,YAAY;AAC9B,UAAI,KAAK;AACP,iBAAS,IAAE,GAAG,IAAE,IAAI,QAAQ,IAAK,IAAE,MAAO,KAAG,IAAI,CAAC,IAAI,KAAK;AACzD,eAAK,CAAC,GAAG,QAAQ,GAAG,KAAK,YAAY,QAChC,CAAC,YAAY,mBAAmB,MAAM,GAAG,OAAO,IAAI;AACvD,gBAAI,GAAG,MAAM;AACX,iBAAG,KAAK,UAAU;AAAA,YACpB;AACA,eAAG,GAAG,MAAM,MAAM,OAAO,UAAU,GAAG,MAAM,UAAU,SAAS;AAC/D,kBAAM;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAgBA,SAAS,sBAAsB,MAAM,SAASC,WAAU,MAAM,OAAO,UAAU,UAAU,WAAW;AAClG,MAAI,MAAM;AACV,MAAI,eAAe,WAAW,KAAK,IAAI,IAAI;AAC3C,MAAI,MAAM,QAAQ,YAAY;AAC9B,MAAI,KAAK;AACP,aAAS,IAAE,GAAG,IAAE,IAAI,QAAQ,IAAK,IAAE,MAAO,KAAG,IAAI,CAAC,IAAI,KAAK;AACzD,WAAK,CAAC,GAAG,QAAQ,GAAG,KAAK,YAAYA,eAChC,CAAC,YAAY,mBAAmB,MAAM,GAAG,OAAO,IAAI;AACvD,YAAI,GAAG,MAAM;AACX,aAAG,KAAK,UAAUA;AAAA,QACpB;AACA,WAAG,GAAG,MAAM,MAAM,OAAO,UAAU,GAAG,MAAM,UAAU,SAAS;AAC/D,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAoBA,SAAS,mBAAmB,MAAM,SAAS;AACzC,MAAI,SAAS;AACX,QAAI;AAAA;AAAA,MAAqC,QAAQ;AAAA;AACjD,WAAQ,eAAe,QACnB,CAAC,EAAE,QAAQ,cAAc,WAAW,aAAa,IAAI,MACrD,CAAC,EAAE,QAAQ,YAAY,aAAa,aAAa,IAAI;AAAA,EAC3D,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAgBA,SAAS,kBAAkB,MAAM,UAAU,OAAO,UAAU,MAAM;AAChE,MAAI,KAAK,OAAO,KAAK,WAAW,WAAW,KAAK,KAAK,MAAM,IAAI,KAAK;AACpE,MAAI,cAAc,KAAK;AACvB,MAAI,IAAI;AACN,OAAG,KAAK,MAAM,KAAK,OAAO,WAAW,GAAG,SAAS,WAAW,CAAC;AAAA,EAC/D,WAAW,CAAC,KAAK,WAAW;AAC1B,YAAQ,KAAK,sBAAsB,KAAK,SAAS,eAAe;AAAA,EAClE;AACF;AAoBA,SAAS,iBAAiB,MAAM,aAAa,OAAO,UAAU,UAAU;AAEtE,MAAI,MAAM,KAAK,MAAM,MAAM;AAC3B,MAAI;AACJ,MAAI,KAAK;AAET,WAAS,QAAQ,aAAa;AAC5B,QAAI,YAAY,IAAI,GAAG;AACrB,UAAI,OAAO,sBAAsB,MAAM,KAAK,IAAI,MAAM,OAAO,UAAU,QAAQ,GAAG;AAChF,mBAAW;AAAA,MACb,WAAW,YAAY,WAAW,MAAM,MAAM,KAAK,GAAG;AACpD,mBAAW;AAAA,MACb;AAAA,IACF;AAAA,EACF;AAIA,MAAI;AACJ,MAAI,aAAa,OAAO,KAAK,eAAe,KAAK,uBAAuB;AACtE,SAAK,sBAAsB;AAAA,EAC7B;AACF;AAaA,SAAS,WAAW,MAAM,MAAM,OAAO;AACrC,MAAI,eAAe,KAAK,IAAI;AAC5B,MAAI,iBAAiB,MAAM;AACzB,QAAI,YAAY,gBAAgB,YAAY,IAAI;AAChD,wBAAoB,MAAM,WAAW,MAAM,IAAI,GAAG,IAAI;AACtD,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAiBA,SAAS,oBAAoB,MAAM,WAAW,OAAO,MAAM;AACzD,MAAI,SAAS;AAAA,IACX;AAAA,IACA,eAAe;AAAA,EACjB;AACA,MAAI,MAAM;AACR,WAAO,OAAO;AAAA,EAChB;AAMA;AAAA;AAAA,IAAiC;AAAA,EAAK,EAAE,cAAc,IAAI,YAAY,WAAW,EAAE,OAAO,CAAC,CAAC;AAC9F;AAiBA,SAAS,gBAAgB,MAAM,UAAU,OAAO,UAAU,MAAM,UAAU;AACxE,MAAI,eAAe,WAAW,KAAK,QAAQ,IAAI;AAC/C,MAAI,OAAO,gBAAgB,WAAW,WAAW;AACjD,MAAI,QAAQ,OAAO,IAAI,MAAM,IAAI,IAAI,KAAK,OAAO,QAAQ;AACzD,MAAI,QAAQ,UAAU,QAAW;AAC/B,YAAQ,MAAM,QAAQ;AAAA,EACxB;AACA,sBAAoB,MAAM,KAAK,WAAW,OAAO,IAAI;AACvD;AAoBA,SAAS,mBAAmB,OAAO,MAAM,UAAU,QAAQ,QAAQ;AACjE,MAAI;AACJ,MAAI;AAAA;AAAA,IAA+B,MAAM;AAAA;AACzC,MAAI,WAAW,UAAU,OAAO;AAChC,MAAI,UAAU;AACZ,aAAS,UAAU,UAAU,QAAQ,QAAQ;AAC7C,YAAQ,UAAU,OAAO;AAAA,EAC3B,OAAO;AACL,YAAQ,MAAM,cAAc,QAAQ;AAAA,EACtC;AACA,UAAQ,SAAS,CAAC,QAAQ;AAC1B,MAAI,CAAC,KAAK,MAAM,SAAS,KAAK,CAAC,KAAK,MAAM,SAAS,EAAE,MAAM,GAAG;AAC5D,QAAI,KAAK,0BAA0B,QAAQ,OAAO,MAAM,QAAQ,QAAQ,CAAC,MACnE,CAAC,UAAU,CAAC,OAAO,gBAAgB;AACvC,WAAK,sBAAsB;AAAA,IAC7B;AAAA,EACF;AACF;AAeA,SAAS,iBAAiB,MAAM,UAAU,OAAO,UAAU,MAAM;AAC/D,MAAI,QAAQ,KAAK,OAAO,QAAQ;AAChC,MAAI,kBAAkB;AACpB,YAAQ;AAAA,MAAiB;AAAA,MAAO,KAAK;AAAA,MAAU;AAAA;AAAA,MAAiC;AAAA,IAAK;AAAA,EACvF;AACA,OAAK,qBAAqB,UAAU,KAAK,UAAU,KAAK;AAC1D;AAmBA,SAAS,mBAAmB,MAAM,cAAc,UAAU,UAAU;AAClE,MAAI,iBAAiB,KAAK,MAAM,OAAO;AACvC,MAAI,gBAAgB;AAClB,QAAI,iBAAiB;AAInB;AACA,YAAM,QAAQ,iBAAiB,IAAI;AACnC,YAAM,QAAQ,CAAC;AACf,eAAS,KAAK,cAAc;AAC1B,0BAAkB,GAAG,gBAAgB,OAAO,OAAO,QAAQ;AAAA,MAC7D;AACA,UAAI;AACJ,aAAQ,OAAO,MAAM,MAAM,GAAI;AAC7B,YAAI,kBAAkB,MAAM,IAAI,cAAc,UAAU,IAAI,GAAG;AAC7D,4BAAkB,KAAK,YAAY,gBAAgB,OAAO,OAAO,QAAQ;AAAA,QAC3E;AAAA,MACF;AACA,aAAO;AAAA;AAAA,QAA+B;AAAA,QAAW,KAAK;AAAA,MAAS;AAC/D,aAAO;AAAA;AAAA,QAA+B;AAAA,QAAe,KAAK;AAAA,MAAa;AACvE,WAAK,gBAAgB;AAAA,IACvB,OAAO;AAGL,UAAI,aAAa;AACjB,aAAO,WAAW,MAAM,gBAAgB,YAAY,UAAU,QAAQ,GAAG;AACvE,eAAO;AAAA;AAAA,UAA+B;AAAA,UAAW,KAAK;AAAA,QAAS;AAC/D,eAAO;AAAA;AAAA,UAA+B;AAAA,UAAe,KAAK;AAAA,QAAa;AACvE,qBAAa,KAAK;AAClB,aAAK,gBAAgB;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AACF;AAaA,IAAM,eAAe,CAAC,MAAM,OAAO,UAAU;AAC3C,MAAI,QAAQ;AACZ,MAAI,MAAM,MAAM,SAAS;AACzB,MAAI,MAAM;AACV,SAAO,SAAS,KAAK;AACnB,UAAM,MAAO,QAAQ,OAAQ;AAG7B,UAAM,MAAM,MAAM,IAAI,MAAM,GAAG,EAAE,UAAU,IAAI,MAAM,IAAI,KAAK,UAAU;AACxE,QAAI,MAAM,GAAG;AACX,cAAQ,MAAM;AAAA,IAChB,WAAW,MAAM,GAAG;AAClB,YAAM,MAAM;AAAA,IACd,OAAO;AACL,YAAM;AACN;AAAA,IACF;AAAA,EACF;AACA,MAAI,MAAM,GAAG;AACX,UAAM,MAAM;AAAA,EACd;AACA,QAAM,OAAO,KAAK,GAAG,IAAI;AAC3B;AAgBA,IAAM,oBAAoB,CAAC,MAAM,gBAAgB,OAAO,OAAO,aAAa;AAC1E,QAAM,eAAe,WAAW,KAAK,IAAI,IAAI;AAC7C,QAAM,MAAM,eAAe,YAAY;AACvC,MAAI,KAAK;AACP,aAAS,IAAE,GAAG,IAAE,IAAI,QAAQ,KAAK;AAC/B,YAAM,KAAK,IAAI,CAAC;AAChB,UAAK,GAAG,KAAK,YAAY,aACpB,CAAC,YAAY,mBAAmB,MAAM,GAAG,OAAO,IAAI;AACvD,WAAG,KAAK,UAAU;AAClB,qBAAa,GAAG,MAAM,OAAO,KAAK;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AACF;AAuBA,SAAS,iBAAiB,MAAM;AAC9B,MAAI,UAAU,KAAK,YAAY;AAC/B,MAAI,CAAC,SAAS;AACZ,cAAU,oBAAI,IAAI;AAClB,UAAM,UAAU,KAAK,MAAM,OAAO;AAClC,QAAI,EAAC,QAAQ,OAAO,MAAK,IAAI,iBAAiB,IAAI;AAClD,QAAI;AACJ,WAAQ,OAAO,MAAM,MAAM,GAAI;AAC7B,cAAQ,IAAI,MAAM,QAAQ,IAAI;AAC9B,YAAM,iBAAiB,QAAQ,IAAI;AACnC,UAAI,gBAAgB;AAClB,uBAAe,QAAQ,QAAM;AAE3B,gBAAM,eAAe,GAAG,KAAK;AAC7B,YAAE;AACF,cAAI,EAAE,OAAO,YAAY,MAAM,GAAG;AAChC,kBAAM,KAAK,YAAY;AAAA,UACzB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,QAAI,UAAU,GAAG;AACf,YAAM;AAAA;AAAA,QAAiC;AAAA;AACvC,cAAQ,KAAK,sBAAsB,GAAG,SAAS,wBAAwB;AAAA,IACzE;AACA,SAAK,YAAY,wBAAwB;AAAA,EAC3C;AACA,SAAO;AACT;AAiBA,SAAS,iBAAiB,MAAM;AAC9B,QAAM,kBAAkB,KAAK,YAAY;AACzC,QAAM,SAAS,CAAC;AAChB,QAAM,eAAe,KAAK,MAAM,OAAO;AACvC,QAAM,QAAQ,CAAC;AACf,MAAI,QAAQ;AAEZ,WAAS,KAAK,iBAAiB;AAC7B,UAAM,OAAO,gBAAgB,CAAC;AAE9B,aAAS,OAAO,CAAC,IACf,KAAK,KAAK,OAAO,OAAK,CAAC,EAAE,OAAO,EAAE,UAAU,KAAK,YAAY,IAAI;AAAA,EACrE;AAEA,WAAS,KAAK,cAAc;AAC1B,QAAI,CAAC,gBAAgB,CAAC,GAAG;AACvB,YAAM,KAAK,CAAC;AAAA,IACd;AAAA,EACF;AACA,SAAO,EAAC,QAAQ,OAAO,MAAK;AAC9B;AAeA,SAAS,kBAAkB,MAAM,UAAU,cAAc,UAAU,MAAM;AAEvE,MAAI,SAAS,gBAAgB,MAAM,UAAU,cAAc,UAAU,IAAI;AAEzE,MAAI,WAAW,MAAM;AACnB,WAAO;AAAA,EACT;AACA,MAAI,eAAe,KAAK;AACxB,MAAI,KAAK,qBAAqB,KAAK,kBAAkB,YAAY,GAAG;AAClE,WAAO,KAAK,oBAAoB,cAAc,QAAQ,IAAI;AAAA,EAC5D,OAAO;AACL,SAAK,YAAY,IAAI;AACrB,WAAO;AAAA,EACT;AACF;AAYA,SAAS,mBAAmB,MAAM,MAAM,OAAO;AAC7C,MAAI,QAAQ,KAAK;AACjB,MAAI,OAAO;AACT,QAAI;AACJ,aAAS,KAAK,OAAO;AACnB,UAAI,IAAI,MAAM,CAAC;AACf,UAAI,aAAa,GAAG,IAAI,GAAG;AACzB,eAAO,UAAU,GAAG,GAAG,IAAI;AAC3B,aAAK,0BAA0B,MAAM,OAAO,MAAM,IAAI;AAAA,MACxD,WAAW,aAAa,GAAG,IAAI,GAAG;AAChC,eAAO,UAAU,GAAG,GAAG,IAAI;AAC3B,aAAK,0BAA0B,MAAM,OAAO,MAAM,IAAI;AAAA,MACxD;AAAA,IACF;AAAA,EACF;AACF;AAqBA,SAAS,WAAW,aAAa,cAAc,UAAU,MAAM,QAAQ,OAAO,SAAS;AAErF,WAAS,WAAW,SAAS,YAAY,CAAC;AAC1C,MAAmB,UAAU,EAAE,MAAM,QAAQ,OAAO,SAAS,YAAa,MAAM,WAAW,EAAG;AAC9F,WAAS,SAAS,KAAK,OAAO;AAE9B,MAAI,kBAAkB,OAAO,GAAG;AAC9B,QAAI,EAAC,OAAO,OAAM,IAAI,QAAQ,MAAM,CAAC;AACrC,YAAQ,gBAAgB,SAAU,gBAAgB,MAAM,IAAI;AAC5D,YAAQ,iBAAiB;AAAA,EAC3B;AAEA,MAAI,QAAQ,aAAa,aAAa;AACtC,WAAS,IAAE,GAAG,IAAE,QAAQ,MAAM,QAAQ,KAAK;AACzC,QAAI,OAAO,QAAQ,MAAM,CAAC;AAC1B,SAAK,gBAAgB;AACrB,4BAAwB,aAAa,cAAc,SAAS,MAAM,KAAK;AAAA,EACzE;AACF;AAcA,SAAS,wBAAwB,aAAa,cAAc,SAAS,MAAM,OAAO;AAChF,MAAI,CAAC,KAAK,SAAS;AACjB,QAAI,QAAQ,SAAS,eAAe,QAAQ,OAAO,CAAC,MAAM,KAAK;AAC7D,cAAQ,KAAK,0BAA0B,QAAQ,SAC7C,0DAA0D;AAAA,IAC9D,OAAO;AACL,UAAI,eAAe,KAAK;AACxB,UAAI,OAAO,EAAE,OAAO,SAAS,MAAM,WAAW,YAAY;AAC1D,eAAS,IAAE,GAAG,IAAE,aAAa,QAAQ,KAAK;AACxC,YAAI,UAAU,aAAa,CAAC;AAC5B,YAAI,OAAO,WAAW,UAAU;AAC9B,oBAAU,SAAS,OAAO;AAC1B,kBAAQ,WAAW;AAAA,QACrB;AACA,oBAAY,2BAA2B,cAAc,QAAQ,cAAc;AAAA,UACzE,IAAI;AAAA,UACJ;AAAA,UAAM;AAAA,QACR,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;AAsBA,SAAS,iBAAiB,MAAM,MAAM,OAAO,UAAU,MAAM,UAAU,UAAU;AAC/E,MAAI,OAAO,SAAS,KAAK,KAAK;AAC9B,MAAI,UAAU,KAAK;AACnB,MAAI,OAAO,KAAK;AAGhB,MAAI,YAAY,KAAK,UAAW,KAAK,SAAS,KAAK,OAAO,UACrD,QAAQ,QAAQ,cAAe,CAAC,QAAQ,cACzC,KAAK,6BACL,KAAK,qBAAqB,KAAK,kBAAkB,QAAQ,MAAM,GAAG;AACpE,QAAI,QAAQ,MAAM,IAAI;AACtB,WAAO,UAAU,KAAK,QAAQ,QAAQ,QAAQ,IAAI;AAClD,QAAI,KAAK,0BAA0B,MAAM,OAAO,OAAO,IAAI,GAAG;AAC5D,WAAK,eAAe,IAAI;AAAA,IAC1B;AAAA,EACF,OAAO;AACL,QAAI,QAAQ,KAAK,UAAU,iBAAiB,MAAM,MAAM,MAAM,OAAO,UAAU,QAAQ;AAGvF,QAAI,UAAU,MAAM;AAClB,wBAAkB,MAAM,MAAM,SAAS,MAAM,KAAK;AAAA,IACpD;AAAA,EACF;AACF;AAcA,SAAS,kBAAkB,MAAM,MAAM,SAAS,MAAM,OAAO;AAC3D,UAAQ,oBAAoB,MAAM,OAAO,SAAS,IAAI;AACtD,MAAI,kBAAkB;AACpB,YAAQ,iBAAiB,OAAO,QAAQ,QAAQ,QAAQ,MAAM,IAAI;AAAA,EACpE;AACA,MAAI,QAAQ,QAAQ,aAAa;AAE/B,SAAK;AAAA;AAAA,MAA6C;AAAA,MAAO;AAAA,MAAO,QAAQ;AAAA,IAAM;AAAA,EAChF,OAAO;AAEL,QAAI,OAAO,QAAQ;AACnB,QAAI,KAAK,6BACL,KAAK,qBAAqB,KAAK,kBAAkB,IAAI,GAAG;AAC1D,UAAI,CAAC,KAAK,MAAM,SAAS,KAAK,CAAC,KAAK,MAAM,SAAS,EAAE,IAAI,GAAG;AAC1D,YAAI,KAAK,oBAAoB,MAAM,KAAK,GAAG;AACzC,eAAK,eAAe,IAAI;AAAA,QAC1B;AAAA,MACF;AAAA,IACF,OAAO;AAGL,WAAK,4BAA4B,MAAM,MAAM,KAAK;AAAA,IACpD;AAAA,EACF;AACF;AAaA,SAAS,oBAAoB,MAAM,OAAO,SAAS,MAAM;AACvD,MAAI,QAAQ,YAAY;AACtB,QAAI,UAAU,KAAK,sBAAsB,QAAQ,MAAM;AACvD,YAAQ,KAAK,aAAa,IAAI;AAC9B,YAAQ,QAAQ,KAAK,EAAE;AAAA,EACzB;AACA,MAAI,QAAQ,SAAS,aAAa;AAEhC,QAAI,QAAQ,WAAW,iBAClB,QAAQ,WAAW,YACjB,KAAK,cAAc,WAAW,KAAK,cAAc,aAAc;AACpE,cAAQ,SAAS,SAAY,KAAK;AAAA,IACpC;AAAA,EACF;AACA,SAAO;AACT;AAeA,SAAS,kBAAkB,SAAS;AAClC,SAAO,QAAQ,QAAQ,MAAM,KACtB,QAAQ,QAAQ,eAChB,QAAQ,QAAQ,UAChB,CAAC,QAAQ,cACT,QAAQ,MAAM,CAAC,EAAE,SAAS;AACnC;AAYA,SAAS,cAAc,MAAM,cAAc;AAEzC,MAAI,EAAC,UAAU,aAAY,IAAI;AAC/B,MAAI,aAAa,QAAQ;AACvB,aAAS,IAAE,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,UAAI,OAAO,aAAa,CAAC;AACzB,UAAI,OAAO,SAAS,CAAC;AACrB,UAAI,WAAW,KAAK;AACpB,UAAI,UAAU;AACZ,iBAASC,KAAE,GAAGA,KAAE,SAAS,QAAQA,MAAK;AACpC,cAAI,UAAU,SAASA,EAAC;AACxB,+BAAqB,MAAM,OAAO;AAClC,4BAAkB,MAAM,MAAM,OAAO;AAAA,QACvC;AAAA,MACF;AAGA,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AACF;AAgBA,SAAS,qBAAqB,MAAM,SAAS;AAC3C,MAAI,QAAQ,YAAY;AAEtB,QAAI,UAAU,KAAK,0BAChB,KAAK,wBAAwB,CAAC;AACjC,QAAI,QAAQ,QAAQ;AAEpB,QAAI,WAAW,IAAI,MAAM,MAAM,MAAM;AACrC,aAAS,IAAE,GAAG,IAAE,MAAM,QAAQ,KAAK;AACjC,eAAS,CAAC,IAAI,MAAM,CAAC,EAAE;AAAA,IACzB;AACA,QAAI,SAAS,QAAQ;AACrB,YAAQ,MAAM,IAAI;AAElB,QAAI,QAAQ,WAAW,QAAQ,QAAQ,YAAY;AAIjD,UAAI,WAAW,aAAa;AAC1B,eAAO,KAAK,IAAI;AAAA,MAClB;AACA,WAAK,MAAM,IAAI,QAAQ;AAAA,IACzB;AAAA,EACF;AACF;AAYA,SAAS,kBAAkB,MAAM,MAAM,SAAS;AAC9C,MAAI,QAAQ,eAAe;AACzB,QAAI,OAAO,QAAQ,MAAM,CAAC;AAC1B,SAAK,iBAAiB,QAAQ,eAAe,SAAS,GAAG;AACvD,yBAAmB,GAAG,MAAM,QAAQ,QAAQ,KAAK,QAAQ,KAAK,MAAM;AAAA,IACtE,CAAC;AAAA,EACH;AACF;AAqBA,SAAS,mBAAmB,OAAO,KAAK,MAAM,UAAU,YAAY,WAAW;AAC7E,cAAY,IAAI,UAAW,cACxB,OAAO,cAAc,YAAY,UAAU,IAAI,UAAU;AAC5D,MAAI,OAAO;AAAA,IACT,YAAY,IAAI;AAAA,IAChB,MAAM,IAAI;AAAA,IACV;AAAA,IACA;AAAA,EACF;AACA,WAAS,IAAE,GAAG,KAAM,IAAE,IAAI,KAAK,WAAY,MAAI,IAAI,KAAK,CAAC,IAAI,KAAK;AAChE,QAAI,CAAC,IAAI,SAAS;AAChB,YAAM,mBAAmB,IAAI,cAAc,MAAM;AAAA,QAC/C,IAAI;AAAA,QAAU;AAAA,QAAY,SAAS;AAAA,MACrC,CAAC;AAAA,IACH;AAAA,EACF;AACA,MAAI,WAAW;AACb,UAAM,mBAAmB,IAAI,YAAY,MAAM;AAAA,MAC7C,IAAI;AAAA,MAAU;AAAA,IAChB,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAkBA,SAAS,gBAAgB,MAAM,UAAU,OAAO,UAAU,MAAM;AAG9D,MAAI,UAAU,KAAK,eAAe;AAClC,MAAI,KAAK,QAAQ,KAAK,UAAU;AAChC,MAAI,IAAI;AACN,QAAI,OAAO,KAAK,aAAa,KAAK,MAAM,UAAU,KAAK;AACvD,WAAO,SAAS,OAAO,OAAO,GAAG,MAAM,SAAS,IAAI;AAAA,EACtD,WAAW,CAAC,KAAK,WAAW;AAC1B,YAAQ,KAAK,aAAa,KAAK,aAAa,eAAe;AAAA,EAC7D;AACF;AAEA,IAAM,aAAa,CAAC;AAGpB,IAAM,QAAS;AACf,IAAM,SAAS;AACf,IAAM,gBAAgB;AACtB,IAAM,gBAAgB;AACtB,IAAM,SAAS,QAAQ,gBAAgB,MAAM,gBAAgB;AAC7D,IAAM,WAAW,SAAS,QAAQ,MAAM,SAAS,MAAO,SAAS;AACjE,IAAM,YAAY,QAAQ,WAAW,aAAa,WAAW;AAC7D,IAAM,gBAAgB,kBACgB,YAAY;AAElD,IAAM,UAAU,MAAM,QAAQ,SAAS,gBAAgB;AACvD,IAAM,eAAe;AACrB,IAAM,gBAAgB;AACtB,IAAM,SAAS;AACf,IAAM,aAAa,eAAe,SAAS,UAAU;AACrD,IAAM,eAAe,IAAI,OAAO,YAAY,GAAG;AAQ/C,SAAS,iBAAiB,OAAO;AAC/B,MAAI,IAAI;AACR,WAAS,IAAE,GAAG,IAAE,MAAM,QAAQ,KAAK;AACjC,QAAI,UAAU,MAAM,CAAC,EAAE;AACvB,SAAK,WAAW;AAAA,EAClB;AACA,SAAO;AACT;AAYA,SAAS,YAAY,YAAY;AAE/B,MAAI,IAAI,WAAW,MAAM,wBAAwB;AACjD,MAAI,GAAG;AACL,QAAI,aAAa,EAAE,CAAC;AACpB,QAAI,MAAM,EAAE,YAAY,QAAQ,MAAM,MAAM,WAAW;AACvD,QAAI,EAAE,CAAC,EAAE,KAAK,GAAG;AAEf,UAAI,OAAO,EAAE,CAAC,EAAE,QAAQ,QAAQ,SAAS,EAAE,MAAM,GAAG;AACpD,aAAO,UAAU,MAAM,GAAG;AAAA,IAC5B,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAYA,SAAS,UAAU,SAAS,KAAK;AAC/B,MAAI,OAAO,QAAQ,IAAI,SAAS,QAAQ;AACtC,QAAI,MAAM,SAAS,MAAM;AACzB,QAAI,CAAC,IAAI,SAAS;AAChB,UAAI,SAAS;AAAA,IACf;AACA,WAAO;AAAA,EACT,GAAG,IAAI;AACP,SAAO;AACT;AAkBA,SAAS,SAAS,QAAQ;AAExB,MAAI,MAAM,OAAO,KAAK,EAEnB,QAAQ,YAAY,GAAG,EAIvB,QAAQ,UAAU,IAAI;AAGzB,MAAI,IAAI;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,SAAS;AAAA,EACX;AAEA,MAAI,KAAK,IAAI,CAAC;AACd,MAAI,OAAO,KAAK;AACd,SAAK,IAAI,CAAC;AAAA,EACZ;AACA,MAAI,MAAM,OAAO,MAAM,KAAK;AAC1B,SAAK;AAAA,EACP;AACA,UAAO,IAAI;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AACH,QAAE,QAAQ,IAAI,MAAM,GAAG,EAAE;AACzB,QAAE,UAAU;AACZ;AAAA,IACF,KAAK;AACH,QAAE,QAAQ,OAAO,GAAG;AACpB,QAAE,UAAU;AACZ;AAAA,EACJ;AAEA,MAAI,CAAC,EAAE,SAAS;AACd,MAAE,eAAe,KAAK,GAAG;AAEzB,MAAE,aAAa,OAAO,GAAG;AACzB,QAAI,EAAE,YAAY;AAChB,QAAE,WAAY,IAAI,MAAM,EAAE,KAAK;AAC/B,UAAI,EAAE,UAAU;AACd,UAAE,OAAO,IAAI,MAAM,GAAG,EAAE;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,YAAY,MAAM,OAAO,MAAM;AACtC,MAAI,QAAQ,IAAI,MAAM,IAAI;AAM1B,MAAI,UAAU,QAAW;AACvB,YAAQ,MAAM,IAAI;AAAA,EACpB;AACA,SAAO;AACT;AAgBA,SAAS,cAAc,MAAM,OAAO,MAAM,SAAS;AACjD,QAAM,cAAc,EAAE,cAAc,QAAQ;AAG5C,MAAI,mBAAmB,CAAC,KAAK,0BAA0B;AACrD,UAAM,UAAU;AAAA,EAClB;AACA,OAAK,WAAW,OAAO,YAAY,WAAW;AAC9C,OAAK,WAAW,OAAO,WAAW,MAAM,MAAM;AAE9C,MAAI,mBAAmB,CAAC,KAAK,0BAA0B;AACrD,gBAAY,eAAe,CAAC;AAAA,EAC9B;AACF;AAiBA,SAAS,aAAa,MAAM,OAAO,MAAM,OAAO,YAAY,SAAS;AACnE,gBAAc,MAAM,OAAO,MAAM,CAAC;AAAA,IAChC;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC,CAAC;AACJ;AASA,SAAS,MAAM,MAAM;AACnB,SAAO,KAAK,CAAC,EAAE,YAAY,IAAI,KAAK,UAAU,CAAC;AACjD;AAqCO,IAAM,kBAAkB,cAAc,gBAAc;AASzD,QAAM,sBAAsB,cAAc,kBAAkB,UAAU,CAAC;AAAA,EASvE,MAAMC,yBAAwB,oBAAoB;AAAA,IAEhD,cAAc;AACZ,YAAM;AAGN,WAAK,4BAA4B;AAEjC,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAAA,IACP;AAAA,IAEA,IAAI,wBAAwB;AAC1B,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,wBAAwB;AACtB,YAAM,sBAAsB;AAC5B,WAAK,cAAc;AACnB,WAAK,qBAAqB;AAC1B,WAAK,uBAAuB;AAC5B,WAAK,iBAAiB;AACtB,WAAK,oBAAoB;AACzB,WAAK,iBAAiB;AAEtB,WAAK,wBAAwB,KAAK,yBAAyB;AAC3D,WAAK,aAAa,KAAK,cAAc;AACrC,WAAK,aAAa,CAAC;AACnB,WAAK,2BAA2B;AAAA,IAClC;AAAA,IAEA,gBAAgB;AACd,UAAI,UAAU,QAAQ;AACpB,YAAI,OAAO,UAAU,UAAU,SAAO,CAAC;AACvC,aAAK,eAAe,IAAI;AAGxB,aAAK,aAAa;AAAA,MACpB;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,2BAA2B,OAAO;AAChC,WAAK,SAAS,OAAO,OAAO,KAAK;AACjC,WAAK,gBAAgB,OAAO,OAAO,KAAK;AACxC,WAAK,YAAY,CAAC;AAAA,IACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,8BAA8B,OAAO;AACnC,UAAI,WAAW,KAAK,MAAM,SAAS;AACnC,eAAS,QAAQ,OAAO;AACtB,YAAI,CAAC,YAAY,CAAC,SAAS,IAAI,GAAG;AAChC,eAAK,gBAAgB,KAAK,iBAAiB,CAAC;AAC5C,eAAK,YAAY,KAAK,aAAa,CAAC;AACpC,eAAK,OAAO,IAAI,IAAI,KAAK,cAAc,IAAI,IAAI,MAAM,IAAI;AAAA,QAC3D;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,mBAAmB,UAAU,MAAM,QAAQ;AACzC,WAAK,wBAAwB,UAAU,QAAQ,MAAM,SAAS;AAE9D,UAAI,UAAU,mBAAmB,MAAM,MAAM,IAAI,EAAE,QAAQ;AAC3D,UAAI,CAAC,SAAS;AACZ,kBAAU,KAAK,IAAI,EAAE,QAAQ,IAAI,CAAC;AAAA,MACpC;AACA,cAAQ,KAAK,MAAM;AAAA,IACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,sBAAsB,UAAU,MAAM,QAAQ;AAC5C,UAAI,UAAU,mBAAmB,MAAM,MAAM,IAAI,EAAE,QAAQ;AAC3D,UAAI,MAAM,QAAQ,QAAQ,MAAM;AAChC,UAAI,OAAO,GAAG;AACZ,gBAAQ,OAAO,KAAK,CAAC;AAAA,MACvB;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAaA,mBAAmB,UAAU,MAAM;AACjC,UAAI,UAAU,KAAK,IAAI;AACvB,aAAO,QAAQ,WAAW,QAAQ,QAAQ,CAAC;AAAA,IAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,mBAAmB,UAAU;AAC3B,aAAO,KAAK,mBAAmB,UAAU,MAAM,SAAS;AAAA,IAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,iBAAiB,UAAU;AACzB,aAAO,KAAK,mBAAmB,UAAU,MAAM,MAAM;AAAA,IACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,kBAAkB,UAAU;AAC1B,aAAO,KAAK,mBAAmB,UAAU,MAAM,OAAO;AAAA,IACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,mBAAmB,UAAU;AAC3B,aAAO,KAAK,mBAAmB,UAAU,MAAM,OAAO;AAAA,IACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiCA,0BAA0B,MAAM,OAAO,cAAc,oBAAoB;AACvE,UAAI,sBACA,KAAK,MAAM,QAAQ,IAAI,IAAI,KAAK,CAAC,IAAI,IAAI,MAAM,MAAM;AASvD,YAAI,CAAC,oBAAoB;AACvB,cAAI,MAAM,IAAI,MAAM,IAAI;AACxB;AAAA,UAA8B,IAAI,MAAM,MAAM,KAAK;AAEnD,cAAI,CAAC,QAAQ,CAAC,MAAM,sBAAsB,MAAM,OAAO,GAAG,GAAG;AAC3D,mBAAO;AAAA,UACT;AAAA,QACF;AACA,aAAK,iBAAiB;AACtB,YAAI,KAAK;AAAA;AAAA,UAAuC;AAAA,UAAO;AAAA,UAAO;AAAA,QAAY,GAAG;AAC3E;AAAA,YAAmB;AAAA;AAAA,YAA0B;AAAA,YAAO;AAAA,UAAK;AACzD,iBAAO;AAAA,QACT;AAAA,MACF,OAAO;AACL,YAAI,KAAK,qBAAqB,KAAK,kBAAkB,IAAI,GAAG;AAC1D,iBAAO,KAAK;AAAA;AAAA,YAAuC;AAAA,YAAO;AAAA,YAAO;AAAA,UAAY;AAAA,QAC/E,OAAO;AACL,eAAK,IAAI,IAAI;AAAA,QACf;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAwBA,4BAA4B,MAAM,MAAM,OAAO;AAK7C,UAAI,UAAU,KAAK,IAAI,KAAK,OAAO,SAAS,UAAU;AAEpD,YAAI,SAAS,aAAa;AACxB;AAAA,UAA4B,KAAK,IAAI;AAAA,QACvC;AACA,aAAK,IAAI,IAAI;AAAA,MACf;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAqCA,oBAAoB,UAAU,OAAO,cAAc;AACjD,UAAI,aAAa,KAAK,kBAAkB,OAAO,QAAQ;AACvD,UAAI,YAAY,aAAa,KAAK,aAAa,KAAK;AACpD,UAAI,KAAK,sBAAsB,UAAU,OAAO,UAAU,QAAQ,CAAC,GAAG;AACpE,YAAI,CAAC,KAAK,eAAe;AACvB,eAAK,gBAAgB,CAAC;AACtB,eAAK,YAAY,CAAC;AAAA,QACpB;AAEA,YAAI,EAAE,YAAY,KAAK,YAAY;AACjC,eAAK,UAAU,QAAQ,IAAI,KAAK,OAAO,QAAQ;AAAA,QACjD;AAGA,YAAI,YAAY;AACd,eAAK,WAAW,QAAQ,IAAI;AAAA,QAC9B,OAAO;AACL,eAAK,OAAO,QAAQ,IAAI;AAAA,QAC1B;AAEA,aAAK,cAAc,QAAQ,IAAI;AAE/B,YAAI,cAAe,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,MAAM,EAAE,QAAQ,GAAI;AACtE,eAAK,iBAAiB,KAAK,kBAAkB,CAAC;AAC9C,eAAK,eAAe,QAAQ,IAAI;AAAA,QAClC;AACA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,aAAa,UAAU,OAAO;AAC5B,UAAI,KAAK,oBAAoB,UAAU,OAAO,IAAI,GAAG;AACnD,aAAK,sBAAsB;AAAA,MAC7B;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,wBAAwB;AACtB,UAAI,KAAK,aAAa;AACpB,aAAK,iBAAiB;AAAA,MACxB;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,eAAe,QAAQ;AACrB,WAAK,uBAAuB,KAAK,wBAAwB,CAAC;AAC1D,UAAI,WAAW,MAAM;AACnB,aAAK,qBAAqB,KAAK,MAAM;AAAA,MACvC;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,gBAAgB;AACd,UAAI,CAAC,KAAK,oBAAoB;AAC5B,aAAK,qBAAqB;AAC1B,aAAK,cAAc;AAInB,aAAK,cAAc;AAAA,MACrB,OAAO;AACL,aAAK,uBAAuB;AAAA,MAC9B;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,yBAAyB;AACvB,UAAI,UAAU,KAAK;AACnB,UAAI,SAAS;AACX,aAAK,uBAAuB;AAC5B,iBAAS,IAAE,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,cAAI,SAAS,QAAQ,CAAC;AACtB,cAAI,CAAC,OAAO,eAAe;AACzB,mBAAO,kBAAkB;AAAA,UAC3B,WAAW,OAAO,eAAe;AAC/B,mBAAO,iBAAiB;AAAA,UAC1B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,gBAAgB;AACd,WAAK,uBAAuB;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBA,cAAc,OAAO,aAAa;AAChC,eAAS,QAAQ,OAAO;AACtB,YAAI,eAAe,CAAC,KAAK,MAAM,SAAS,KAAK,CAAC,KAAK,MAAM,SAAS,EAAE,IAAI,GAAG;AAKzE,eAAK,0BAA0B,MAAM,MAAM,IAAI,GAAG,IAAI;AAAA,QACxD;AAAA,MACF;AACA,WAAK,sBAAsB;AAAA,IAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,QAAQ;AAKN,WAAK,iBAAiB;AAGtB,UAAI,CAAC,KAAK,oBAAoB;AAC5B,aAAK,cAAc;AAAA,MACrB;AAGA,UAAI,KAAK,eAAe;AACtB,aAAK,iBAAiB;AAAA,MACxB;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,mBAAmB,cAAc,cAAc,UAAU;AAMvD,UAAI,WAAW,KAAK;AACpB,WAAK,iBAAiB;AACtB,UAAI;AAEJ,yBAAmB,MAAM,cAAc,UAAU,QAAQ;AAGzD,oBAAc,KAAK;AACnB,WAAK,iBAAiB;AAEtB,WAAK,0BAA0B,cAAc,UAAU,QAAQ;AAE/D,WAAK,cAAc;AAEnB,iBAAW,MAAM,KAAK,MAAM,OAAO,GAAG,cAAc,UAAU,QAAQ;AAEtE,iBAAW,MAAM,KAAK,MAAM,OAAO,GAAG,cAAc,UAAU,QAAQ;AAEtE,UAAI,aAAa;AACf,yBAAiB,MAAM,aAAa,cAAc,UAAU,QAAQ;AAAA,MACtE;AAEA,UAAI,KAAK,iBAAiB,GAAG;AAC3B,aAAK,aAAa,CAAC;AAAA,MACrB;AAAA,IAIF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAaA,0BAA0B,cAAc,UAAU,UAAU;AAC1D,UAAI,KAAK,MAAM,SAAS,GAAG;AACzB,mBAAW,MAAM,KAAK,MAAM,SAAS,GAAG,cAAc,UAAU,QAAQ;AAAA,MAC1E;AACA,UAAI,KAAK,gBAAgB;AACvB,aAAK,uBAAuB,KAAK,gBAAgB,cAAc,UAAU,QAAQ;AAAA,MACnF;AAAA,IACF;AAAA,IAEA,uBAAuB,cAAc,cAAc,UAAU,UAAU;AACrE,YAAM,iBAAiB,CAACC,eAAcC,cAAa;AACjD;AAAA,UAAW;AAAA,UAAM,aAAa;AAAA,UAAiBD;AAAA,UAAc;AAAA,UAC3DC;AAAA,UAAU,aAAa;AAAA,QAAQ;AACjC,iBAAS,OAAK,aAAa,YAAY,MAAM,OAAK,KAAK,aAAa;AAClE,eAAK,uBAAuB,MAAMD,eAAc,UAAUC,SAAQ;AAAA,QACpE;AAAA,MACF;AACA,UAAI,aAAa,YAAY;AAC3B,qBAAa,WAAW,gBAAgB,cAAc,QAAQ;AAAA,MAChE,OAAO;AACL,uBAAe,cAAc,QAAQ;AAAA,MACvC;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,UAAU,IAAI,MAAM;AAClB,WAAK,UAAU,EAAE;AACjB,aAAO,UAAU,IAAI;AACrB,WAAK,oBAAoB,KAAK,qBAAqB,CAAC;AACpD,WAAK,kBAAkB,EAAE,IAAI;AAAA,IAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAaA,YAAY,MAAM;AAChB,aAAO,UAAU,IAAI;AACrB,UAAI,KAAK,mBAAmB;AAC1B,eAAO,KAAK,kBAAkB,IAAI;AAAA,MACpC;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoCA,cAAc,MAAM,SAAS;AAC3B,UAAI,OAAO,EAAC,MAAM,GAAE;AACpB,UAAI;AAAA;AAAA,QAA6B,IAAI,MAAM,MAAM,IAAI;AAAA;AACrD,oBAAc,MAAM,OAAO,KAAK,MAAM,OAAO;AAAA,IAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsBA,IAAI,MAAMC,OAAM;AACd,aAAO,IAAIA,SAAQ,MAAM,IAAI;AAAA,IAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAwBA,IAAI,MAAM,OAAOA,OAAM;AACrB,UAAIA,OAAM;AACR,YAAIA,OAAM,MAAM,KAAK;AAAA,MACvB,OAAO;AACL,YAAI,CAAC,KAAK,MAAM,SAAS,KAAK,CAAC,KAAK,MAAM,SAAS;AAAA;AAAA,UAAwB;AAAA,QAAK,GAAG;AACjF,cAAI,KAAK,0BAA0B,MAAM,OAAO,IAAI,GAAG;AACrD,iBAAK,sBAAsB;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBA,KAAK,SAAS,OAAO;AACnB,UAAI,OAAO,EAAC,MAAM,GAAE;AACpB,UAAI;AAAA;AAAA,QAA4B,IAAI,MAAM,MAAM,IAAI;AAAA;AACpD,UAAI,MAAM,MAAM;AAChB,UAAI,MAAM,MAAM,KAAK,GAAG,KAAK;AAC7B,UAAI,MAAM,QAAQ;AAChB,qBAAa,MAAM,OAAO,KAAK,MAAM,KAAK,MAAM,QAAQ,CAAC,CAAC;AAAA,MAC5D;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,IAAI,MAAM;AACR,UAAI,OAAO,EAAC,MAAM,GAAE;AACpB,UAAI;AAAA;AAAA,QAA6B,IAAI,MAAM,MAAM,IAAI;AAAA;AACrD,UAAI,YAAY,QAAQ,MAAM,MAAM;AACpC,UAAI,MAAM,MAAM,IAAI;AACpB,UAAI,WAAW;AACb,qBAAa,MAAM,OAAO,KAAK,MAAM,MAAM,QAAQ,GAAG,CAAC,GAAG,CAAC;AAAA,MAC7D;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoBA,OAAO,MAAM,OAAO,gBAAgB,OAAO;AACzC,UAAI,OAAO,EAAC,MAAO,GAAE;AACrB,UAAI;AAAA;AAAA,QAA6B,IAAI,MAAM,MAAM,IAAI;AAAA;AAErD,UAAI,QAAQ,GAAG;AACb,gBAAQ,MAAM,SAAS,KAAK,MAAM,CAAC,KAAK;AAAA,MAC1C,WAAW,OAAO;AAChB,gBAAQ,KAAK,MAAM,KAAK;AAAA,MAC1B;AASA,UAAI;AAEJ,UAAI,UAAU,WAAW,GAAG;AAC1B,cAAM,MAAM,OAAO,KAAK;AAAA,MAO1B,OAAO;AACL,cAAM,MAAM,OAAO,OAAO,aAAa,GAAG,KAAK;AAAA,MACjD;AAIA,UAAI,MAAM,UAAU,IAAI,QAAQ;AAC9B,qBAAa,MAAM,OAAO,KAAK,MAAM,OAAO,MAAM,QAAQ,GAAG;AAAA,MAC/D;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,MAAM,MAAM;AACV,UAAI,OAAO,EAAC,MAAM,GAAE;AACpB,UAAI;AAAA;AAAA,QAA6B,IAAI,MAAM,MAAM,IAAI;AAAA;AACrD,UAAI,YAAY,QAAQ,MAAM,MAAM;AACpC,UAAI,MAAM,MAAM,MAAM;AACtB,UAAI,WAAW;AACb,qBAAa,MAAM,OAAO,KAAK,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC;AAAA,MAClD;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBA,QAAQ,SAAS,OAAO;AACtB,UAAI,OAAO,EAAC,MAAM,GAAE;AACpB,UAAI;AAAA;AAAA,QAA6B,IAAI,MAAM,MAAM,IAAI;AAAA;AACrD,UAAI,MAAM,MAAM,QAAQ,GAAG,KAAK;AAChC,UAAI,MAAM,QAAQ;AAChB,qBAAa,MAAM,OAAO,KAAK,MAAM,GAAG,MAAM,QAAQ,CAAC,CAAC;AAAA,MAC1D;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,WAAW,MAAM,OAAO;AAEtB,UAAI;AACJ,UAAI,UAAU,UAAU,GAAG;AAEzB,YAAI,OAAO,EAAC,MAAM,GAAE;AACpB,gBAAQ,IAAI,MAAM,MAAM,IAAI;AAC5B,mBAAW,KAAK;AAAA,MAClB,WAAW,MAAM,QAAQ,IAAI,GAAG;AAE9B,mBAAW,UAAU,IAAI;AAAA,MAC3B,OAAO;AACL;AAAA,QAAgC;AAAA,MAClC;AACA,UAAI,KAAK,0BAA0B,UAAU,OAAO,MAAM,IAAI,GAAG;AAC/D,aAAK,sBAAsB;AAAA,MAC7B;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,wBAAwB,UAAU,iBAAiB;AACjD,WAAK,mBAAmB,UAAU,MAAM,SAAS;AACjD,UAAI,iBAAiB;AACnB,aAAK,SAAS,MAAM,QAAQ,CAAC;AAAA,QAAkC,SAAS,OAAO;AAC7E,eAAK,aAAa,UAAU,KAAK;AAAA,QACnC;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,wBAAwB,UAAU,QAAQ,WAAW;AACnD,UAAI,OAAO,EAAE,UAAU,QAAQ,WAAW,QAAQ,SAAS,EAAE;AAC7D,WAAK,mBAAmB,UAAU,MAAM,SAAS;AAAA,QAC/C,IAAI;AAAA,QAAmB;AAAA,QAAM,SAAS,EAAC,MAAM,SAAQ;AAAA,MACvD,CAAC;AACD,UAAI,WAAW;AACb,aAAK;AAAA;AAAA,UAAyC;AAAA,UAAS,MAAM;AAAA,UAAS;AAAA,YACpE,IAAI;AAAA,YAAmB;AAAA,YAAM,SAAS,EAAC,MAAM,OAAM;AAAA,UACrD;AAAA,QAAC;AAAA,MACH;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,sBAAsB,YAAY,WAAW;AAC3C,UAAI,MAAM,YAAY,UAAU;AAChC,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM,oCAAoC,aAAa,GAAG;AAAA,MACtE;AACA,yBAAmB,MAAM,KAAK,MAAM,SAAS,iBAAiB,MAAM,SAAS;AAAA,IAC/E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,yBAAyB,UAAU;AACjC,WAAK,mBAAmB,UAAU,MAAM,QAAQ;AAAA,QAC9C,IAAI;AAAA,QACJ,MAAM;AAAA,UACJ,WAAW,gBAAgB,QAAQ,IAAI;AAAA,UACvC;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAaA,yBAAyB,UAAU;AACjC,UAAI,OAAO,KAAK,YAAY,yBAAyB,QAAQ;AAC7D,UAAI,KAAK,CAAC,MAAM,KAAK;AACnB,gBAAQ,KAAK,cAAc,WAAW,uCACpC,OAAO,6GAA6G;AAAA,MACxH,OAAO;AACL,aAAK,mBAAmB,UAAU,MAAM,SAAS;AAAA,UAC/C,IAAI;AAAA,UACJ,MAAM;AAAA,YACJ,UAAU;AAAA,UACZ;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,wBAAwB,UAAU,YAAY,WAAW;AACvD,UAAI,MAAM,YAAY,UAAU;AAChC,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM,oCAAoC,aAAa,GAAG;AAAA,MACtE;AACA,YAAM,OAAO,mBAAmB,MAAM,KAAK,MAAM,SAAS,mBAAmB,UAAU,SAAS;AAGhG,yBAAmB,MAAM,YAAY,EAAE,QAAQ,IAAI;AAAA,IACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,aAAa,MAAM,MAAM,OAAO;AAC9B,YAAM,OAAO,KAAK;AAClB,YAAM,SAAS,CAAC;AAChB,eAAS,IAAE,GAAG,IAAE,KAAK,QAAQ,IAAE,GAAG,KAAK;AACrC,YAAI,EAAC,MAAM,YAAY,UAAU,OAAO,QAAO,IAAI,KAAK,CAAC;AACzD,YAAI,CAAC,SAAS;AACZ,cAAI,UAAU;AACZ,kBAAMC,WAAU,aAAa,MAAM,IAAI;AACvC,kBAAM,YAAY,YAAY,MAAM,OAAOA,WAAU,OAAO,IAAI;AAChE,oBAAQ;AAAA,cACN,MAAMA,WAAU,OAAO;AAAA,cACvB,OAAO;AAAA,cACP,MAAMA,WAAU,IAAI,MAAM,IAAI,IAAI;AAAA,YACpC;AAAA,UACF,OAAO;AACL,oBAAQ,aAAa,YAAY,MAAM,OAAO,IAAI,IAAI,KAAK,IAAI;AAAA,UACjE;AAAA,QACF;AAGA,YAAI,mBAAmB,CAAC,KAAK,4BAA4B,UAAU,UAAa,KAAK,SAAS,GAAG;AAC/F,iBAAO;AAAA,QACT;AACA,eAAO,CAAC,IAAI;AAAA,MACd;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAyCA,OAAO,kBAAkB,UAAU,MAAM,QAAQ;AAC/C,WAAK,UAAU,mBAAmB,UAAU,MAAM,MAAM;AAAA,IAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAaA,OAAO,uBAAuB,UAAU,QAAQ,WAAW;AACzD,WAAK,UAAU,wBAAwB,UAAU,QAAQ,SAAS;AAAA,IACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,OAAO,qBAAqB,YAAY,WAAW;AACjD,WAAK,UAAU,sBAAsB,YAAY,SAAS;AAAA,IAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,OAAO,wBAAwB,UAAU;AACvC,WAAK,UAAU,yBAAyB,QAAQ;AAAA,IAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmBA,OAAO,uBAAuB,UAAU,iBAAiB;AACvD,WAAK,UAAU,wBAAwB,UAAU,eAAe;AAAA,IAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,OAAO,wBAAwB,UAAU;AACvC,WAAK,UAAU,yBAAyB,QAAQ;AAAA,IAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBA,OAAO,uBAAuB,UAAU,YAAY,WAAW;AAC7D,WAAK,UAAU,wBAAwB,UAAU,YAAY,SAAS;AAAA,IACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,OAAO,aAAa,UAAU;AAC5B,aAAO,KAAK,UAAU,cAAc,QAAQ;AAAA,IAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA6DA,cAAc,UAAU,iBAAiB;AACvC,UAAI,eAAe,KAAK,YAAY,eAAe,QAAQ;AAC3D,UAAI,cAAc,KAAK,0BAA0B;AAGjD,UAAI,CAAC,aAAa;AAChB,iBAAS,QAAQ,aAAa,iBAAiB;AAC7C,eAAK,wBAAwB,IAAI;AAAA,QACnC;AAAA,MACF;AACA,UAAI,iBAAiB;AAGnB;AAAA,QAA4C,OAAO,OAAO,YAAY;AACtE,qBAAa,cAAc;AAC3B,YAAI,CAAC,KAAK,gBAAgB;AAExB,eAAK,iBAAiB;AAAA,QACxB,OAAO;AAaL,gBAAM,SAAS,SAAS,uBAAuB,KAAK;AACpD,gBAAM,WAAW,OAAO;AACxB,uBAAa,SAAS;AACtB,iBAAO,YAAY;AACnB,uBAAa,kBAAkB;AAC/B,cAAI,UAAU;AACZ,qBAAS,cAAc;AAAA,UACzB,OAAO;AACL,mBAAO,aAAa;AAAA,UACtB;AAAA,QACF;AAAA,MACF,OAAO;AACL,aAAK,yBAAyB;AAAA,MAChC;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,OAAO,2BAA2B,cAAc,MAAM,QAAQ;AAC5D,UAAI,YAAY,aAAa,YAAY,aAAa,aAAa,CAAC;AACpE,gBAAU,IAAI,IAAI;AAClB,UAAI,UAAU,aAAa,kBAAkB,aAAa,mBAAmB,CAAC;AAC9E,UAAI,cAAc,QAAQ,IAAI,IAAI,QAAQ,IAAI,KAAK,CAAC;AACpD,kBAAY,KAAK,MAAM;AAAA,IACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAyBA,eAAe,UAAU,cAAc;AACrC,qBAAgB;AAAA,MAA6C,KAAK,cAAc,UAAU,IAAI;AAG9F,gBAAU,KAAK,IAAI;AACnB,UAAI,MAAM,MAAM,eAAe,UAAU,YAAY;AACrD,gBAAU,IAAI;AAEd,mBAAa,WAAW,IAAI;AAE5B,UAAI,CAAC,aAAa,aAAa;AAC7B,YAAI,QAAQ,aAAa,aAAa,CAAC;AACvC,iBAAS,IAAE,IAAI,YAAY,GAAG,IAAE,EAAE,aAAa;AAC7C,gBAAM,KAAK,CAAC;AAAA,QACd;AAAA,MACF;AACA,UAAI,eAAe;AAEnB,oBAAc,MAAM,YAAY;AAUhC,UAAI,KAAK,oBAAoB;AAC3B,aAAK,uBAAuB,cAAc,KAAK,QAAQ,MAAM,KAAK;AAClE,aAAK,cAAc;AAAA,MACrB;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,gBAAgB,KAAK;AAKnB,YAAM,eAAe,IAAI;AACzB,YAAM,EAAC,iBAAiB,aAAa,OAAM,IAAI;AAC/C,UAAI,iBAAiB;AACnB,wBAAgB,cAAc;AAAA,MAChC,WAAW,QAAQ;AACjB,eAAO,aAAa;AAAA,MACtB;AACA,UAAI,aAAa;AACf,oBAAY,kBAAkB;AAAA,MAChC,WAAW,QAAQ;AACjB,eAAO,YAAY;AAAA,MACrB;AACA,mBAAa,cAAc,aAAa,kBAAkB;AAE1D,UAAI,QAAQ,aAAa;AACzB,eAAS,IAAE,GAAG,IAAE,MAAM,QAAQ,KAAK;AACjC,YAAI,OAAO,MAAM,CAAC;AAClB,aAAK,KAAK,IAAI,EAAE,UAAU,EAAE,YAAY,IAAI;AAAA,MAC9C;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmBA,OAAO,mBAAmB,MAAM,cAAc,UAAU;AAGtD,UAAI,QAAQ,oBAAoB,mBAAmB;AAAA,QACjD;AAAA,QAAM;AAAA,QAAM;AAAA,QAAc;AAAA,MAAQ;AACpC,UAAI,KAAK,aAAa,KAAK,WAAW;AACpC,YAAI,QAAQ,KAAK,eAAe,KAAK,aAAa,YAAY;AAC9D,YAAI,OAAO;AAIT,eAAK,cAAc,iBAAiB,KAAK,KAAK;AAC9C,qBAAW,MAAM,cAAc,UAAU,QAAQ,eAAe,KAAK;AACrE,kBAAQ;AAAA,QACV;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAqBA,OAAO,4BAA4B,MAAM,cAAc,UAAU,MAAM,OAAO;AAC5E,UAAI,QAAQ,KAAK,eAAe,OAAO,YAAY;AACnD,UAAI,OAAO;AAET,YAAI,WAAW;AACf,YAAI,OAAO;AAIX,YAAI,sBAAsB,KAAK,IAAI,GAAG;AACpC,iBAAO;AAAA,QACT,WAAW,KAAK,KAAK,SAAO,CAAC,KAAK,KAAK;AACrC,iBAAO,KAAK,MAAM,GAAG,EAAE;AACvB,iBAAO;AAAA,QACT;AAEA,YAAI,UAAU,iBAAiB,KAAK;AACpC,YAAI,WAAW,QAAQ,aAAa;AAGlC,cAAI,QAAQ,WAAW,KAAK,aAAa,OAAO,GAAG;AACjD,uBAAW,MAAM,KAAK,aAAa,IAAI;AAAA,UACzC;AACA,eAAK,aAAa,MAAM,OAAO;AAAA,QACjC;AAEA,YAAI,QAAQ,eAAe,YAAY,oBAAoB;AACzD,eAAK,aAAa,MAAM,EAAE;AAAA,QAC5B;AAKA,YAAI,KAAK,cAAc,WAAW,aAAa,SAAS;AACtD,eAAK,aAAa,UAAU,EAAE;AAAA,QAChC;AAEA,aAAK,gBAAgB,QAAQ;AAK7B,YAAI,SAAS,YAAY;AACvB,iBAAO,gBAAgB,IAAI;AAAA,QAC7B;AACA,mBAAW,MAAM,cAAc,UAAU,MAAM,MAAM,OAAO,OAAO;AACnE,eAAO;AAAA,MACT,OAAO;AAGL,eAAO,oBAAoB,4BAA4B;AAAA,UACrD;AAAA,UAAM;AAAA,UAAM;AAAA,UAAc;AAAA,UAAU;AAAA,UAAM;AAAA,QAAK;AAAA,MACnD;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,OAAO,6BAA6B,MAAM,cAAc,UAAU;AAGhE,UAAI,QAAQ,oBAAoB,6BAA6B;AAAA,QAC3D;AAAA,QAAM;AAAA,QAAM;AAAA,QAAc;AAAA,MAAQ;AACpC,YAAM,SAAS,KAAK;AACpB,YAAM,qBAAqB,SAAS;AACpC,YAAM,UAAU,OAAO,cAAc;AACrC,YAAM,cAAc,OAAO,cAAc;AAGzC,UAAI,0BAA0B,WAAW,cAAc;AACrD,eAAO,YAAY,IAAI;AAGvB,mBAAW,SAAS;AACpB,iBAAS,eAAe;AAGxB,iBAAS,QAAQ;AACjB,gBAAQ;AAAA,MACV;AAEA,UAAI,YAAY,mBAAmB;AACnC,UAAI,aAAa,SAAS;AAQxB,YAAI,WAAW;AACb,uBAAa,YACX,OAAO,OAAO,aAAa,aAAa,CAAC,GAAG,SAAS;AAIvD,cAAI,CAAC,uBAAuB;AAC1B,qBAAS,WAAW,QAAQ;AAAA,UAC9B;AAAA,QACF;AAAA,MACF,OAAO;AACL,YAAI,OAAO;AACX,iBAAS,UAAU,WAAW;AAC5B,cAAI,QAAQ,CAAC,EAAE,MAAM,QAAQ,cAAc,CAAC,MAAM,GAAG,UAAU,KAAK,CAAC;AACrE,qBAAW,MAAM,cAAc,UAAU,YAAY,WAAW,QAAQ,KAAK;AAAA,QAC/E;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA+CA,OAAO,eAAe,MAAM,cAAc;AACxC,UAAI,QAAQ,CAAC;AACb,UAAI,YAAY;AAChB,UAAI;AAOJ,cAAQ,IAAI,aAAa,KAAK,IAAI,OAAO,MAAM;AAE7C,YAAI,EAAE,QAAQ,WAAW;AACvB,gBAAM,KAAK,EAAC,SAAS,KAAK,MAAM,WAAW,EAAE,KAAK,EAAC,CAAC;AAAA,QACtD;AAEA,YAAI,OAAO,EAAE,CAAC,EAAE,CAAC;AACjB,YAAI,SAAS,QAAQ,EAAE,CAAC,CAAC;AACzB,YAAI,SAAS,EAAE,CAAC,EAAE,KAAK;AACvB,YAAI,cAAc,OAAO,cAAc,IAAI,QAAQ;AACnD,YAAI,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,IAAI,KAAK,GAAG;AACrD,wBAAc,OAAO,UAAU,QAAQ,CAAC;AACxC,mBAAS,OAAO,UAAU,GAAG,KAAK;AAClC,wBAAc;AAAA,QAChB;AACA,YAAI,YAAY,YAAY,MAAM;AAClC,YAAI,eAAe,CAAC;AACpB,YAAI,WAAW;AAEb,cAAI,EAAC,MAAM,WAAU,IAAI;AACzB,mBAAS,IAAE,GAAG,IAAE,KAAK,QAAQ,KAAK;AAChC,gBAAI,MAAM,KAAK,CAAC;AAChB,gBAAI,CAAC,IAAI,SAAS;AAChB,2BAAa,KAAK,GAAG;AAAA,YACvB;AAAA,UACF;AACA,cAAI,aAAa,aAAa;AAC9B,cAAI,cAAc,WAAW,UAAU,KAAK,UAAU,QAAQ;AAC5D,yBAAa,KAAK,UAAU;AAC5B,sBAAU,YAAY;AAAA,UACxB;AAAA,QACF,OAAO;AAEL,uBAAa,KAAK,MAAM;AAAA,QAC1B;AACA,cAAM,KAAK;AAAA,UACT;AAAA,UAAQ;AAAA,UAAM;AAAA,UAAQ;AAAA,UAAa;AAAA,UAAW;AAAA,UAC9C,OAAO;AAAA,QACT,CAAC;AACD,oBAAY,aAAa;AAAA,MAC3B;AAEA,UAAI,aAAa,YAAY,KAAK,QAAQ;AACxC,YAAI,UAAU,KAAK,UAAU,SAAS;AACtC,YAAI,SAAS;AACX,gBAAM,KAAK;AAAA,YACT;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AACA,UAAI,MAAM,QAAQ;AAChB,eAAO;AAAA,MACT,OAAO;AACL,eAAO;AAAA,MACT;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBA,OAAO,iBAAiB,MAAM,MAAM,MAAM,OAAO,UAAU,UAAU;AACnE,UAAI;AACJ,UAAI,KAAK,WAAW;AAClB,gBAAQ,gBAAgB,MAAM,MAAM,OAAO,UAAU,KAAK,SAAS;AAAA,MACrE,WAAW,QAAQ,KAAK,QAAQ;AAC9B,gBAAQ,IAAI,MAAM,KAAK,MAAM;AAAA,MAC/B,OAAO;AACL,YAAI,YAAY,OAAO,IAAI,GAAG;AAC5B,kBAAQ,IAAI,MAAM,IAAI;AAAA,QACxB,OAAO;AACL,kBAAQ,KAAK,OAAO,IAAI;AAAA,QAC1B;AAAA,MACF;AACA,UAAI,KAAK,QAAQ;AACf,gBAAQ,CAAC;AAAA,MACX;AACA,aAAO;AAAA,IACT;AAAA,EAEF;AAEA,SAAOJ;AACT,CAAC;AAyBD,IAAM,YAAY,CAAC;;;ACtnGZ,IAAI,gBAAgB;AAEpB,SAAS,yBAAyB;AACvC;AACF;AAMO,IAAM,gBAAgB,CAAC;AAevB,SAAS,SAAS,WAAW;AAClC,gBAAc,KAAK,SAAS;AAC9B;;;ACjBA,SAAS,oBAAoB,OAAO;AAClC,QAAM,SAAS,CAAC;AAChB,WAAS,KAAK,OAAO;AACnB,UAAM,IAAI,MAAM,CAAC;AACjB,WAAO,CAAC,IAAK,OAAO,MAAM,aAAc,EAAC,MAAM,EAAC,IAAI;AAAA,EACtD;AACA,SAAO;AACT;AAsBO,IAAM,kBAAkB,cAAc,gBAAc;AAO1D,QAAM,OAAO,kBAAkB,UAAU;AASzC,WAAS,qBAAqB,aAAa;AACzC,UAAM,YAAY,OAAO,eAAe,WAAW;AAMnD,WAAQ,UAAU,qBAAqBK;AAAA;AAAA,MACO;AAAA,QAAa;AAAA,EAC7D;AAUA,WAAS,cAAc,aAAa;AAClC,QAAI,CAAC,YAAY,eAAe,0BAA0B,mBAAmB,WAAW,CAAC,GAAG;AAC1F,UAAI,QAAQ;AAEZ,UAAI,YAAY,eAAe,0BAA0B,cAAc,WAAW,CAAC,GAAG;AACpF,cAAM,aAAa,YAAY;AAE/B,YAAI,YAAY;AACf,kBAAQ,oBAAoB,UAAU;AAAA,QACvC;AAAA,MACF;AAEA,kBAAY,kBAAkB;AAAA,IAChC;AACA,WAAO,YAAY;AAAA,EACrB;AAAA,EASA,MAAMA,yBAAwB,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQjC,WAAW,qBAAqB;AAC9B,UAAI,CAAC,KAAK,eAAe,0BAA0B,wBAAwB,IAAI,CAAC,GAAG;AACjF,iBAAS,KAAK,SAAS;AACvB,cAAM,QAAQ,KAAK;AACnB,aAAK,uBAAuB,QAAQ,OAAO,KAAK,KAAK,EAAE,IAAI,OAAK,KAAK,UAAU,2BAA2B,CAAC,CAAC,IAAI,CAAC;AAAA,MACnH;AACA,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,OAAO,WAAW;AAChB,UAAI,CAAC,KAAK,eAAe,0BAA0B,eAAe,IAAI,CAAC,GAAG;AACxE,cAAM,YAAY;AAAA;AAAA,UAAgE;AAAA,QAAK;AACvF,YAAI,WAAW;AACb,oBAAU,SAAS;AAAA,QACrB;AACA,aAAK,cAAc;AACnB,aAAK,eAAe;AAAA,MACtB;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,OAAO,iBAAiB;AACtB,YAAM,QAAQ;AAAA;AAAA,QAAyD;AAAA,MAAK;AAC5E,UAAI,OAAO;AACQ,QAAC,KAAM,iBAAiB,KAAK;AAAA,MAChD;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,WAAW,cAAc;AACvB,UAAI,CAAC,KAAK;AAAA,QACR,0BAA0B,gBAAgB,IAAI;AAAA,MAAC,GAAG;AAClD,cAAM,YAAY;AAAA;AAAA,UAAgE;AAAA,QAAK;AACvF,aAAK,eAAe,OAAO;AAAA,UAAO,CAAC;AAAA,UACjC,aAAa,UAAU;AAAA,UACvB;AAAA;AAAA,YAAwD;AAAA,UAAK;AAAA,QAAC;AAAA,MAClE;AACA,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,OAAO,gBAAgB,MAAM;AAC3B,YAAM,OAAO,KAAK,YAAY,IAAI;AAClC,aAAO,QAAQ,KAAK;AAAA,IACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,wBAAwB;AACtB,6BAAuB;AACvB,WAAK,YAAY,SAAS;AAC1B,YAAM,sBAAsB;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,oBAAoB;AAClB,UAAI,MAAM,mBAAmB;AAC3B,cAAM,kBAAkB;AAAA,MAC1B;AACA,WAAK,kBAAkB;AAAA,IACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,uBAAuB;AACrB,UAAI,MAAM,sBAAsB;AAC9B,cAAM,qBAAqB;AAAA,MAC7B;AAAA,IACF;AAAA,EAEF;AAEA,SAAOA;AAER,CAAC;;;ACtNM,IAAM,UAAU;AAEhB,IAAM,WAAW,OAAO,YAAY,OAAO,SAAS,UAAU;AAyE9D,IAAM,eAAe,cAAc,UAAQ;AAQhD,QAAM,qBAAqB,gBAAgB,gBAAgB,IAAI,CAAC;AAahE,WAAS,iBAAiB,aAAa;AACrC,QAAI,CAAC,YAAY;AAAA,MACf,0BAA0B,sBAAsB,WAAW;AAAA,IAAC,GAAG;AAC/D,kBAAY,qBAAqB;AACjC,UAAI,QAAQ,YAAY;AACxB,eAAS,KAAK,OAAO;AACnB,YAAI,OAAO,MAAM,CAAC;AAClB,YAAI,WAAW,MAAM;AACnB,sBAAY,qBAAqB,YAAY,sBAAsB,CAAC;AACpE,sBAAY,mBAAmB,CAAC,IAAI;AAAA,QACtC;AAAA,MACF;AAAA,IACF;AACA,WAAO,YAAY;AAAA,EACrB;AAQA,WAAS,aAAa,aAAa;AACjC,QAAI,CAAC,YAAY;AAAA,MACf,0BAA0B,kBAAkB,WAAW;AAAA,IAAC,GAAG;AAC3D,kBAAY,iBACR,YAAY;AAAA,QACR,0BAA0B,aAAa,WAAW;AAAA,MAAC;AAAA;AAAA,QACb,YAAa;AAAA,UACvD;AAAA,IACN;AACA,WAAO,YAAY;AAAA,EACrB;AA4DA,WAAS,yBAAyBC,QAAO,MAAM,MAAM,UAAU;AAE7D,QAAI,KAAK,UAAU;AACjB,WAAK,WAAW;AAAA,IAClB;AAMA,QAAI,KAAK,UAAU;AACjB,UAAIA,OAAM,mBAAmB,IAAI,GAAG;AAClC,gBAAQ,KAAK,sCAAsC,IAAI,IAAI;AAAA,MAC7D,OAAO;AACL,QAAAA,OAAM,wBAAwB,MAAM,KAAK,UAAU,QAAQ;AAAA,MAC7D;AAAA,IACF;AACA,QAAI,KAAK,YAAY,CAACA,OAAM,mBAAmB,IAAI,GAAG;AACpD,MAAAA,OAAM,wBAAwB,MAAM,CAAC,KAAK,QAAQ;AAAA,IACpD,WAAW,KAAK,aAAa,SAASA,OAAM,mBAAmB,IAAI,GAAG;AACpE,cAAQ,KAAK,kCAAkC,IAAI,iBAAiB;AAAA,IACtE;AACA,QAAI,KAAK,sBAAsB,CAACA,OAAM,kBAAkB,IAAI,GAAG;AAC7D,MAAAA,OAAM,yBAAyB,IAAI;AAAA,IACrC,WAAW,KAAK,uBAAuB,SAASA,OAAM,kBAAkB,IAAI,GAAG;AAC7E,cAAQ,KAAK,mCAAmC,IAAI,kBAAkB;AAAA,IACxE;AACA,QAAI,KAAK,UAAU,CAACA,OAAM,iBAAiB,IAAI,GAAG;AAChD,MAAAA,OAAM,yBAAyB,IAAI;AAAA,IACrC,WAAW,KAAK,WAAW,SAASA,OAAM,iBAAiB,IAAI,GAAG;AAChE,cAAQ,KAAK,gCAAgC,IAAI,eAAe;AAAA,IAClE;AAEA,QAAI,KAAK,UAAU;AACjB,MAAAA,OAAM,wBAAwB,MAAM,KAAK,UAAU,SAAS,KAAK,QAAQ,CAAC;AAAA,IAC5E;AAEA,IAAAA,OAAM,2BAA2B,IAAI;AAAA,EACvC;AAYA,WAAS,qBAAqB,OAAO,UAAU,IAAI,SAAS;AAC1D,QAAI,CAAC,UAAU;AACb,YAAM,iBAAiB,SAAS,QAAQ,iBAAiB,OAAO;AAChE,YAAM,oBAAoB,mBAAmB,QAAQ;AAErD,YAAM,eAAe,wBAAwB,EAAE;AAC/C,YAAM,qBAAqB,SAAS,QAAQ;AAC5C,eAAS,MAAM,GAAG,MAAM,aAAa,QAAQ,OAAO;AAClD,YAAI,IAAI,aAAa,GAAG;AACxB,UAAE,cAAc,MAAM,kBAAkB,EAAE,aAAa,OAAO;AAC9D,iBAAS,QAAQ,aAAa,GAAG,kBAAkB;AAAA,MACrD;AAEA,UAAI,qBAAqB;AAEzB,eAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,KAAK;AACjD,YAAI,IAAI,kBAAkB,CAAC;AAC3B,YAAI,gBAAgB,eAAe,kBAAkB;AAGrD,YAAI,kBAAkB,GAAG;AACvB,cAAI,EAAE,UAAU,IAAI;AACpB,wBAAc,WAAW,aAAa,GAAG,aAAa;AAAA,QACxD,OAAO;AACL;AAAA,QACF;AACA,UAAE,cAAc,MAAM,kBAAkB,EAAE,aAAa,OAAO;AAAA,MAChE;AAAA,IACF;AACA,QAAI,OAAO,UAAU;AACnB,aAAO,SAAS,gBAAgB,UAAU,EAAE;AAAA,IAC9C;AAWA,QAAI,qCAAqC,YACrC,6BAA6B;AAE/B,YAAM,SAAS,SAAS,QAAQ,iBAAiB,OAAO;AACxD,UAAI,QAAQ;AACV,YAAI,MAAM;AACV,cAAM,KAAK,MAAM,EAAE,QAAQ,OAAK;AAC9B,iBAAO,EAAE;AACT,YAAE,WAAW,YAAY,CAAC;AAAA,QAC5B,CAAC;AACD,cAAM,cAAc,IAAI,cAAc;AACtC,cAAM,YAAY,YAAY,GAAG;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAUA,WAAS,yBAAyB,IAAI;AACpC,QAAI,WAAW;AAGf,QAAI,OAAO,CAAC,wBAAwB,6BAA6B;AAC/D;AAAA,MACI,UAAU,OAAO,IAAI,UAAU;AAGnC,UAAI,wBAAwB,CAAC,UAAU;AACrC,cAAM,IAAI,MAAM,mEAAmE,EAAE,EAAE;AAAA,MACzF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EASA,MAAMC,wBAAuB,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAO9C,WAAW,wBAAwB;AACjC,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,OAAO,iBAAiB;AAGtB,yBAAmB,eAAe,KAAK,IAAI;AAC3C,YAAM,YAAY,aAAa,IAAI;AACnC,UAAI,WAAW;AACb,aAAK,gBAAgB,WAAW,KAAK,WAAW;AAAA,MAClD;AACA,WAAK,iBAAiB;AAAA,IACxB;AAAA;AAAA,IAGA,OAAO,mBAAmB;AAExB,UAAI;AAAA;AAAA,QAAqD,KAAM;AAAA;AAC/D,UAAI,UAAU;AACZ,YAAI,OAAO,aAAa,UAAU;AAChC,kBAAQ,MAAM,iDAAiD;AAC/D,qBAAW;AAAA,QACb,WAAW,CAAC,qBAAqB;AAC/B,qBAAW,SAAS,UAAU,IAAI;AAAA,QACpC;AAAA,MACF;AAGA,WAAK,UAAU,YAAY;AAAA,IAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,OAAO,iBAAiB,OAAO;AAC7B,eAAS,KAAK,OAAO;AACnB;AAAA;AAAA,UACsB,KAAK;AAAA,UAAY;AAAA,UAAG,MAAM,CAAC;AAAA,UAAG;AAAA,QAAK;AAAA,MAC3D;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,OAAO,gBAAgB,WAAW,YAAY;AAC5C,YAAMD,SAAQ,KAAK;AACnB,eAAS,IAAE,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,QAAAA,OAAM,sBAAsB,UAAU,CAAC,GAAG,UAAU;AAAA,MACtD;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA2CA,WAAW,WAAW;AAcpB,UAAI,CAAC,KAAK,eAAe,0BAA0B,aAAa,IAAI,CAAC,GAAG;AACtE,YAAI,gBAAgB,KAAK,UAAU;AAAA,UACjC,0BAA0B,aAAa,KAAK,SAAS;AAAA,QAAC,IACtD,KAAK,UAAU,YAAY;AAG7B,YAAI,OAAO,kBAAkB,YAAY;AACvC,0BAAgB,cAAc;AAAA,QAChC;AACA,aAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAOH,kBAAkB,SAAY;AAAA;AAAA,UAE5B,KAAK,eAAe,0BAA0B,MAAM,IAAI,CAAC,KAC1D;AAAA;AAAA,YAAkE,KAAM;AAAA,UAAE;AAAA;AAAA,UAG3E,OAAO;AAAA;AAAA,YAAwD,KAAM;AAAA,UAAS,EAAE,YAAY;AAAA;AAAA,MAChG;AACA,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,WAAW,SAAS,OAAO;AACzB,WAAK,YAAY;AAAA,IACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsBA,WAAW,aAAa;AACtB,UAAI,CAAC,KAAK,eAAe,0BAA0B,eAAe,IAAI,CAAC,GAAG;AACxE,cAAM,OAAO,KAAK;AAClB,YAAI,MAAM;AACR,eAAK,cAAc,YAAY,KAAK,GAAG;AAAA,QACzC,OAAO;AACL,gBAAM,SAAS,UAAU;AAAA;AAAA,YAAiD,KAAM;AAAA,UAAE;AAClF,eAAK,cAAe,UAAU,OAAO,aACnC,OAAO;AAAA;AAAA,YAAwD,KAAM;AAAA,UAAS,EAAE,YAAY;AAAA,QAChG;AAAA,MACF;AACA,aAAO,KAAK;AAAA,IACd;AAAA,IAEA,cAAc;AACZ,YAAM;AAEN,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAEL,WAAK;AAAA,IACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,wBAAwB;AACtB,WAAK,YAAY,SAAS;AAG1B,WAAK,YAAY;AAAA;AAAA,QAA8C,KAAM;AAAA,MAAS;AAC9E,YAAM,sBAAsB;AAE5B,WAAK,WAAW;AAChB,WAAK,aAAa,KAAK,YAAY;AAEnC,UAAI,KAAK,iBAAiB,KAAK,WAAW;AAC1C,UAAI,CAAC,IAAI;AACP;AAAA,MACF;AACA,eAAS,KAAK,IAAI;AAChB,YAAI,OAAO,GAAG,CAAC;AACf,YAAI,KAAK,yBAAyB,CAAC,GAAG;AACpC,cAAI,QAAQ,OAAO,KAAK,SAAS,aAC/B,KAAK,MAAM,KAAK,IAAI,IACpB,KAAK;AAGP,cAAI,KAAK,aAAa,CAAC,GAAG;AACxB,iBAAK,oBAAoB,GAAG,OAAO,IAAI;AAAA,UACzC,OAAO;AACL,iBAAK,CAAC,IAAI;AAAA,UACZ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,yBAAyB,UAAU;AACjC,aAAO,CAAC,KAAK,eAAe,QAAQ;AAAA,IACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWA,OAAO,kBAAkB,SAAS,SAAS;AACzC,aAAO,WAAW,SAAS,OAAO;AAAA,IACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,OAAO,kBAAkB,IAAI;AAE3B,YAAM,WAAW,KAAK,UAAU;AAChC,UAAI,YAAY,CAAC,SAAS,oBAAoB;AAC5C,iBAAS,qBAAqB;AAC9B,cAAM,aAAa,KAAK;AACxB,cAAM,UAAU,aAAa,WAAW,UAAU,IAAI;AAEtD,6BAAqB,MAAM,UAAU,IAAI,OAAO;AAChD,aAAK,UAAU,cAAc,QAAQ;AAAA,MACvC;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,oBAAoB;AAClB,UAAI,OAAO,YAAY,KAAK,WAAW;AACrC,eAAO,SAAS;AAAA;AAAA,UAAyC;AAAA,QAAK;AAAA,MAChE;AACA,YAAM,kBAAkB;AAAA,IAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,QAAQ;AACN,UAAI,KAAK,WAAW;AAClB,aAAK,OAAO,KAAK,eAAe,KAAK,SAAS;AAC9C,aAAK,IAAI,KAAK,KAAK;AAAA,MACrB;AACA,YAAM,MAAM;AAAA,IACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,gBAAgB;AACd,UAAI,KAAK,WAAW;AAClB,aAAK,OAAO,KAAK;AAAA;AAAA,UAA0C,KAAK;AAAA,QAAK;AAAA,MACvE;AAKA,YAAM,cAAc;AAAA,IACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,WAAW,KAAK;AACd,YAAM,IAAI,KAAK,IAAI;AACnB,UAAI,EAAE,cAAc;AAClB,YAAI,KAAK;AACP,cAAI,CAAC,EAAE,YAAY;AACjB,cAAE,aAAa,EAAC,MAAM,QAAQ,sBAAsB,IAAG,CAAC;AACxD,cAAE,WAAW,YAAY,GAAG;AAG5B,gBAAI,KAAK,YAAY,aAAa;AAChC,gBAAE,WAAW,qBAAqB,CAAC,KAAK,YAAY,WAAW;AAAA,YACjE;AAAA,UACF;AACA,cAAI,qBAAqB,OAAO,UAAU;AACxC,mBAAO,SAAS,aAAa,EAAE,UAAU;AAAA,UAC3C;AACA,iBAAO,EAAE;AAAA,QACX;AACA,eAAO;AAAA,MACT,OAAO;AACL,cAAM,IAAI,MAAM,2IAG6C;AAAA,MAC/D;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAwBA,aAAa,YAAY;AACvB,UAAI,OAAO,UAAU;AACnB,eAAO,SAAS;AAAA;AAAA,UAAyC;AAAA,UAAO;AAAA,QAAU;AAAA,MAC5E;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBA,WAAW,KAAKE,OAAM;AACpB,UAAI,CAACA,SAAQ,KAAK,YAAY;AAC5B,QAAAA,QAAO,WAAW,KAAK,UAAU;AAAA,MACnC;AACA,aAAO,WAAW,KAAKA,KAAI;AAAA,IAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,OAAO,sBAAsB,UAAU,cAAc,UAAU;AAC7D,mBAAa,aAAa,aAAa,cAAc,KAAK;AAG1D,aAAO,mBAAmB,sBAAsB;AAAA,QAC9C;AAAA,QAAM;AAAA,QAAU;AAAA,QAAc;AAAA,MAAQ;AAAA,IAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,OAAO,2BAA2B,cAAc,MAAM,QAAQ;AAS5D,UAAI,kBAAkB,EAAE,QAAQ,KAAK;AAAA;AAAA,MAGjC,EAAE,OAAO,KAAK,KAAK,aAAa,OAAO,KAAK,KAAK,UAAU;AAAA;AAAA;AAAA;AAAA,MAK3D,CAAC,OAAO,KAAK,KAAK,YAAY,CAAC,aAAa,gBAAgB;AAC9D,gBAAQ,KAAK,aAAa,IAAI,sFACK;AAAA,MACrC;AAGA,aAAO,mBAAmB,2BAA2B;AAAA,QACnD;AAAA,QAAM;AAAA,QAAc;AAAA,QAAM;AAAA,MAAM;AAAA,IACpC;AAAA,EAEF;AAEA,SAAOD;AACT,CAAC;;;AC90BM,IAAM,iBAAiB,aAAa,WAAW;",
  "names": ["root", "PropertiesChanged", "proto", "PropertyAccessors", "root", "TemplateStamp", "dedupeId", "i", "PropertyEffects", "changedProps", "hasPaths", "root", "matches", "PropertiesMixin", "proto", "PolymerElement", "base"]
}
