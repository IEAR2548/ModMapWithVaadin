import {
  Select
} from "./chunk-RCJSVF2D.js";
import "./chunk-S5QLJC4T.js";
import {
  TextField
} from "./chunk-Y2AJMF5G.js";
import "./chunk-4Z7GPLQJ.js";
import {
  GridColumn
} from "./chunk-D6FJLU7Z.js";
import "./chunk-435THF4U.js";
import "./chunk-5ESYFZ3Z.js";
import "./chunk-WGJN77FX.js";
import "./chunk-HKTMLLWR.js";
import "./chunk-3C2DXTKX.js";
import "./chunk-T3TK66R3.js";
import "./chunk-TYNXAAOB.js";
import "./chunk-KDMU7KRZ.js";
import {
  get,
  set
} from "./chunk-U4OQEY5H.js";
import "./chunk-5J2BD6XO.js";
import {
  Checkbox
} from "./chunk-ASIVB3N2.js";
import "./chunk-DUUC5ZSA.js";
import "./chunk-HAU22DCE.js";
import "./chunk-RS5C4C66.js";
import "./chunk-QVZYNUS5.js";
import "./chunk-BM4Y2K3C.js";
import "./chunk-SX3OERDA.js";
import "./chunk-F7QS6G5O.js";
import "./chunk-3U65M3F2.js";
import "./chunk-JZD2KJJX.js";
import "./chunk-ZFTJKNOJ.js";
import "./chunk-W2UZPIBV.js";
import "./chunk-6UYCWOWN.js";
import "./chunk-IMJTZNS3.js";
import "./chunk-TNTYFQYJ.js";
import "./chunk-KMJME6UN.js";
import "./chunk-XQZHWSYU.js";
import "./chunk-DJVSXF3M.js";
import "./chunk-NQUFUYCJ.js";
import "./chunk-H2CSL527.js";
import "./chunk-GZUGITXY.js";
import "./chunk-B2HJJUI6.js";
import "./chunk-UF5ES3VB.js";
import "./chunk-U2M46WVE.js";
import "./chunk-T243RQF2.js";
import "./chunk-NPC7FAUI.js";
import "./chunk-DMZMFF2U.js";
import "./chunk-TAIFBA4G.js";
import "./chunk-FFK3QFYP.js";
import "./chunk-JN3IROFX.js";
import "./chunk-FIRGGFKS.js";
import "./chunk-4SWSK3CD.js";
import "./chunk-HXO5X6HG.js";
import "./chunk-3YPW2P7U.js";
import "./chunk-VNRF6E57.js";
import "./chunk-MY27H5BQ.js";
import "./chunk-TH52KELX.js";
import "./chunk-QN4QZSZG.js";
import "./chunk-RQAC3AN6.js";
import "./chunk-QZAHM4JN.js";
import "./chunk-HTUMVTZR.js";
import "./chunk-CU6AK3MF.js";
import "./chunk-7TDF2HKG.js";
import "./chunk-CCS6CDM7.js";
import "./chunk-XINNUJWD.js";
import "./chunk-WOH7SGKZ.js";
import "./chunk-E33ETZLW.js";
import "./chunk-CXDC5LNX.js";
import "./chunk-ARCEVOS6.js";
import "./chunk-JOZKWWH6.js";
import "./chunk-BJXKYFZQ.js";
import "./chunk-JJ5PH6RA.js";
import "./chunk-3DUAHG2W.js";
import {
  registerStyles
} from "./chunk-KEWLZU7R.js";
import "./chunk-QBLL3FQM.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import "./chunk-MTSXO4VS.js";
import "./chunk-YBEXGSZO.js";
import "./chunk-MMSAJ3TN.js";
import "./chunk-KYHIEJIL.js";
import "./chunk-NZOAG24Y.js";
import "./chunk-KV4N6HS4.js";
import "./chunk-QO5P4LIH.js";
import "./chunk-3URU5I64.js";
import "./chunk-2VJ6XAW7.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";
import "./chunk-4QYCOPDF.js";
import "./chunk-DWA4UIM3.js";

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-checkbox.js
var GridProEditCheckbox = class extends Checkbox {
  static get is() {
    return "vaadin-grid-pro-edit-checkbox";
  }
};
defineCustomElement(GridProEditCheckbox);

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-editor-styles.js
var gridProEditor = css`
  :host([theme~='grid-pro-editor']) {
    position: absolute;
    inset: 0;
    padding: 0;
    will-change: transform;
    font-size: inherit;
    --lumo-text-field-size: 27px;
    /* outline similar to what grid uses */
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  :host([theme~='grid-pro-editor']) [part='input-field'] {
    padding: 0;
    border-radius: 0;
    flex-grow: 1;
    font-weight: 400;
    --vaadin-input-field-border-color: transparent;
  }

  /* reset outline inherited from text-field */
  :host([theme~='grid-pro-editor'][focus-ring]) [part='input-field'] {
    box-shadow: none;
  }

  :host([theme~='grid-pro-editor']) ::slotted(input) {
    padding: 0 var(--lumo-space-m);
    font-size: inherit;
  }
`;
registerStyles("", gridProEditor, { moduleId: "lumo-grid-pro-editor" });

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-edit-select-styles.js
var gridProEditSelect = css`
  :host([theme~='grid-pro-editor']) [part='toggle-button'] {
    margin-right: var(--lumo-space-xs);
  }

  :host([theme~='grid-pro-editor']) [part='input-field'] ::slotted([slot='value']) {
    box-sizing: border-box;
    padding: 0 var(--lumo-space-m);
    font-size: var(--lumo-font-size-m);
    /* prevent selection on editor focus */
    -webkit-user-select: none;
    user-select: none;
  }
`;
registerStyles("vaadin-grid-pro-edit-select", [gridProEditor, gridProEditSelect], {
  moduleId: "lumo-grid-pro-edit-select"
});

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-select-mixin.js
var GridProEditSelectMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      options: {
        type: Array,
        value: () => []
      },
      _grid: {
        type: Object
      },
      _initialized: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["_optionsChanged(options)"];
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
  _onKeyDown(e) {
    super._onKeyDown(e);
    if (this.options.length === 0 && /^(ArrowDown|Down|ArrowUp|Up|Enter|SpaceBar| )$/u.test(e.key)) {
      console.warn('Missing "editorOptions" for <vaadin-grid-pro-edit-column> select editor!');
    }
    if (e.defaultPrevented) {
      e.stopPropagation();
    }
  }
  /**
   * Override list-box event listener inherited from `Select`:
   * - Enter: set flag for moving to next row on value change,
   * - Tab: switch to next cell when "singleCellEdit" is false.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDownInside(event) {
    if (event.keyCode === 13) {
      this._enterKeydown = event;
    }
    if (event.keyCode === 9) {
      if (!this._grid.singleCellEdit) {
        this._grid._switchEditCell(event);
      }
    }
    super._onKeyDownInside(event);
  }
  _valueChanged(value, oldValue) {
    super._valueChanged(value, oldValue);
    if (value === "" && oldValue === void 0) {
      return;
    }
    if (this._initialized) {
      const enter = this._enterKeydown;
      if (enter && this._grid.enterNextRow) {
        this._grid._switchEditCell(enter);
      } else if (this._grid.singleCellEdit) {
        this._grid._stopEdit(false, true);
      } else {
        this.focus();
      }
    }
  }
  _optionsChanged(options) {
    if (options && options.length) {
      this.items = options.map((option) => ({
        label: option,
        value: option
      }));
      this._overlayElement || (this._overlayElement = this.shadowRoot.querySelector("vaadin-select-overlay"));
      this._overlayElement.addEventListener("vaadin-overlay-outside-click", () => {
        this._grid._stopEdit();
      });
      setTimeout(() => {
        this.opened = true;
        this._initialized = true;
      });
    }
  }
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-select.js
var GridProEditSelect = class extends GridProEditSelectMixin(Select) {
  static get is() {
    return "vaadin-grid-pro-edit-select";
  }
};
defineCustomElement(GridProEditSelect);

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-edit-text-field-styles.js
registerStyles("vaadin-grid-pro-edit-text-field", gridProEditor, {
  moduleId: "lumo-grid-pro-edit-text-field"
});

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-text-field.js
var GridProEditText = class extends TextField {
  static get is() {
    return "vaadin-grid-pro-edit-text-field";
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
};
defineCustomElement(GridProEditText);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-column-mixin.js
var GridProEditColumnMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * Custom function for rendering the cell content in edit mode.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your editor component to it.
       * - `column` The `<vaadin-grid-pro-edit-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       * @type {!GridBodyRenderer | null | undefined}
       */
      editModeRenderer: {
        type: Function,
        sync: true
      },
      /**
       * The list of options which should be passed to cell editor component.
       * Used with the `select` editor type, to provide a list of items.
       * @type {!Array<string>}
       */
      editorOptions: {
        type: Array,
        value: () => []
      },
      /**
       * Type of the cell editor component to be rendered. Allowed values:
       * - `text` (default) - renders a text field
       * - `checkbox` - renders a checkbox
       * - `select` - renders a select with a list of items passed as `editorOptions`
       *
       * Editor type is set to `custom` when `editModeRenderer` is set.
       * @attr {text|checkbox|select|custom} editor-type
       * @type {!GridProEditorType}
       */
      editorType: {
        type: String,
        notify: true,
        // FIXME(web-padawan): needed by Flow counterpart
        value: "text"
      },
      /**
       * Path of the property used for the value of the editor component.
       * @attr {string} editor-value-path
       * @type {string}
       */
      editorValuePath: {
        type: String,
        value: "value"
      },
      /**
       * JS Path of the property in the item used for the editable content.
       */
      path: {
        type: String,
        observer: "_pathChanged",
        sync: true
      },
      /**
       * A function to check whether a specific cell of this column can be
       * edited. This allows to disable editing of individual rows or cells,
       * based on the item.
       *
       * Receives a `model` object containing the item for an individual row,
       * and should return a boolean indicating whether the column's cell in
       * that row is editable.
       *
       * The `model` object contains:
       * - `model.index` The index of the item.
       * - `model.item` The item.
       * - `model.expanded` Sublevel toggle state.
       * - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       * - `model.selected` Selected state.
       *
       * @type {(model: GridItemModel) => boolean}
       */
      isCellEditable: {
        type: Function,
        observer: "_isCellEditableChanged"
      },
      /** @private */
      _oldRenderer: Function
    };
  }
  static get observers() {
    return ["_editModeRendererChanged(editModeRenderer, __initialized)"];
  }
  constructor() {
    super();
    this._focusButtonMode = navigator.platform.includes("Mac");
    this.__editModeRenderer = function(root, column) {
      const cell = root.assignedSlot.parentNode;
      const tagName = column._getEditorTagName(cell);
      if (!root.firstElementChild || root.firstElementChild.localName.toLowerCase() !== tagName) {
        root.innerHTML = `
          <${tagName}></${tagName}>
        `;
      }
    };
  }
  /** @private */
  _pathChanged(path) {
    if (!path || path.length === 0) {
      throw new Error("You should specify the path for the edit column");
    }
  }
  /** @private */
  _isCellEditableChanged() {
    this._grid.requestContentUpdate();
  }
  /** @private */
  _editModeRendererChanged(renderer) {
    if (renderer) {
      this.editorType = "custom";
    } else if (this._oldRenderer) {
      this.editorType = "text";
    }
    this._oldRenderer = renderer;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {string}
   * @protected
   */
  _getEditorTagName(cell) {
    return this.editorType === "custom" ? this._getEditorComponent(cell).localName : this._getTagNameByType();
  }
  /**
   * @param {!HTMLElement} cell
   * @return {HTMLElement | null}
   * @protected
   */
  _getEditorComponent(cell) {
    return this.editorType === "custom" ? cell._content.firstElementChild : cell._content.querySelector(this._getEditorTagName(cell));
  }
  /** @private */
  _getTagNameByType() {
    let type;
    switch (this.editorType) {
      case "checkbox":
        type = "checkbox";
        break;
      case "select":
        type = "select";
        break;
      case "text":
      default:
        type = "text-field";
        break;
    }
    return this.constructor.is.replace("column", type);
  }
  /** @private */
  _focusEditor(editor) {
    editor.focus();
    if (this.editorType === "checkbox") {
      editor.setAttribute("focus-ring", "");
    } else if (editor instanceof HTMLInputElement) {
      editor.select();
    } else if (editor.focusElement && editor.focusElement instanceof HTMLInputElement) {
      editor.focusElement.select();
    }
  }
  /**
   * @param {!HTMLElement} editor
   * @return {unknown}
   * @protected
   */
  _getEditorValue(editor) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    return get(path, editor);
  }
  /** @private */
  _renderEditor(cell, model) {
    cell.__savedRenderer = this._renderer || cell._renderer;
    cell._renderer = this.editModeRenderer || this.__editModeRenderer;
    if (cell._focusButton) {
      cell._focusButton.removeAttribute("role");
    }
    this._clearCellContent(cell);
    this._runRenderer(cell._renderer, cell, model);
  }
  /** @private */
  _removeEditor(cell, _model) {
    if (!cell.__savedRenderer) {
      return;
    }
    cell._renderer = cell.__savedRenderer;
    cell.__savedRenderer = void 0;
    this._clearCellContent(cell);
    if (cell._focusButton) {
      cell._focusButton.setAttribute("role", "button");
    }
    this.__renderCellsContent(cell._renderer, [cell]);
  }
  /** @private */
  _setEditorOptions(editor) {
    if (this.editorOptions && this.editorOptions.length) {
      editor.options = this.editorOptions;
    }
  }
  /** @private */
  _setEditorValue(editor, value) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    value = this.editorType === "checkbox" && typeof value === "string" ? value === "true" : value;
    set(path, value, editor);
    if (editor.notifyPath) {
      editor.notifyPath(path, value);
    }
  }
  /**
   * @param {!HTMLElement} cell
   * @param {!GridItemModel} model
   * @protected
   */
  _startCellEdit(cell, model) {
    this._renderEditor(cell, model);
    const editor = this._getEditorComponent(cell);
    editor.addEventListener("focusout", this._grid.__boundEditorFocusOut);
    editor.addEventListener("focusin", this._grid.__boundEditorFocusIn);
    this._setEditorOptions(editor);
    this._setEditorValue(editor, get(this.path, model.item));
    editor._grid = this._grid;
    if (editor.updateComplete) {
      editor.updateComplete.then(() => this._focusEditor(editor));
    } else {
      this._focusEditor(editor);
    }
  }
  /**
   * @param {!HTMLElement} cell
   * @param {!GridItemModel} model
   * @protected
   */
  _stopCellEdit(cell, model) {
    this._removeEditor(cell, model);
  }
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-column.js
var GridProEditColumn = class extends GridProEditColumnMixin(GridColumn) {
  static get is() {
    return "vaadin-grid-pro-edit-column";
  }
};
defineCustomElement(GridProEditColumn);
/*! Bundled license information:

@vaadin/grid-pro/src/vaadin-grid-pro-edit-checkbox.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-select-mixin.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-select.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-text-field.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-column-mixin.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-column.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)
*/
//# sourceMappingURL=@vaadin_grid-pro_theme_lumo_vaadin-grid-pro-edit-column__js.js.map
