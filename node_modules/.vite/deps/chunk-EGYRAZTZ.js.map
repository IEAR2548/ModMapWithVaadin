{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/iron-list-core.js", "../../@vaadin/component-base/src/virtualizer-iron-list-adapter.js", "../../@vaadin/component-base/src/virtualizer.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { animationFrame, idlePeriod, microTask } from './async.js';\r\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\r\n\r\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/u);\r\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\r\nconst DEFAULT_PHYSICAL_COUNT = 3;\r\n\r\n/**\r\n * DO NOT EDIT THIS FILE!\r\n *\r\n * This file includes the iron-list scrolling engine copied from\r\n * https://github.com/PolymerElements/iron-list/blob/master/iron-list.js\r\n *\r\n * If something in the scrolling engine needs to be changed\r\n * for the virtualizer's purposes, override a function\r\n * in virtualizer-iron-list-adapter.js instead of changing it here.\r\n * If a function on this file is no longer needed, the code can be safely deleted.\r\n *\r\n * This will allow us to keep the iron-list code here as close to\r\n * the original as possible.\r\n */\r\nexport const ironList = {\r\n  /**\r\n   * The ratio of hidden tiles that should remain in the scroll direction.\r\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\r\n   * directions.\r\n   */\r\n  _ratio: 0.5,\r\n\r\n  /**\r\n   * The padding-top value for the list.\r\n   */\r\n  _scrollerPaddingTop: 0,\r\n\r\n  /**\r\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\r\n   */\r\n  _scrollPosition: 0,\r\n\r\n  /**\r\n   * The sum of the heights of all the tiles in the DOM.\r\n   */\r\n  _physicalSize: 0,\r\n\r\n  /**\r\n   * The average `offsetHeight` of the tiles observed till now.\r\n   */\r\n  _physicalAverage: 0,\r\n\r\n  /**\r\n   * The number of tiles which `offsetHeight` > 0 observed until now.\r\n   */\r\n  _physicalAverageCount: 0,\r\n\r\n  /**\r\n   * The Y position of the item rendered in the `_physicalStart`\r\n   * tile relative to the scrolling list.\r\n   */\r\n  _physicalTop: 0,\r\n\r\n  /**\r\n   * The number of items in the list.\r\n   */\r\n  _virtualCount: 0,\r\n\r\n  /**\r\n   * The estimated scroll height based on `_physicalAverage`\r\n   */\r\n  _estScrollHeight: 0,\r\n\r\n  /**\r\n   * The scroll height of the dom node\r\n   */\r\n  _scrollHeight: 0,\r\n\r\n  /**\r\n   * The height of the list. This is referred as the viewport in the context of\r\n   * list.\r\n   */\r\n  _viewportHeight: 0,\r\n\r\n  /**\r\n   * The width of the list. This is referred as the viewport in the context of\r\n   * list.\r\n   */\r\n  _viewportWidth: 0,\r\n\r\n  /**\r\n   * An array of DOM nodes that are currently in the tree\r\n   * @type {?Array<!HTMLElement>}\r\n   */\r\n  _physicalItems: null,\r\n\r\n  /**\r\n   * An array of heights for each item in `_physicalItems`\r\n   * @type {?Array<number>}\r\n   */\r\n  _physicalSizes: null,\r\n\r\n  /**\r\n   * A cached value for the first visible index.\r\n   * See `firstVisibleIndex`\r\n   * @type {?number}\r\n   */\r\n  _firstVisibleIndexVal: null,\r\n\r\n  /**\r\n   * A cached value for the last visible index.\r\n   * See `lastVisibleIndex`\r\n   * @type {?number}\r\n   */\r\n  _lastVisibleIndexVal: null,\r\n\r\n  /**\r\n   * The max number of pages to render. One page is equivalent to the height of\r\n   * the list.\r\n   */\r\n  _maxPages: 2,\r\n\r\n  /**\r\n   * The cost of stamping a template in ms.\r\n   */\r\n  _templateCost: 0,\r\n\r\n  /**\r\n   * The bottom of the physical content.\r\n   */\r\n  get _physicalBottom() {\r\n    return this._physicalTop + this._physicalSize;\r\n  },\r\n\r\n  /**\r\n   * The bottom of the scroll.\r\n   */\r\n  get _scrollBottom() {\r\n    return this._scrollPosition + this._viewportHeight;\r\n  },\r\n\r\n  /**\r\n   * The n-th item rendered in the last physical item.\r\n   */\r\n  get _virtualEnd() {\r\n    return this._virtualStart + this._physicalCount - 1;\r\n  },\r\n\r\n  /**\r\n   * The height of the physical content that isn't on the screen.\r\n   */\r\n  get _hiddenContentSize() {\r\n    return this._physicalSize - this._viewportHeight;\r\n  },\r\n\r\n  /**\r\n   * The maximum scroll top value.\r\n   */\r\n  get _maxScrollTop() {\r\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\r\n  },\r\n\r\n  /**\r\n   * The largest n-th value for an item such that it can be rendered in\r\n   * `_physicalStart`.\r\n   */\r\n  get _maxVirtualStart() {\r\n    const virtualCount = this._virtualCount;\r\n    return Math.max(0, virtualCount - this._physicalCount);\r\n  },\r\n\r\n  get _virtualStart() {\r\n    return this._virtualStartVal || 0;\r\n  },\r\n\r\n  set _virtualStart(val) {\r\n    val = this._clamp(val, 0, this._maxVirtualStart);\r\n    this._virtualStartVal = val;\r\n  },\r\n\r\n  get _physicalStart() {\r\n    return this._physicalStartVal || 0;\r\n  },\r\n\r\n  /**\r\n   * The k-th tile that is at the top of the scrolling list.\r\n   */\r\n  set _physicalStart(val) {\r\n    val %= this._physicalCount;\r\n    if (val < 0) {\r\n      val = this._physicalCount + val;\r\n    }\r\n    this._physicalStartVal = val;\r\n  },\r\n\r\n  /**\r\n   * The k-th tile that is at the bottom of the scrolling list.\r\n   */\r\n  get _physicalEnd() {\r\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\r\n  },\r\n\r\n  get _physicalCount() {\r\n    return this._physicalCountVal || 0;\r\n  },\r\n\r\n  set _physicalCount(val) {\r\n    this._physicalCountVal = val;\r\n  },\r\n\r\n  /**\r\n   * An optimal physical size such that we will have enough physical items\r\n   * to fill up the viewport and recycle when the user scrolls.\r\n   *\r\n   * This default value assumes that we will at least have the equivalent\r\n   * to a viewport of physical items above and below the user's viewport.\r\n   */\r\n  get _optPhysicalSize() {\r\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\r\n  },\r\n\r\n  /**\r\n   * True if the current list is visible.\r\n   */\r\n  get _isVisible() {\r\n    return Boolean(this.offsetWidth || this.offsetHeight);\r\n  },\r\n\r\n  /**\r\n   * Gets the index of the first visible item in the viewport.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get firstVisibleIndex() {\r\n    let idx = this._firstVisibleIndexVal;\r\n    if (idx == null) {\r\n      let physicalOffset = this._physicalTop + this._scrollOffset;\r\n\r\n      idx =\r\n        this._iterateItems((pidx, vidx) => {\r\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\r\n\r\n          if (physicalOffset > this._scrollPosition) {\r\n            return vidx;\r\n          }\r\n        }) || 0;\r\n      this._firstVisibleIndexVal = idx;\r\n    }\r\n    return idx;\r\n  },\r\n\r\n  /**\r\n   * Gets the index of the last visible item in the viewport.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get lastVisibleIndex() {\r\n    let idx = this._lastVisibleIndexVal;\r\n    if (idx == null) {\r\n      let physicalOffset = this._physicalTop + this._scrollOffset;\r\n      this._iterateItems((pidx, vidx) => {\r\n        if (physicalOffset < this._scrollBottom) {\r\n          idx = vidx;\r\n        }\r\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\r\n      });\r\n\r\n      this._lastVisibleIndexVal = idx;\r\n    }\r\n    return idx;\r\n  },\r\n\r\n  get _scrollOffset() {\r\n    return this._scrollerPaddingTop + this.scrollOffset;\r\n  },\r\n\r\n  /**\r\n   * Recycles the physical items when needed.\r\n   */\r\n  _scrollHandler() {\r\n    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\r\n    let delta = scrollTop - this._scrollPosition;\r\n    const isScrollingDown = delta >= 0;\r\n    // Track the current scroll position.\r\n    this._scrollPosition = scrollTop;\r\n    // Clear indexes for first and last visible indexes.\r\n    this._firstVisibleIndexVal = null;\r\n    this._lastVisibleIndexVal = null;\r\n    // Random access.\r\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\r\n      delta -= this._scrollOffset;\r\n      const idxAdjustment = Math.round(delta / this._physicalAverage);\r\n      this._virtualStart += idxAdjustment;\r\n      this._physicalStart += idxAdjustment;\r\n      // Estimate new physical offset based on the virtual start index.\r\n      // adjusts the physical start position to stay in sync with the clamped\r\n      // virtual start index. It's critical not to let this value be\r\n      // more than the scroll position however, since that would result in\r\n      // the physical items not covering the viewport, and leading to\r\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\r\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\r\n      this._update();\r\n    } else if (this._physicalCount > 0) {\r\n      const reusables = this._getReusables(isScrollingDown);\r\n      if (isScrollingDown) {\r\n        this._physicalTop = reusables.physicalTop;\r\n        this._virtualStart += reusables.indexes.length;\r\n        this._physicalStart += reusables.indexes.length;\r\n      } else {\r\n        this._virtualStart -= reusables.indexes.length;\r\n        this._physicalStart -= reusables.indexes.length;\r\n      }\r\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\r\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns an object that contains the indexes of the physical items\r\n   * that might be reused and the physicalTop.\r\n   *\r\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\r\n   */\r\n  _getReusables(fromTop) {\r\n    let ith, offsetContent, physicalItemHeight;\r\n    const idxs = [];\r\n    const protectedOffsetContent = this._hiddenContentSize * this._ratio;\r\n    const virtualStart = this._virtualStart;\r\n    const virtualEnd = this._virtualEnd;\r\n    const physicalCount = this._physicalCount;\r\n    let top = this._physicalTop + this._scrollOffset;\r\n    const bottom = this._physicalBottom + this._scrollOffset;\r\n    // This may be called outside of a scrollHandler, so use last cached position\r\n    const scrollTop = this._scrollPosition;\r\n    const scrollBottom = this._scrollBottom;\r\n\r\n    if (fromTop) {\r\n      ith = this._physicalStart;\r\n      offsetContent = scrollTop - top;\r\n    } else {\r\n      ith = this._physicalEnd;\r\n      offsetContent = bottom - scrollBottom;\r\n    }\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\r\n      offsetContent -= physicalItemHeight;\r\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\r\n        break;\r\n      }\r\n      if (fromTop) {\r\n        // Check that index is within the valid range.\r\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\r\n          break;\r\n        }\r\n        // Check that the index is not visible.\r\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\r\n          break;\r\n        }\r\n        idxs.push(ith);\r\n        top += physicalItemHeight;\r\n        ith = (ith + 1) % physicalCount;\r\n      } else {\r\n        // Check that index is within the valid range.\r\n        if (virtualStart - idxs.length <= 0) {\r\n          break;\r\n        }\r\n        // Check that the index is not visible.\r\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\r\n          break;\r\n        }\r\n        idxs.push(ith);\r\n        top -= physicalItemHeight;\r\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\r\n      }\r\n    }\r\n    return { indexes: idxs, physicalTop: top - this._scrollOffset };\r\n  },\r\n\r\n  /**\r\n   * Update the list of items, starting from the `_virtualStart` item.\r\n   * @param {!Array<number>=} itemSet\r\n   * @param {!Array<number>=} movingUp\r\n   */\r\n  _update(itemSet, movingUp) {\r\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\r\n      return;\r\n    }\r\n    this._assignModels(itemSet);\r\n    this._updateMetrics(itemSet);\r\n    // Adjust offset after measuring.\r\n    if (movingUp) {\r\n      while (movingUp.length) {\r\n        const idx = movingUp.pop();\r\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\r\n      }\r\n    }\r\n    this._positionItems();\r\n    this._updateScrollerSize();\r\n  },\r\n\r\n  _isClientFull() {\r\n    return (\r\n      this._scrollBottom !== 0 &&\r\n      this._physicalBottom - 1 >= this._scrollBottom &&\r\n      this._physicalTop <= this._scrollPosition\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Increases the pool size.\r\n   */\r\n  _increasePoolIfNeeded(count) {\r\n    const nextPhysicalCount = this._clamp(\r\n      this._physicalCount + count,\r\n      DEFAULT_PHYSICAL_COUNT,\r\n      this._virtualCount - this._virtualStart,\r\n    );\r\n    const delta = nextPhysicalCount - this._physicalCount;\r\n    let nextIncrease = Math.round(this._physicalCount * 0.5);\r\n\r\n    if (delta < 0) {\r\n      return;\r\n    }\r\n    if (delta > 0) {\r\n      const ts = window.performance.now();\r\n      // Concat arrays in place.\r\n      [].push.apply(this._physicalItems, this._createPool(delta));\r\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\r\n      // support it.\r\n      for (let i = 0; i < delta; i++) {\r\n        this._physicalSizes.push(0);\r\n      }\r\n      this._physicalCount += delta;\r\n      // Update the physical start if it needs to preserve the model of the\r\n      // focused item. In this situation, the focused item is currently rendered\r\n      // and its model would have changed after increasing the pool if the\r\n      // physical start remained unchanged.\r\n      if (\r\n        this._physicalStart > this._physicalEnd &&\r\n        this._isIndexRendered(this._focusedVirtualIndex) &&\r\n        this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd\r\n      ) {\r\n        this._physicalStart += delta;\r\n      }\r\n      this._update();\r\n      this._templateCost = (window.performance.now() - ts) / delta;\r\n      nextIncrease = Math.round(this._physicalCount * 0.5);\r\n    }\r\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\r\n      // Do nothing.\r\n    } else if (!this._isClientFull()) {\r\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\r\n    } else if (this._physicalSize < this._optPhysicalSize) {\r\n      // Yield and increase the pool during idle time until the physical size is\r\n      // optimal.\r\n      this._debounce(\r\n        '_increasePoolIfNeeded',\r\n        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),\r\n        idlePeriod,\r\n      );\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Renders the a new list.\r\n   */\r\n  _render() {\r\n    if (!this.isAttached || !this._isVisible) {\r\n      return;\r\n    }\r\n    if (this._physicalCount !== 0) {\r\n      const reusables = this._getReusables(true);\r\n      this._physicalTop = reusables.physicalTop;\r\n      this._virtualStart += reusables.indexes.length;\r\n      this._physicalStart += reusables.indexes.length;\r\n      this._update(reusables.indexes);\r\n      this._update();\r\n      this._increasePoolIfNeeded(0);\r\n    } else if (this._virtualCount > 0) {\r\n      // Initial render\r\n      this.updateViewportBoundaries();\r\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Called when the items have changed. That is, reassignments\r\n   * to `items`, splices or updates to a single item.\r\n   */\r\n  _itemsChanged(change) {\r\n    if (change.path === 'items') {\r\n      this._virtualStart = 0;\r\n      this._physicalTop = 0;\r\n      this._virtualCount = this.items ? this.items.length : 0;\r\n      this._physicalIndexForKey = {};\r\n      this._firstVisibleIndexVal = null;\r\n      this._lastVisibleIndexVal = null;\r\n      if (!this._physicalItems) {\r\n        this._physicalItems = [];\r\n      }\r\n      if (!this._physicalSizes) {\r\n        this._physicalSizes = [];\r\n      }\r\n      this._physicalStart = 0;\r\n      if (this._scrollTop > this._scrollOffset) {\r\n        this._resetScrollPosition(0);\r\n      }\r\n      this._debounce('_render', this._render, animationFrame);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Executes a provided function per every physical index in `itemSet`\r\n   * `itemSet` default value is equivalent to the entire set of physical\r\n   * indexes.\r\n   *\r\n   * @param {!function(number, number)} fn\r\n   * @param {!Array<number>=} itemSet\r\n   */\r\n  _iterateItems(fn, itemSet) {\r\n    let pidx, vidx, rtn, i;\r\n\r\n    if (arguments.length === 2 && itemSet) {\r\n      for (i = 0; i < itemSet.length; i++) {\r\n        pidx = itemSet[i];\r\n        vidx = this._computeVidx(pidx);\r\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\r\n          return rtn;\r\n        }\r\n      }\r\n    } else {\r\n      pidx = this._physicalStart;\r\n      vidx = this._virtualStart;\r\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\r\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\r\n          return rtn;\r\n        }\r\n      }\r\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\r\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\r\n          return rtn;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns the virtual index for a given physical index\r\n   *\r\n   * @param {number} pidx Physical index\r\n   * @return {number}\r\n   */\r\n  _computeVidx(pidx) {\r\n    if (pidx >= this._physicalStart) {\r\n      return this._virtualStart + (pidx - this._physicalStart);\r\n    }\r\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\r\n  },\r\n\r\n  /**\r\n   * Updates the position of the physical items.\r\n   */\r\n  _positionItems() {\r\n    this._adjustScrollPosition();\r\n\r\n    let y = this._physicalTop;\r\n\r\n    this._iterateItems((pidx) => {\r\n      this.translate3d(0, `${y}px`, 0, this._physicalItems[pidx]);\r\n      y += this._physicalSizes[pidx];\r\n    });\r\n  },\r\n\r\n  _getPhysicalSizeIncrement(pidx) {\r\n    return this._physicalSizes[pidx];\r\n  },\r\n\r\n  /**\r\n   * Adjusts the scroll position when it was overestimated.\r\n   */\r\n  _adjustScrollPosition() {\r\n    const deltaHeight =\r\n      this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\r\n    // Note: the delta can be positive or negative.\r\n    if (deltaHeight !== 0) {\r\n      this._physicalTop -= deltaHeight;\r\n      // This may be called outside of a scrollHandler, so use last cached position\r\n      const scrollTop = this._scrollPosition;\r\n      // Juking scroll position during interial scrolling on iOS is no bueno\r\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\r\n        this._resetScrollPosition(scrollTop - deltaHeight);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets the position of the scroll.\r\n   */\r\n  _resetScrollPosition(pos) {\r\n    if (this.scrollTarget && pos >= 0) {\r\n      this._scrollTop = pos;\r\n      this._scrollPosition = this._scrollTop;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets the scroll height, that's the height of the content,\r\n   *\r\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\r\n   */\r\n  _updateScrollerSize(forceUpdate) {\r\n    const estScrollHeight =\r\n      this._physicalBottom +\r\n      Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\r\n\r\n    this._estScrollHeight = estScrollHeight;\r\n\r\n    // Amortize height adjustment, so it won't trigger large repaints too often.\r\n    if (\r\n      forceUpdate ||\r\n      this._scrollHeight === 0 ||\r\n      this._scrollPosition >= estScrollHeight - this._physicalSize ||\r\n      Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight\r\n    ) {\r\n      this.$.items.style.height = `${estScrollHeight}px`;\r\n      this._scrollHeight = estScrollHeight;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Scroll to a specific index in the virtual list regardless\r\n   * of the physical items in the DOM tree.\r\n   *\r\n   * @method scrollToIndex\r\n   * @param {number} idx The index of the item\r\n   */\r\n  scrollToIndex(idx) {\r\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\r\n      return;\r\n    }\r\n    flush();\r\n    // Items should have been rendered prior scrolling to an index.\r\n    if (this._physicalCount === 0) {\r\n      return;\r\n    }\r\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\r\n    // Update the virtual start only when needed.\r\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\r\n      this._virtualStart = idx - 1;\r\n    }\r\n    this._assignModels();\r\n    this._updateMetrics();\r\n    // Estimate new physical offset.\r\n    this._physicalTop = this._virtualStart * this._physicalAverage;\r\n\r\n    let currentTopItem = this._physicalStart;\r\n    let currentVirtualItem = this._virtualStart;\r\n    let targetOffsetTop = 0;\r\n    const hiddenContentSize = this._hiddenContentSize;\r\n    // Scroll to the item as much as we can.\r\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\r\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\r\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\r\n      currentVirtualItem += 1;\r\n    }\r\n    this._updateScrollerSize(true);\r\n    this._positionItems();\r\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\r\n    this._increasePoolIfNeeded(0);\r\n    // Clear cached visible index.\r\n    this._firstVisibleIndexVal = null;\r\n    this._lastVisibleIndexVal = null;\r\n  },\r\n\r\n  /**\r\n   * Reset the physical average and the average count.\r\n   */\r\n  _resetAverage() {\r\n    this._physicalAverage = 0;\r\n    this._physicalAverageCount = 0;\r\n  },\r\n\r\n  /**\r\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\r\n   * when the element is resized.\r\n   */\r\n  _resizeHandler() {\r\n    this._debounce(\r\n      '_render',\r\n      () => {\r\n        // Clear cached visible index.\r\n        this._firstVisibleIndexVal = null;\r\n        this._lastVisibleIndexVal = null;\r\n        if (this._isVisible) {\r\n          this.updateViewportBoundaries();\r\n          // Reinstall the scroll event listener.\r\n          this.toggleScrollListener(true);\r\n          this._resetAverage();\r\n          this._render();\r\n        } else {\r\n          // Uninstall the scroll event listener.\r\n          this.toggleScrollListener(false);\r\n        }\r\n      },\r\n      animationFrame,\r\n    );\r\n  },\r\n\r\n  _isIndexRendered(idx) {\r\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\r\n  },\r\n\r\n  _getPhysicalIndex(vidx) {\r\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\r\n  },\r\n\r\n  _clamp(v, min, max) {\r\n    return Math.min(max, Math.max(min, v));\r\n  },\r\n\r\n  _debounce(name, cb, asyncModule) {\r\n    if (!this._debouncers) {\r\n      this._debouncers = {};\r\n    }\r\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\r\n    enqueueDebouncer(this._debouncers[name]);\r\n  },\r\n};\r\n", "/**\r\n * @license\r\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { animationFrame, microTask, timeOut } from './async.js';\r\nimport { isSafari } from './browser-utils.js';\r\nimport { Debouncer, flush } from './debounce.js';\r\nimport { ironList } from './iron-list-core.js';\r\n\r\n// Iron-list can by default handle sizes up to around 100000.\r\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\r\nconst MAX_VIRTUAL_COUNT = 100000;\r\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\r\n\r\nexport class IronListAdapter {\r\n  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {\r\n    this.isAttached = true;\r\n    this._vidxOffset = 0;\r\n    this.createElements = createElements;\r\n    this.updateElement = updateElement;\r\n    this.scrollTarget = scrollTarget;\r\n    this.scrollContainer = scrollContainer;\r\n    this.elementsContainer = elementsContainer || scrollContainer;\r\n    this.reorderElements = reorderElements;\r\n    // Iron-list uses this value to determine how many pages of elements to render\r\n    this._maxPages = 1.3;\r\n\r\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\r\n    this.__placeholderHeight = 200;\r\n    // A queue of 10 previous element heights\r\n    this.__elementHeightQueue = Array(10);\r\n\r\n    this.timeouts = {\r\n      SCROLL_REORDER: 500,\r\n      IGNORE_WHEEL: 500,\r\n      FIX_INVALID_ITEM_POSITIONING: 100,\r\n    };\r\n\r\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\r\n\r\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\r\n      this.scrollTarget.style.overflow = 'auto';\r\n    }\r\n\r\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\r\n      this.scrollContainer.style.position = 'relative';\r\n    }\r\n\r\n    this.__resizeObserver.observe(this.scrollTarget);\r\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\r\n\r\n    const attachObserver = new ResizeObserver(([{ contentRect }]) => {\r\n      const isHidden = contentRect.width === 0 && contentRect.height === 0;\r\n      if (!isHidden && this.__scrollTargetHidden && this.scrollTarget.scrollTop !== this._scrollPosition) {\r\n        // When removing element from DOM, its scroll position is lost and\r\n        // virtualizer doesn't re-render when adding it to the DOM again.\r\n        // Restore scroll position when the scroll target becomes visible,\r\n        // which is the case e.g. when virtualizer is used inside a dialog.\r\n        this.scrollTarget.scrollTop = this._scrollPosition;\r\n      }\r\n\r\n      this.__scrollTargetHidden = isHidden;\r\n    });\r\n    attachObserver.observe(this.scrollTarget);\r\n\r\n    this._scrollLineHeight = this._getScrollLineHeight();\r\n    this.scrollTarget.addEventListener('wheel', (e) => this.__onWheel(e));\r\n\r\n    this.scrollTarget.addEventListener('virtualizer-element-focused', (e) => this.__onElementFocused(e));\r\n    this.elementsContainer.addEventListener('focusin', () => {\r\n      this.scrollTarget.dispatchEvent(\r\n        new CustomEvent('virtualizer-element-focused', { detail: { element: this.__getFocusedElement() } }),\r\n      );\r\n    });\r\n\r\n    if (this.reorderElements) {\r\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\r\n      // Need to defer reordering until the user lets go of the scroll bar handle.\r\n      this.scrollTarget.addEventListener('mousedown', () => {\r\n        this.__mouseDown = true;\r\n      });\r\n      this.scrollTarget.addEventListener('mouseup', () => {\r\n        this.__mouseDown = false;\r\n        if (this.__pendingReorder) {\r\n          this.__reorderElements();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  get scrollOffset() {\r\n    return 0;\r\n  }\r\n\r\n  get adjustedFirstVisibleIndex() {\r\n    return this.firstVisibleIndex + this._vidxOffset;\r\n  }\r\n\r\n  get adjustedLastVisibleIndex() {\r\n    return this.lastVisibleIndex + this._vidxOffset;\r\n  }\r\n\r\n  get _maxVirtualIndexOffset() {\r\n    return this.size - this._virtualCount;\r\n  }\r\n\r\n  __hasPlaceholders() {\r\n    return this.__getVisibleElements().some((el) => el.__virtualizerPlaceholder);\r\n  }\r\n\r\n  scrollToIndex(index) {\r\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\r\n      return;\r\n    }\r\n    delete this.__pendingScrollToIndex;\r\n\r\n    if (this._physicalCount <= 3 /* iron-list-core.DEFAULT_PHYSICAL_COUNT */) {\r\n      // The condition here is a performance improvement to avoid an unnecessary\r\n      // re-render when the physical item pool is already covered.\r\n\r\n      // Finish rendering at the current scroll position before scrolling\r\n      this.flush();\r\n    }\r\n\r\n    index = this._clamp(index, 0, this.size - 1);\r\n\r\n    const visibleElementCount = this.__getVisibleElements().length;\r\n    let targetVirtualIndex = Math.floor((index / this.size) * this._virtualCount);\r\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\r\n      targetVirtualIndex = this._virtualCount - (this.size - index);\r\n      this._vidxOffset = this._maxVirtualIndexOffset;\r\n    } else if (targetVirtualIndex < visibleElementCount) {\r\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\r\n        targetVirtualIndex = index;\r\n        this._vidxOffset = 0;\r\n      } else {\r\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\r\n        this._vidxOffset = index - targetVirtualIndex;\r\n      }\r\n    } else {\r\n      this._vidxOffset = index - targetVirtualIndex;\r\n    }\r\n\r\n    this.__skipNextVirtualIndexAdjust = true;\r\n    super.scrollToIndex(targetVirtualIndex);\r\n\r\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\r\n      // Workaround an iron-list issue by manually adjusting the scroll position\r\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\r\n    }\r\n    this._scrollHandler();\r\n\r\n    if (this.__hasPlaceholders()) {\r\n      // After rendering synchronously, there are still placeholders in the DOM.\r\n      // Try again after the next elements update.\r\n      this.__pendingScrollToIndex = index;\r\n    }\r\n  }\r\n\r\n  flush() {\r\n    // The scroll target is hidden.\r\n    if (this.scrollTarget.offsetHeight === 0) {\r\n      return;\r\n    }\r\n\r\n    this._resizeHandler();\r\n    flush();\r\n    this._scrollHandler();\r\n    if (this.__fixInvalidItemPositioningDebouncer) {\r\n      this.__fixInvalidItemPositioningDebouncer.flush();\r\n    }\r\n    if (this.__scrollReorderDebouncer) {\r\n      this.__scrollReorderDebouncer.flush();\r\n    }\r\n    if (this.__debouncerWheelAnimationFrame) {\r\n      this.__debouncerWheelAnimationFrame.flush();\r\n    }\r\n  }\r\n\r\n  hostConnected() {\r\n    // Restore scroll position, which is reset when host is removed from DOM,\r\n    // since virtualizer doesn't re-render when adding it to the DOM again.\r\n    // If the scroll target isn't visible and its `offsetParent` is `null`, wait\r\n    // for the ResizeObserver to handle this case (hiding -> moving -> showing).\r\n    if (this.scrollTarget.offsetParent && this.scrollTarget.scrollTop !== this._scrollPosition) {\r\n      this.scrollTarget.scrollTop = this._scrollPosition;\r\n    }\r\n  }\r\n\r\n  update(startIndex = 0, endIndex = this.size - 1) {\r\n    const updatedElements = [];\r\n    this.__getVisibleElements().forEach((el) => {\r\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\r\n        this.__updateElement(el, el.__virtualIndex, true);\r\n        updatedElements.push(el);\r\n      }\r\n    });\r\n\r\n    this.__afterElementsUpdated(updatedElements);\r\n  }\r\n\r\n  /**\r\n   * Updates the height for a given set of items.\r\n   *\r\n   * @param {!Array<number>=} itemSet\r\n   */\r\n  _updateMetrics(itemSet) {\r\n    // Make sure we distributed all the physical items\r\n    // so we can measure them.\r\n    flush();\r\n\r\n    let newPhysicalSize = 0;\r\n    let oldPhysicalSize = 0;\r\n    const prevAvgCount = this._physicalAverageCount;\r\n    const prevPhysicalAvg = this._physicalAverage;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    this._iterateItems((pidx, vidx) => {\r\n      oldPhysicalSize += this._physicalSizes[pidx];\r\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\r\n      newPhysicalSize += this._physicalSizes[pidx];\r\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\r\n    }, itemSet);\r\n\r\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\r\n\r\n    // Update the average if it measured something.\r\n    if (this._physicalAverageCount !== prevAvgCount) {\r\n      this._physicalAverage = Math.round(\r\n        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount,\r\n      );\r\n    }\r\n  }\r\n\r\n  __getBorderBoxHeight(el) {\r\n    const style = getComputedStyle(el);\r\n\r\n    const itemHeight = parseFloat(style.height) || 0;\r\n\r\n    if (style.boxSizing === 'border-box') {\r\n      return itemHeight;\r\n    }\r\n\r\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\r\n    const paddingTop = parseFloat(style.paddingTop) || 0;\r\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\r\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\r\n\r\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\r\n  }\r\n\r\n  __updateElement(el, index, forceSameIndexUpdates) {\r\n    // Clean up temporary placeholder sizing\r\n    if (el.__virtualizerPlaceholder) {\r\n      el.style.paddingTop = '';\r\n      el.style.opacity = '';\r\n      el.__virtualizerPlaceholder = false;\r\n    }\r\n\r\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\r\n      this.updateElement(el, index);\r\n      el.__lastUpdatedIndex = index;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called synchronously right after elements have been updated.\r\n   * This is a good place to do any post-update work.\r\n   *\r\n   * @param {!Array<!HTMLElement>} updatedElements\r\n   */\r\n  __afterElementsUpdated(updatedElements) {\r\n    updatedElements.forEach((el) => {\r\n      const elementHeight = el.offsetHeight;\r\n      if (elementHeight === 0) {\r\n        // If the elements have 0 height after update (for example due to lazy rendering),\r\n        // it results in iron-list requesting to create an unlimited count of elements.\r\n        // Assign a temporary placeholder sizing to elements that would otherwise end up having\r\n        // no height.\r\n        el.style.paddingTop = `${this.__placeholderHeight}px`;\r\n        el.style.opacity = '0';\r\n        el.__virtualizerPlaceholder = true;\r\n\r\n        // Manually schedule the resize handler to make sure the placeholder padding is\r\n        // cleared in case the resize observer never triggers.\r\n        this.__placeholderClearDebouncer = Debouncer.debounce(this.__placeholderClearDebouncer, animationFrame, () =>\r\n          this._resizeHandler(),\r\n        );\r\n      } else {\r\n        // Add element height to the queue\r\n        this.__elementHeightQueue.push(elementHeight);\r\n        this.__elementHeightQueue.shift();\r\n\r\n        // Calculate new placeholder height based on the average of the defined values in the\r\n        // element height queue\r\n        const filteredHeights = this.__elementHeightQueue.filter((h) => h !== undefined);\r\n        this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\r\n      }\r\n    });\r\n\r\n    if (this.__pendingScrollToIndex !== undefined && !this.__hasPlaceholders()) {\r\n      this.scrollToIndex(this.__pendingScrollToIndex);\r\n    }\r\n  }\r\n\r\n  __getIndexScrollOffset(index) {\r\n    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);\r\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\r\n  }\r\n\r\n  get size() {\r\n    return this.__size;\r\n  }\r\n\r\n  set size(size) {\r\n    if (size === this.size) {\r\n      return;\r\n    }\r\n    // Cancel active debouncers\r\n    if (this.__fixInvalidItemPositioningDebouncer) {\r\n      this.__fixInvalidItemPositioningDebouncer.cancel();\r\n    }\r\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\r\n      // Avoid creating unnecessary elements on the following flush()\r\n      this._debouncers._increasePoolIfNeeded.cancel();\r\n    }\r\n\r\n    // Prevent element update while the scroll position is being restored\r\n    this.__preventElementUpdates = true;\r\n\r\n    // Record the scroll position before changing the size\r\n    let fvi; // First visible index\r\n    let fviOffsetBefore; // Scroll offset of the first visible index\r\n    if (size > 0) {\r\n      fvi = this.adjustedFirstVisibleIndex;\r\n      fviOffsetBefore = this.__getIndexScrollOffset(fvi);\r\n    }\r\n\r\n    // Change the size\r\n    this.__size = size;\r\n\r\n    this._itemsChanged({\r\n      path: 'items',\r\n    });\r\n    flush();\r\n\r\n    // Try to restore the scroll position if the new size is larger than 0\r\n    if (size > 0) {\r\n      fvi = Math.min(fvi, size - 1);\r\n      // Note, calling scrollToIndex also updates the virtual index offset,\r\n      // causing the virtualizer to add more items when size is increased,\r\n      // and remove exceeding items when size is decreased.\r\n      this.scrollToIndex(fvi);\r\n\r\n      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);\r\n      if (fviOffsetBefore !== undefined && fviOffsetAfter !== undefined) {\r\n        this._scrollTop += fviOffsetBefore - fviOffsetAfter;\r\n      }\r\n    }\r\n\r\n    this.__preventElementUpdates = false;\r\n\r\n    // When reducing size while invisible, iron-list does not update items, so\r\n    // their hidden state is not updated and their __lastUpdatedIndex is not\r\n    // reset. In that case force an update here.\r\n    if (!this._isVisible) {\r\n      this._assignModels();\r\n    }\r\n\r\n    if (!this.elementsContainer.children.length) {\r\n      requestAnimationFrame(() => this._resizeHandler());\r\n    }\r\n\r\n    // Schedule and flush a resize handler\r\n    this._resizeHandler();\r\n    flush();\r\n    // Schedule an update to ensure item positions are correct after subsequent size changes\r\n    // Fix for https://github.com/vaadin/flow-components/issues/6269\r\n    this._debounce('_update', this._update, microTask);\r\n  }\r\n\r\n  /** @private */\r\n  get _scrollTop() {\r\n    return this.scrollTarget.scrollTop;\r\n  }\r\n\r\n  /** @private */\r\n  set _scrollTop(top) {\r\n    this.scrollTarget.scrollTop = top;\r\n  }\r\n\r\n  /** @private */\r\n  get items() {\r\n    return {\r\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT),\r\n    };\r\n  }\r\n\r\n  /** @private */\r\n  get offsetHeight() {\r\n    return this.scrollTarget.offsetHeight;\r\n  }\r\n\r\n  /** @private */\r\n  get $() {\r\n    return {\r\n      items: this.scrollContainer,\r\n    };\r\n  }\r\n\r\n  /** @private */\r\n  updateViewportBoundaries() {\r\n    const styles = window.getComputedStyle(this.scrollTarget);\r\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\r\n    this._isRTL = Boolean(styles.direction === 'rtl');\r\n    this._viewportWidth = this.elementsContainer.offsetWidth;\r\n    this._viewportHeight = this.scrollTarget.offsetHeight;\r\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\r\n    if (this.grid) {\r\n      this._updateGridMetrics();\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  setAttribute() {}\r\n\r\n  /** @private */\r\n  _createPool(size) {\r\n    const physicalItems = this.createElements(size);\r\n    const fragment = document.createDocumentFragment();\r\n    physicalItems.forEach((el) => {\r\n      el.style.position = 'absolute';\r\n      fragment.appendChild(el);\r\n      this.__resizeObserver.observe(el);\r\n    });\r\n    this.elementsContainer.appendChild(fragment);\r\n    return physicalItems;\r\n  }\r\n\r\n  /** @private */\r\n  _assignModels(itemSet) {\r\n    const updatedElements = [];\r\n    this._iterateItems((pidx, vidx) => {\r\n      const el = this._physicalItems[pidx];\r\n      el.hidden = vidx >= this.size;\r\n      if (!el.hidden) {\r\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\r\n        this.__updateElement(el, el.__virtualIndex);\r\n        updatedElements.push(el);\r\n      } else {\r\n        delete el.__lastUpdatedIndex;\r\n      }\r\n    }, itemSet);\r\n\r\n    this.__afterElementsUpdated(updatedElements);\r\n  }\r\n\r\n  /** @private */\r\n  _isClientFull() {\r\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\r\n    setTimeout(() => {\r\n      this.__clientFull = true;\r\n    });\r\n    return this.__clientFull || super._isClientFull();\r\n  }\r\n\r\n  /** @private */\r\n  translate3d(_x, y, _z, el) {\r\n    el.style.transform = `translateY(${y})`;\r\n  }\r\n\r\n  /** @private */\r\n  toggleScrollListener() {}\r\n\r\n  /** @private */\r\n  __getFocusedElement(visibleElements = this.__getVisibleElements()) {\r\n    return visibleElements.find(\r\n      (element) =>\r\n        element.contains(this.elementsContainer.getRootNode().activeElement) ||\r\n        element.contains(this.scrollTarget.getRootNode().activeElement),\r\n    );\r\n  }\r\n\r\n  /** @private */\r\n  __nextFocusableSiblingMissing(focusedElement, visibleElements) {\r\n    return (\r\n      // Check if focused element is the last visible DOM element\r\n      visibleElements.indexOf(focusedElement) === visibleElements.length - 1 &&\r\n      // ...while there are more items available\r\n      this.size > focusedElement.__virtualIndex + 1\r\n    );\r\n  }\r\n\r\n  /** @private */\r\n  __previousFocusableSiblingMissing(focusedElement, visibleElements) {\r\n    return (\r\n      // Check if focused element is the first visible DOM element\r\n      visibleElements.indexOf(focusedElement) === 0 &&\r\n      // ...while there are preceding items available\r\n      focusedElement.__virtualIndex > 0\r\n    );\r\n  }\r\n\r\n  /** @private */\r\n  __onElementFocused(e) {\r\n    if (!this.reorderElements) {\r\n      return;\r\n    }\r\n\r\n    const focusedElement = e.detail.element;\r\n    if (!focusedElement) {\r\n      return;\r\n    }\r\n\r\n    // User has tabbed to or within a virtualizer element.\r\n    // Check if a next or previous focusable sibling is missing while it should be there (so the user can continue tabbing).\r\n    // The focusable sibling might be missing due to the elements not yet being in the correct DOM order.\r\n    // First try flushing (which also flushes any active __scrollReorderDebouncer).\r\n    const visibleElements = this.__getVisibleElements();\r\n    if (\r\n      this.__previousFocusableSiblingMissing(focusedElement, visibleElements) ||\r\n      this.__nextFocusableSiblingMissing(focusedElement, visibleElements)\r\n    ) {\r\n      this.flush();\r\n    }\r\n\r\n    // If the focusable sibling is still missing (because the focused element is at the edge of the viewport and\r\n    // the virtual scrolling logic hasn't had the need to recycle elements), scroll the virtualizer just enough to\r\n    // have the focusable sibling inside the visible viewport to force the virtualizer to recycle.\r\n    const reorderedVisibleElements = this.__getVisibleElements();\r\n    if (this.__nextFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {\r\n      this._scrollTop +=\r\n        Math.ceil(focusedElement.getBoundingClientRect().bottom) -\r\n        Math.floor(this.scrollTarget.getBoundingClientRect().bottom - 1);\r\n      this.flush();\r\n    } else if (this.__previousFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {\r\n      this._scrollTop -=\r\n        Math.ceil(this.scrollTarget.getBoundingClientRect().top + 1) -\r\n        Math.floor(focusedElement.getBoundingClientRect().top);\r\n      this.flush();\r\n    }\r\n  }\r\n\r\n  _scrollHandler() {\r\n    // The scroll target is hidden.\r\n    if (this.scrollTarget.offsetHeight === 0) {\r\n      return;\r\n    }\r\n\r\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\r\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\r\n\r\n    super._scrollHandler();\r\n\r\n    if (this._physicalCount !== 0) {\r\n      const isScrollingDown = delta >= 0;\r\n      const reusables = this._getReusables(!isScrollingDown);\r\n\r\n      if (reusables.indexes.length) {\r\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\r\n        // See https://github.com/vaadin/web-components/issues/1691\r\n        this._physicalTop = reusables.physicalTop;\r\n\r\n        if (isScrollingDown) {\r\n          this._virtualStart -= reusables.indexes.length;\r\n          this._physicalStart -= reusables.indexes.length;\r\n        } else {\r\n          this._virtualStart += reusables.indexes.length;\r\n          this._physicalStart += reusables.indexes.length;\r\n        }\r\n        this._resizeHandler();\r\n      }\r\n    }\r\n\r\n    if (delta) {\r\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\r\n      this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(\r\n        this.__fixInvalidItemPositioningDebouncer,\r\n        timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),\r\n        () => this.__fixInvalidItemPositioning(),\r\n      );\r\n    }\r\n\r\n    if (this.reorderElements) {\r\n      this.__scrollReorderDebouncer = Debouncer.debounce(\r\n        this.__scrollReorderDebouncer,\r\n        timeOut.after(this.timeouts.SCROLL_REORDER),\r\n        () => this.__reorderElements(),\r\n      );\r\n    }\r\n\r\n    this.__previousScrollTop = this._scrollTop;\r\n\r\n    // If the first visible index is not 0 when scrolled to the top,\r\n    // scroll to index 0 to fix the issue.\r\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\r\n      this.scrollToIndex(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Work around an iron-list issue with invalid item positioning.\r\n   * See https://github.com/vaadin/flow-components/issues/4306\r\n   * @private\r\n   */\r\n  __fixInvalidItemPositioning() {\r\n    if (!this.scrollTarget.isConnected) {\r\n      return;\r\n    }\r\n\r\n    // Check if the first physical item element is below the top of the viewport\r\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\r\n    // Check if the last physical item element is above the bottom of the viewport\r\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\r\n\r\n    // Check if the first index is visible\r\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\r\n    // Check if the last index is visible\r\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\r\n\r\n    if ((physicalTopBelowTop && !firstIndexVisible) || (physicalBottomAboveBottom && !lastIndexVisible)) {\r\n      // Invalid state! Try to recover.\r\n\r\n      const isScrollingDown = physicalBottomAboveBottom;\r\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\r\n      // place all the free physical items on one side of the viewport.\r\n      const originalRatio = this._ratio;\r\n      this._ratio = 0;\r\n      // Fake a scroll change to make _scrollHandler place the physical items\r\n      // on the desired side.\r\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\r\n      this._scrollHandler();\r\n      // Restore the original \"_ratio\" value.\r\n      this._ratio = originalRatio;\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  __onWheel(e) {\r\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\r\n      return;\r\n    }\r\n\r\n    let deltaY = e.deltaY;\r\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\r\n      // Scrolling by \"lines of text\" instead of pixels\r\n      deltaY *= this._scrollLineHeight;\r\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\r\n      // Scrolling by \"pages\" instead of pixels\r\n      deltaY *= this._scrollPageHeight;\r\n    }\r\n\r\n    if (!this._deltaYAcc) {\r\n      this._deltaYAcc = 0;\r\n    }\r\n\r\n    if (this._wheelAnimationFrame) {\r\n      // Accumulate wheel delta while a frame is being processed\r\n      this._deltaYAcc += deltaY;\r\n      e.preventDefault();\r\n      return;\r\n    }\r\n\r\n    deltaY += this._deltaYAcc;\r\n    this._deltaYAcc = 0;\r\n\r\n    this._wheelAnimationFrame = true;\r\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(\r\n      this.__debouncerWheelAnimationFrame,\r\n      animationFrame,\r\n      () => {\r\n        this._wheelAnimationFrame = false;\r\n      },\r\n    );\r\n\r\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\r\n\r\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\r\n      e.preventDefault();\r\n      this.scrollTarget.scrollTop += deltaY;\r\n      this.scrollTarget.scrollLeft += e.deltaX;\r\n\r\n      this._hasResidualMomentum = true;\r\n\r\n      this._ignoreNewWheel = true;\r\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(\r\n        this._debouncerIgnoreNewWheel,\r\n        timeOut.after(this.timeouts.IGNORE_WHEEL),\r\n        () => {\r\n          this._ignoreNewWheel = false;\r\n        },\r\n      );\r\n    } else if ((this._hasResidualMomentum && momentum <= this._previousMomentum) || this._ignoreNewWheel) {\r\n      e.preventDefault();\r\n    } else if (momentum > this._previousMomentum) {\r\n      this._hasResidualMomentum = false;\r\n    }\r\n    this._previousMomentum = momentum;\r\n  }\r\n\r\n  /**\r\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\r\n   *\r\n   * @private\r\n   */\r\n  _hasScrolledAncestor(el, deltaX, deltaY) {\r\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\r\n      return false;\r\n    } else if (\r\n      this._canScroll(el, deltaX, deltaY) &&\r\n      ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1\r\n    ) {\r\n      return true;\r\n    } else if (el !== this && el.parentElement) {\r\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\r\n    }\r\n  }\r\n\r\n  _canScroll(el, deltaX, deltaY) {\r\n    return (\r\n      (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||\r\n      (deltaY < 0 && el.scrollTop > 0) ||\r\n      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||\r\n      (deltaX < 0 && el.scrollLeft > 0)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Increases the pool size.\r\n   * @override\r\n   */\r\n  _increasePoolIfNeeded(count) {\r\n    if (this._physicalCount > 2 && count) {\r\n      // The iron-list logic has already created some physical items and\r\n      // has decided to create more. Since each item creation round is\r\n      // expensive, let's try to create the remaining items in one go.\r\n\r\n      // Calculate the total item count that would be needed to fill the viewport\r\n      // plus the buffer assuming rest of the items to be of the average size\r\n      // of the items already created.\r\n      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\r\n      const missingItemCount = totalItemCount - this._physicalCount;\r\n      // Create the remaining items in one go. Use a maximum of 100 items\r\n      // as a safety measure.\r\n      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));\r\n    } else {\r\n      super._increasePoolIfNeeded(count);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An optimal physical size such that we will have enough physical items\r\n   * to fill up the viewport and recycle when the user scrolls.\r\n   *\r\n   * This default value assumes that we will at least have the equivalent\r\n   * to a viewport of physical items above and below the user's viewport.\r\n   * @override\r\n   */\r\n  get _optPhysicalSize() {\r\n    const optPhysicalSize = super._optPhysicalSize;\r\n    // No need to adjust\r\n    if (optPhysicalSize <= 0 || this.__hasPlaceholders()) {\r\n      return optPhysicalSize;\r\n    }\r\n    // Item height buffer accounts for the cases where some items are much larger than the average.\r\n    // This can lead to some items not being rendered and leaving empty space in the viewport.\r\n    // https://github.com/vaadin/flow-components/issues/6651\r\n    return optPhysicalSize + this.__getItemHeightBuffer();\r\n  }\r\n\r\n  /**\r\n   * Extra item height buffer used when calculating optimal physical size.\r\n   *\r\n   * The iron list core uses the optimal physical size when determining whether to increase the item pool.\r\n   * For the cases where some items are much larger than the average, the iron list core might not increase item pool.\r\n   * This can lead to the large item not being rendered.\r\n   *\r\n   * @returns {Number} - Extra item height buffer\r\n   * @private\r\n   */\r\n  __getItemHeightBuffer() {\r\n    // No need for a buffer with no items\r\n    if (this._physicalCount === 0) {\r\n      return 0;\r\n    }\r\n    // The regular buffer zone height for either top or bottom\r\n    const bufferZoneHeight = Math.ceil((this._viewportHeight * (this._maxPages - 1)) / 2);\r\n    // The maximum height of the currently rendered items\r\n    const maxItemHeight = Math.max(...this._physicalSizes);\r\n    // Only add buffer if the item is larger that the other items\r\n    if (maxItemHeight > Math.min(...this._physicalSizes)) {\r\n      // Add a buffer height since the large item can still be in the viewport and out of the original buffer\r\n      return Math.max(0, maxItemHeight - bufferZoneHeight);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @returns {Number|undefined} - The browser's default font-size in pixels\r\n   * @private\r\n   */\r\n  _getScrollLineHeight() {\r\n    const el = document.createElement('div');\r\n    el.style.fontSize = 'initial';\r\n    el.style.display = 'none';\r\n    document.body.appendChild(el);\r\n    const fontSize = window.getComputedStyle(el).fontSize;\r\n    document.body.removeChild(el);\r\n    return fontSize ? window.parseInt(fontSize) : undefined;\r\n  }\r\n\r\n  __getVisibleElements() {\r\n    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);\r\n  }\r\n\r\n  /** @private */\r\n  __reorderElements() {\r\n    if (this.__mouseDown) {\r\n      this.__pendingReorder = true;\r\n      return;\r\n    }\r\n    this.__pendingReorder = false;\r\n\r\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\r\n\r\n    // Which row to use as a target?\r\n    const visibleElements = this.__getVisibleElements();\r\n    const targetElement = this.__getFocusedElement(visibleElements) || visibleElements[0];\r\n    if (!targetElement) {\r\n      // All elements are hidden, don't reorder\r\n      return;\r\n    }\r\n\r\n    // Where the target row should be?\r\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\r\n\r\n    // Reodrer the DOM elements to keep the target row at the target physical index\r\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\r\n    if (delta > 0) {\r\n      for (let i = 0; i < delta; i++) {\r\n        this.elementsContainer.appendChild(visibleElements[i]);\r\n      }\r\n    } else if (delta < 0) {\r\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\r\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\r\n      }\r\n    }\r\n\r\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\r\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\r\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\r\n    if (isSafari) {\r\n      const { transform } = this.scrollTarget.style;\r\n      this.scrollTarget.style.transform = 'translateZ(0)';\r\n      setTimeout(() => {\r\n        this.scrollTarget.style.transform = transform;\r\n      });\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  _adjustVirtualIndexOffset(delta) {\r\n    const maxOffset = this._maxVirtualIndexOffset;\r\n\r\n    if (this._virtualCount >= this.size) {\r\n      this._vidxOffset = 0;\r\n    } else if (this.__skipNextVirtualIndexAdjust) {\r\n      this.__skipNextVirtualIndexAdjust = false;\r\n    } else if (Math.abs(delta) > 10000) {\r\n      // Process a large scroll position change\r\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight);\r\n      this._vidxOffset = Math.round(scale * maxOffset);\r\n    } else {\r\n      // Make sure user can always swipe/wheel scroll to the start and end\r\n      const oldOffset = this._vidxOffset;\r\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\r\n      const maxShift = 100;\r\n\r\n      // Near start\r\n      if (this._scrollTop === 0) {\r\n        this._vidxOffset = 0;\r\n        if (oldOffset !== this._vidxOffset) {\r\n          super.scrollToIndex(0);\r\n        }\r\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\r\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\r\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\r\n      }\r\n\r\n      // Near end\r\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\r\n        this._vidxOffset = maxOffset;\r\n        if (oldOffset !== this._vidxOffset) {\r\n          super.scrollToIndex(this._virtualCount - 1);\r\n        }\r\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\r\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\r\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);\r\n", "import { IronListAdapter } from './virtualizer-iron-list-adapter.js';\r\n\r\nexport class Virtualizer {\r\n  /**\r\n   * @typedef {Object} VirtualizerConfig\r\n   * @property {Function} createElements Function that returns the given number of new elements\r\n   * @property {Function} updateElement Function that updates the element at a specific index\r\n   * @property {HTMLElement} scrollTarget Reference to the scrolling element\r\n   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget\r\n   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer\r\n   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM\r\n   * @param {VirtualizerConfig} config Configuration for the virtualizer\r\n   */\r\n  constructor(config) {\r\n    this.__adapter = new IronListAdapter(config);\r\n  }\r\n\r\n  /**\r\n   * Gets the index of the first visible item in the viewport.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get firstVisibleIndex() {\r\n    return this.__adapter.adjustedFirstVisibleIndex;\r\n  }\r\n\r\n  /**\r\n   * Gets the index of the last visible item in the viewport.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get lastVisibleIndex() {\r\n    return this.__adapter.adjustedLastVisibleIndex;\r\n  }\r\n\r\n  /**\r\n   * The size of the virtualizer\r\n   * @return {number | undefined} The size of the virtualizer\r\n   */\r\n  get size() {\r\n    return this.__adapter.size;\r\n  }\r\n\r\n  /**\r\n   * The size of the virtualizer\r\n   * @param {number} size The size of the virtualizer\r\n   */\r\n  set size(size) {\r\n    this.__adapter.size = size;\r\n  }\r\n\r\n  /**\r\n   * Scroll to a specific index in the virtual list\r\n   *\r\n   * @method scrollToIndex\r\n   * @param {number} index The index of the item\r\n   */\r\n  scrollToIndex(index) {\r\n    this.__adapter.scrollToIndex(index);\r\n  }\r\n\r\n  /**\r\n   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM\r\n   *\r\n   * @method update\r\n   * @param {number | undefined} startIndex The start index of the range\r\n   * @param {number | undefined} endIndex The end index of the range\r\n   */\r\n  update(startIndex = 0, endIndex = this.size - 1) {\r\n    this.__adapter.update(startIndex, endIndex);\r\n  }\r\n\r\n  /**\r\n   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state\r\n   *\r\n   * @method update\r\n   * @param {number | undefined} startIndex The start index of the range\r\n   * @param {number | undefined} endIndex The end index of the range\r\n   */\r\n  flush() {\r\n    this.__adapter.flush();\r\n  }\r\n\r\n  /**\r\n   * Notifies the virtualizer about its host element connected to the DOM.\r\n   *\r\n   * @method hostConnected\r\n   */\r\n  hostConnected() {\r\n    this.__adapter.hostConnected();\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
