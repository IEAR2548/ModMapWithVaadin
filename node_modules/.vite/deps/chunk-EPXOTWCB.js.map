{
  "version": 3,
  "sources": ["../../ol/src/tilecoord.js", "../../ol/src/tilegrid/TileGrid.js", "../../ol/src/tilegrid.js", "../../ol/src/structs/LRUCache.js", "../../ol/src/TileCache.js", "../../ol/src/source/TileEventType.js", "../../ol/src/source/Tile.js", "../../ol/src/tileurlfunction.js", "../../ol/src/source/UrlTile.js", "../../ol/src/source/TileImage.js"],
  "sourcesContent": ["/**\r\n * @module ol/tilecoord\r\n */\r\n\r\n/**\r\n * An array of three numbers representing the location of a tile in a tile\r\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\r\n * @typedef {Array<number>} TileCoord\r\n * @api\r\n */\r\n\r\n/**\r\n * @param {number} z Z.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\r\n * @return {TileCoord} Tile coordinate.\r\n */\r\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\r\n  if (opt_tileCoord !== undefined) {\r\n    opt_tileCoord[0] = z;\r\n    opt_tileCoord[1] = x;\r\n    opt_tileCoord[2] = y;\r\n    return opt_tileCoord;\r\n  } else {\r\n    return [z, x, y];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} z Z.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {string} Key.\r\n */\r\nexport function getKeyZXY(z, x, y) {\r\n  return z + '/' + x + '/' + y;\r\n}\r\n\r\n/**\r\n * Get the key for a tile coord.\r\n * @param {TileCoord} tileCoord The tile coord.\r\n * @return {string} Key.\r\n */\r\nexport function getKey(tileCoord) {\r\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\r\n}\r\n\r\n/**\r\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\r\n * @param {string} tileKey The tile key.\r\n * @return {string} The cache key.\r\n */\r\nexport function getCacheKeyForTileKey(tileKey) {\r\n  const [z, x, y] = tileKey\r\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\r\n    .split(',')\r\n    .map(Number);\r\n  return getKeyZXY(z, x, y);\r\n}\r\n\r\n/**\r\n * Get a tile coord given a key.\r\n * @param {string} key The tile coord key.\r\n * @return {TileCoord} The tile coord.\r\n */\r\nexport function fromKey(key) {\r\n  return key.split('/').map(Number);\r\n}\r\n\r\n/**\r\n * @param {TileCoord} tileCoord Tile coord.\r\n * @return {number} Hash.\r\n */\r\nexport function hash(tileCoord) {\r\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\r\n}\r\n\r\n/**\r\n * @param {TileCoord} tileCoord Tile coordinate.\r\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n * @return {boolean} Tile coordinate is within extent and zoom level range.\r\n */\r\nexport function withinExtentAndZ(tileCoord, tileGrid) {\r\n  const z = tileCoord[0];\r\n  const x = tileCoord[1];\r\n  const y = tileCoord[2];\r\n\r\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\r\n    return false;\r\n  }\r\n  const tileRange = tileGrid.getFullTileRange(z);\r\n  if (!tileRange) {\r\n    return true;\r\n  } else {\r\n    return tileRange.containsXY(x, y);\r\n  }\r\n}\r\n", "/**\r\n * @module ol/tilegrid/TileGrid\r\n */\r\nimport TileRange, {\r\n  createOrUpdate as createOrUpdateTileRange,\r\n} from '../TileRange.js';\r\nimport {DEFAULT_TILE_SIZE} from './common.js';\r\nimport {assert} from '../asserts.js';\r\nimport {ceil, clamp, floor} from '../math.js';\r\nimport {createOrUpdate, getTopLeft} from '../extent.js';\r\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\r\nimport {isSorted, linearFindNearest} from '../array.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @private\r\n * @type {import(\"../tilecoord.js\").TileCoord}\r\n */\r\nconst tmpTileCoord = [0, 0, 0];\r\n\r\n/**\r\n * Number of decimal digits to consider in integer values when rounding.\r\n * @type {number}\r\n */\r\nconst DECIMALS = 5;\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\r\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\r\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\r\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\r\n * specified, `extent` or `origins` must be provided.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\r\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\r\n * `origin` must be provided.\r\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\r\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\r\n * array will have a length of `maxZoom + 1`.\r\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\r\n * of the grid for each zoom level. If specified the values\r\n * define each zoom level's extent together with the `origin` or `origins`.\r\n * A grid `extent` can be configured in addition, and will further limit the extent\r\n * for which tile requests are made by sources. If the bottom-left corner of\r\n * an extent is used as `origin` or `origins`, then the `y` value must be\r\n * negative because OpenLayers tile coordinates use the top left as the origin.\r\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\r\n * Default is `[256, 256]`.\r\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * tile size.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for setting the grid pattern for sources accessing tiled-image\r\n * servers.\r\n * @api\r\n */\r\nclass TileGrid {\r\n  /**\r\n   * @param {Options} options Tile grid options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<number>}\r\n     */\r\n    this.resolutions_ = options.resolutions;\r\n    assert(\r\n      isSorted(\r\n        this.resolutions_,\r\n        function (a, b) {\r\n          return b - a;\r\n        },\r\n        true\r\n      ),\r\n      17\r\n    ); // `resolutions` must be sorted in descending order\r\n\r\n    // check if we've got a consistent zoom factor and origin\r\n    let zoomFactor;\r\n    if (!options.origins) {\r\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\r\n        if (!zoomFactor) {\r\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\r\n        } else {\r\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\r\n            zoomFactor = undefined;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.zoomFactor_ = zoomFactor;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.maxZoom = this.resolutions_.length - 1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate|null}\r\n     */\r\n    this.origin_ = options.origin !== undefined ? options.origin : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\r\n     */\r\n    this.origins_ = null;\r\n    if (options.origins !== undefined) {\r\n      this.origins_ = options.origins;\r\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\r\n    }\r\n\r\n    const extent = options.extent;\r\n\r\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\r\n      this.origin_ = getTopLeft(extent);\r\n    }\r\n\r\n    assert(\r\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\r\n      18\r\n    ); // Either `origin` or `origins` must be configured, never both\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number|import(\"../size.js\").Size>}\r\n     */\r\n    this.tileSizes_ = null;\r\n    if (options.tileSizes !== undefined) {\r\n      this.tileSizes_ = options.tileSizes;\r\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|import(\"../size.js\").Size}\r\n     */\r\n    this.tileSize_ =\r\n      options.tileSize !== undefined\r\n        ? options.tileSize\r\n        : !this.tileSizes_\r\n        ? DEFAULT_TILE_SIZE\r\n        : null;\r\n    assert(\r\n      (!this.tileSize_ && this.tileSizes_) ||\r\n        (this.tileSize_ && !this.tileSizes_),\r\n      22\r\n    ); // Either `tileSize` or `tileSizes` must be configured, never both\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = extent !== undefined ? extent : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../TileRange.js\").default>}\r\n     */\r\n    this.fullTileRanges_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.tmpExtent_ = [0, 0, 0, 0];\r\n\r\n    if (options.sizes !== undefined) {\r\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\r\n        const tileRange = new TileRange(\r\n          Math.min(0, size[0]),\r\n          Math.max(size[0] - 1, -1),\r\n          Math.min(0, size[1]),\r\n          Math.max(size[1] - 1, -1)\r\n        );\r\n        if (extent) {\r\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\r\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\r\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\r\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\r\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\r\n        }\r\n        return tileRange;\r\n      }, this);\r\n    } else if (extent) {\r\n      this.calculateTileRanges_(extent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call a function with each tile coordinate for a given extent and zoom level.\r\n   *\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} zoom Integer zoom level.\r\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\r\n   * @api\r\n   */\r\n  forEachTileCoord(extent, zoom, callback) {\r\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\r\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\r\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\r\n        callback([zoom, i, j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\r\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {boolean} Callback succeeded.\r\n   */\r\n  forEachTileCoordParentTileRange(\r\n    tileCoord,\r\n    callback,\r\n    opt_tileRange,\r\n    opt_extent\r\n  ) {\r\n    let tileRange, x, y;\r\n    let tileCoordExtent = null;\r\n    let z = tileCoord[0] - 1;\r\n    if (this.zoomFactor_ === 2) {\r\n      x = tileCoord[1];\r\n      y = tileCoord[2];\r\n    } else {\r\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\r\n    }\r\n    while (z >= this.minZoom) {\r\n      if (this.zoomFactor_ === 2) {\r\n        x = Math.floor(x / 2);\r\n        y = Math.floor(y / 2);\r\n        tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\r\n      } else {\r\n        tileRange = this.getTileRangeForExtentAndZ(\r\n          tileCoordExtent,\r\n          z,\r\n          opt_tileRange\r\n        );\r\n      }\r\n      if (callback(z, tileRange)) {\r\n        return true;\r\n      }\r\n      --z;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get the extent for this tile grid, if it was configured.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Get the maximum zoom level for the grid.\r\n   * @return {number} Max zoom.\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return this.maxZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the minimum zoom level for the grid.\r\n   * @return {number} Min zoom.\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return this.minZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the origin for the grid at the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\r\n   * @api\r\n   */\r\n  getOrigin(z) {\r\n    if (this.origin_) {\r\n      return this.origin_;\r\n    } else {\r\n      return this.origins_[z];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {number} Resolution.\r\n   * @api\r\n   */\r\n  getResolution(z) {\r\n    return this.resolutions_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the list of resolutions for the tile grid.\r\n   * @return {Array<number>} Resolutions.\r\n   * @api\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {import(\"../TileRange.js\").default} Tile range.\r\n   */\r\n  getTileCoordChildTileRange(tileCoord, opt_tileRange, opt_extent) {\r\n    if (tileCoord[0] < this.maxZoom) {\r\n      if (this.zoomFactor_ === 2) {\r\n        const minX = tileCoord[1] * 2;\r\n        const minY = tileCoord[2] * 2;\r\n        return createOrUpdateTileRange(\r\n          minX,\r\n          minX + 1,\r\n          minY,\r\n          minY + 1,\r\n          opt_tileRange\r\n        );\r\n      }\r\n      const tileCoordExtent = this.getTileCoordExtent(\r\n        tileCoord,\r\n        opt_extent || this.tmpExtent_\r\n      );\r\n      return this.getTileRangeForExtentAndZ(\r\n        tileCoordExtent,\r\n        tileCoord[0] + 1,\r\n        opt_tileRange\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @return {import(\"../TileRange.js\").default} Tile range.\r\n   */\r\n  getTileRangeForTileCoordAndZ(tileCoord, z, opt_tileRange) {\r\n    if (z > this.maxZoom || z < this.minZoom) {\r\n      return null;\r\n    }\r\n\r\n    const tileCoordZ = tileCoord[0];\r\n    const tileCoordX = tileCoord[1];\r\n    const tileCoordY = tileCoord[2];\r\n\r\n    if (z === tileCoordZ) {\r\n      return createOrUpdateTileRange(\r\n        tileCoordX,\r\n        tileCoordY,\r\n        tileCoordX,\r\n        tileCoordY,\r\n        opt_tileRange\r\n      );\r\n    }\r\n\r\n    if (this.zoomFactor_) {\r\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\r\n      const minX = Math.floor(tileCoordX * factor);\r\n      const minY = Math.floor(tileCoordY * factor);\r\n      if (z < tileCoordZ) {\r\n        return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\r\n      }\r\n\r\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\r\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\r\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\r\n    }\r\n\r\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\r\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\r\n  }\r\n\r\n  /**\r\n   * Get the extent for a tile range.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   */\r\n  getTileRangeExtent(z, tileRange, opt_extent) {\r\n    const origin = this.getOrigin(z);\r\n    const resolution = this.getResolution(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\r\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\r\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\r\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\r\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\r\n  }\r\n\r\n  /**\r\n   * Get a tile range for the given extent and integer zoom level.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\r\n   * @return {import(\"../TileRange.js\").default} Tile range.\r\n   */\r\n  getTileRangeForExtentAndZ(extent, z, opt_tileRange) {\r\n    const tileCoord = tmpTileCoord;\r\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\r\n    const minX = tileCoord[1];\r\n    const minY = tileCoord[2];\r\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\r\n    return createOrUpdateTileRange(\r\n      minX,\r\n      tileCoord[1],\r\n      minY,\r\n      tileCoord[2],\r\n      opt_tileRange\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\r\n   */\r\n  getTileCoordCenter(tileCoord) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    return [\r\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\r\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Get the extent of a tile coordinate.\r\n   *\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getTileCoordExtent(tileCoord, opt_extent) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\r\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\r\n    const maxX = minX + tileSize[0] * resolution;\r\n    const maxY = minY + tileSize[1] * resolution;\r\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\r\n  }\r\n\r\n  /**\r\n   * Get the tile coordinate for the given map coordinate and resolution.  This\r\n   * method considers that coordinates that intersect tile boundaries should be\r\n   * assigned the higher tile coordinate.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndResolution_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      resolution,\r\n      false,\r\n      opt_tileCoord\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Note that this method should not be called for resolutions that correspond\r\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {number} resolution Resolution (for a non-integer zoom level).\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndResolution_(\r\n    x,\r\n    y,\r\n    resolution,\r\n    reverseIntersectionPolicy,\r\n    opt_tileCoord\r\n  ) {\r\n    const z = this.getZForResolution(resolution);\r\n    const scale = resolution / this.getResolution(z);\r\n    const origin = this.getOrigin(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\r\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\r\n   * they should have separate implementations.  This method is for integer zoom\r\n   * levels.  The other method should only be called for resolutions corresponding\r\n   * to non-integer zoom levels.\r\n   * @param {number} x Map x coordinate.\r\n   * @param {number} y Map y coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\r\n    const origin = this.getOrigin(z);\r\n    const resolution = this.getResolution(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\r\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Get a tile coordinate given a map coordinate and zoom level.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} z Zoom level.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndZ_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      z,\r\n      false,\r\n      opt_tileCoord\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {number} Tile resolution.\r\n   */\r\n  getTileCoordResolution(tileCoord) {\r\n    return this.resolutions_[tileCoord[0]];\r\n  }\r\n\r\n  /**\r\n   * Get the tile size for a zoom level. The type of the return value matches the\r\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\r\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\r\n   * @param {number} z Z.\r\n   * @return {number|import(\"../size.js\").Size} Tile size.\r\n   * @api\r\n   */\r\n  getTileSize(z) {\r\n    if (this.tileSize_) {\r\n      return this.tileSize_;\r\n    } else {\r\n      return this.tileSizes_[z];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Zoom level.\r\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\r\n   */\r\n  getFullTileRange(z) {\r\n    if (!this.fullTileRanges_) {\r\n      return this.extent_\r\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\r\n        : null;\r\n    } else {\r\n      return this.fullTileRanges_[z];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\r\n   *     If 0, the nearest resolution will be used.\r\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\r\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\r\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\r\n   *\r\n   * For example to change tile Z at the midpoint of zoom levels\r\n   * ```js\r\n   * function(value, high, low) {\r\n   *   return value - low * Math.sqrt(high / low);\r\n   * }\r\n   * ```\r\n   * @return {number} Z.\r\n   * @api\r\n   */\r\n  getZForResolution(resolution, opt_direction) {\r\n    const z = linearFindNearest(\r\n      this.resolutions_,\r\n      resolution,\r\n      opt_direction || 0\r\n    );\r\n    return clamp(z, this.minZoom, this.maxZoom);\r\n  }\r\n\r\n  /**\r\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\r\n   * @private\r\n   */\r\n  calculateTileRanges_(extent) {\r\n    const length = this.resolutions_.length;\r\n    const fullTileRanges = new Array(length);\r\n    for (let z = this.minZoom; z < length; ++z) {\r\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\r\n    }\r\n    this.fullTileRanges_ = fullTileRanges;\r\n  }\r\n}\r\n\r\nexport default TileGrid;\r\n", "/**\r\n * @module ol/tilegrid\r\n */\r\nimport Corner from './extent/Corner.js';\r\nimport TileGrid from './tilegrid/TileGrid.js';\r\nimport Units from './proj/Units.js';\r\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\r\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\r\nimport {\r\n  containsCoordinate,\r\n  createOrUpdate,\r\n  getCorner,\r\n  getHeight,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {toSize} from './size.js';\r\n\r\n/**\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {!TileGrid} Default tile grid for the\r\n * passed projection.\r\n */\r\nexport function getForProjection(projection) {\r\n  let tileGrid = projection.getDefaultTileGrid();\r\n  if (!tileGrid) {\r\n    tileGrid = createForProjection(projection);\r\n    projection.setDefaultTileGrid(tileGrid);\r\n  }\r\n  return tileGrid;\r\n}\r\n\r\n/**\r\n * @param {TileGrid} tileGrid Tile grid.\r\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\r\n */\r\nexport function wrapX(tileGrid, tileCoord, projection) {\r\n  const z = tileCoord[0];\r\n  const center = tileGrid.getTileCoordCenter(tileCoord);\r\n  const projectionExtent = extentFromProjection(projection);\r\n  if (!containsCoordinate(projectionExtent, center)) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.ceil(\r\n      (projectionExtent[0] - center[0]) / worldWidth\r\n    );\r\n    center[0] += worldWidth * worldsAway;\r\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\r\n  } else {\r\n    return tileCoord;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\r\n  const corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\r\n\r\n  const resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\r\n\r\n  return new TileGrid({\r\n    extent: extent,\r\n    origin: getCorner(extent, corner),\r\n    resolutions: resolutions,\r\n    tileSize: opt_tileSize,\r\n  });\r\n}\r\n\r\n/**\r\n * @typedef {Object} XYZOptions\r\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\r\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\r\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\r\n * @property {number} [maxResolution] Resolution at level zero.\r\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\r\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\r\n */\r\n\r\n/**\r\n * Creates a tile grid with a standard XYZ tiling scheme.\r\n * @param {XYZOptions} [opt_options] Tile grid options.\r\n * @return {!TileGrid} Tile grid instance.\r\n * @api\r\n */\r\nexport function createXYZ(opt_options) {\r\n  const xyzOptions = opt_options || {};\r\n\r\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\r\n\r\n  const gridOptions = {\r\n    extent: extent,\r\n    minZoom: xyzOptions.minZoom,\r\n    tileSize: xyzOptions.tileSize,\r\n    resolutions: resolutionsFromExtent(\r\n      extent,\r\n      xyzOptions.maxZoom,\r\n      xyzOptions.tileSize,\r\n      xyzOptions.maxResolution\r\n    ),\r\n  };\r\n  return new TileGrid(gridOptions);\r\n}\r\n\r\n/**\r\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {number} [opt_maxResolution] Resolution at level zero.\r\n * @return {!Array<number>} Resolutions array.\r\n */\r\nfunction resolutionsFromExtent(\r\n  extent,\r\n  opt_maxZoom,\r\n  opt_tileSize,\r\n  opt_maxResolution\r\n) {\r\n  const maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\r\n\r\n  const height = getHeight(extent);\r\n  const width = getWidth(extent);\r\n\r\n  const tileSize = toSize(\r\n    opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE\r\n  );\r\n  const maxResolution =\r\n    opt_maxResolution > 0\r\n      ? opt_maxResolution\r\n      : Math.max(width / tileSize[0], height / tileSize[1]);\r\n\r\n  const length = maxZoom + 1;\r\n  const resolutions = new Array(length);\r\n  for (let z = 0; z < length; ++z) {\r\n    resolutions[z] = maxResolution / Math.pow(2, z);\r\n  }\r\n  return resolutions;\r\n}\r\n\r\n/**\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForProjection(\r\n  projection,\r\n  opt_maxZoom,\r\n  opt_tileSize,\r\n  opt_corner\r\n) {\r\n  const extent = extentFromProjection(projection);\r\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\r\n}\r\n\r\n/**\r\n * Generate a tile grid extent from a projection.  If the projection has an\r\n * extent, it is used.  If not, a global extent is assumed.\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @return {import(\"./extent.js\").Extent} Extent.\r\n */\r\nexport function extentFromProjection(projection) {\r\n  projection = getProjection(projection);\r\n  let extent = projection.getExtent();\r\n  if (!extent) {\r\n    const half =\r\n      (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\r\n    extent = createOrUpdate(-half, -half, half, half);\r\n  }\r\n  return extent;\r\n}\r\n", "/**\r\n * @module ol/structs/LRUCache\r\n */\r\n\r\nimport {assert} from '../asserts.js';\r\n\r\n/**\r\n * @typedef {Object} Entry\r\n * @property {string} key_ Key.\r\n * @property {Object} newer Newer.\r\n * @property {Object} older Older.\r\n * @property {*} value_ Value.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Implements a Least-Recently-Used cache where the keys do not conflict with\r\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\r\n * items from the cache is the responsibility of the user.\r\n *\r\n * @fires import(\"../events/Event.js\").default\r\n * @template T\r\n */\r\nclass LRUCache {\r\n  /**\r\n   * @param {number} [opt_highWaterMark] High water mark.\r\n   */\r\n  constructor(opt_highWaterMark) {\r\n    /**\r\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\r\n     * will be pruned at all.\r\n     * @type {number}\r\n     */\r\n    this.highWaterMark =\r\n      opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.count_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, Entry>}\r\n     */\r\n    this.entries_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.oldest_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.newest_ = null;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\r\n  }\r\n\r\n  /**\r\n   * Expire the cache.\r\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\r\n   */\r\n  expireCache(keep) {\r\n    while (this.canExpireCache()) {\r\n      this.pop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\r\n  clear() {\r\n    this.count_ = 0;\r\n    this.entries_ = {};\r\n    this.oldest_ = null;\r\n    this.newest_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @return {boolean} Contains key.\r\n   */\r\n  containsKey(key) {\r\n    return this.entries_.hasOwnProperty(key);\r\n  }\r\n\r\n  /**\r\n   * @param {function(T, string, LRUCache<T>): ?} f The function\r\n   *     to call for every entry from the oldest to the newer. This function takes\r\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\r\n   *     The return value is ignored.\r\n   */\r\n  forEach(f) {\r\n    let entry = this.oldest_;\r\n    while (entry) {\r\n      f(entry.value_, entry.key_, this);\r\n      entry = entry.newer;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {*} [opt_options] Options (reserved for subclasses).\r\n   * @return {T} Value.\r\n   */\r\n  get(key, opt_options) {\r\n    const entry = this.entries_[key];\r\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\r\n    if (entry === this.newest_) {\r\n      return entry.value_;\r\n    } else if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\r\n      this.oldest_.older = null;\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    entry.newer = null;\r\n    entry.older = this.newest_;\r\n    this.newest_.newer = entry;\r\n    this.newest_ = entry;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * Remove an entry from the cache.\r\n   * @param {string} key The entry key.\r\n   * @return {T} The removed entry.\r\n   */\r\n  remove(key) {\r\n    const entry = this.entries_[key];\r\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\r\n    if (entry === this.newest_) {\r\n      this.newest_ = /** @type {Entry} */ (entry.older);\r\n      if (this.newest_) {\r\n        this.newest_.newer = null;\r\n      }\r\n    } else if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n      if (this.oldest_) {\r\n        this.oldest_.older = null;\r\n      }\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    delete this.entries_[key];\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Count.\r\n   */\r\n  getCount() {\r\n    return this.count_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>} Keys.\r\n   */\r\n  getKeys() {\r\n    const keys = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      keys[i++] = entry.key_;\r\n    }\r\n    return keys;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<T>} Values.\r\n   */\r\n  getValues() {\r\n    const values = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      values[i++] = entry.value_;\r\n    }\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * @return {T} Last value.\r\n   */\r\n  peekLast() {\r\n    return this.oldest_.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {string} Last key.\r\n   */\r\n  peekLastKey() {\r\n    return this.oldest_.key_;\r\n  }\r\n\r\n  /**\r\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\r\n   * @return {string} The newest key.\r\n   */\r\n  peekFirstKey() {\r\n    return this.newest_.key_;\r\n  }\r\n\r\n  /**\r\n   * @return {T} value Value.\r\n   */\r\n  pop() {\r\n    const entry = this.oldest_;\r\n    delete this.entries_[entry.key_];\r\n    if (entry.newer) {\r\n      entry.newer.older = null;\r\n    }\r\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n    if (!this.oldest_) {\r\n      this.newest_ = null;\r\n    }\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  replace(key, value) {\r\n    this.get(key); // update `newest_`\r\n    this.entries_[key].value_ = value;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  set(key, value) {\r\n    assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\r\n    const entry = {\r\n      key_: key,\r\n      newer: null,\r\n      older: this.newest_,\r\n      value_: value,\r\n    };\r\n    if (!this.newest_) {\r\n      this.oldest_ = entry;\r\n    } else {\r\n      this.newest_.newer = entry;\r\n    }\r\n    this.newest_ = entry;\r\n    this.entries_[key] = entry;\r\n    ++this.count_;\r\n  }\r\n\r\n  /**\r\n   * Set a maximum number of entries for the cache.\r\n   * @param {number} size Cache size.\r\n   * @api\r\n   */\r\n  setSize(size) {\r\n    this.highWaterMark = size;\r\n  }\r\n}\r\n\r\nexport default LRUCache;\r\n", "/**\r\n * @module ol/TileCache\r\n */\r\nimport LRUCache from './structs/LRUCache.js';\r\nimport {fromKey, getKey} from './tilecoord.js';\r\n\r\nclass TileCache extends LRUCache {\r\n  /**\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(usedTiles) {\r\n    while (this.canExpireCache()) {\r\n      const tile = this.peekLast();\r\n      if (tile.getKey() in usedTiles) {\r\n        break;\r\n      } else {\r\n        this.pop().release();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\r\n   */\r\n  pruneExceptNewestZ() {\r\n    if (this.getCount() === 0) {\r\n      return;\r\n    }\r\n    const key = this.peekFirstKey();\r\n    const tileCoord = fromKey(key);\r\n    const z = tileCoord[0];\r\n    this.forEach(\r\n      function (tile) {\r\n        if (tile.tileCoord[0] !== z) {\r\n          this.remove(getKey(tile.tileCoord));\r\n          tile.release();\r\n        }\r\n      }.bind(this)\r\n    );\r\n  }\r\n}\r\n\r\nexport default TileCache;\r\n", "/**\r\n * @module ol/source/TileEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered when a tile starts loading.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\r\n   * @api\r\n   */\r\n  TILELOADSTART: 'tileloadstart',\r\n\r\n  /**\r\n   * Triggered when a tile finishes loading, either when its data is loaded,\r\n   * or when loading was aborted because the tile is no longer needed.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\r\n   * @api\r\n   */\r\n  TILELOADEND: 'tileloadend',\r\n\r\n  /**\r\n   * Triggered if tile loading results in an error.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\r\n   * @api\r\n   */\r\n  TILELOADERROR: 'tileloaderror',\r\n};\r\n\r\n/**\r\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\r\n */\r\n", "/**\r\n * @module ol/source/Tile\r\n */\r\nimport Event from '../events/Event.js';\r\nimport Source from './Source.js';\r\nimport TileCache from '../TileCache.js';\r\nimport TileState from '../TileState.js';\r\nimport {abstract} from '../util.js';\r\nimport {assert} from '../asserts.js';\r\nimport {equivalent} from '../proj.js';\r\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\r\nimport {\r\n  getForProjection as getTileGridForProjection,\r\n  wrapX,\r\n} from '../tilegrid.js';\r\nimport {scale as scaleSize, toSize} from '../size.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] CacheSize.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {number} [tilePixelRatio] TilePixelRatio.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {import(\"./State.js\").default} [state] State.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\r\n * @property {boolean} [wrapX=false] WrapX.\r\n * @property {number} [transition] Transition.\r\n * @property {string} [key] Key.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for sources providing images divided into a tile grid.\r\n * @abstract\r\n * @api\r\n */\r\nclass TileSource extends Source {\r\n  /**\r\n   * @param {Options} options SourceTile source options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      wrapX: options.wrapX,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.tilePixelRatio_ =\r\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\r\n\r\n    /**\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\r\n     */\r\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\r\n\r\n    const tileSize = [256, 256];\r\n    if (this.tileGrid) {\r\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\r\n    }\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../TileCache.js\").default}\r\n     */\r\n    this.tileCache = new TileCache(options.cacheSize || 0);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.key_ = options.key || '';\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Tile.js\").Options}\r\n     */\r\n    this.tileOptions = {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    };\r\n\r\n    /**\r\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\r\n     * by a renderer if the views resolution does not match any resolution of the tile source.\r\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n     * will be used. If -1, the nearest higher resolution will be used.\r\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\r\n     */\r\n    this.zDirection = options.zDirection ? options.zDirection : 0;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.tileCache.canExpireCache();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (tileCache) {\r\n      tileCache.expireCache(usedTiles);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {number} z Zoom level.\r\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\r\n   *     loaded tile.  If the callback returns `false`, the tile will not be\r\n   *     considered loaded.\r\n   * @return {boolean} The tile range is fully covered with loaded tiles.\r\n   */\r\n  forEachLoadedTile(projection, z, tileRange, callback) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (!tileCache) {\r\n      return false;\r\n    }\r\n\r\n    let covered = true;\r\n    let tile, tileCoordKey, loaded;\r\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n        tileCoordKey = getKeyZXY(z, x, y);\r\n        loaded = false;\r\n        if (tileCache.containsKey(tileCoordKey)) {\r\n          tile = /** @type {!import(\"../Tile.js\").default} */ (\r\n            tileCache.get(tileCoordKey)\r\n          );\r\n          loaded = tile.getState() === TileState.LOADED;\r\n          if (loaded) {\r\n            loaded = callback(tile) !== false;\r\n          }\r\n        }\r\n        if (!loaded) {\r\n          covered = false;\r\n        }\r\n      }\r\n    }\r\n    return covered;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutterForProjection(projection) {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the key to be used for all tiles in the source.\r\n   * @return {string} The key for all tiles.\r\n   */\r\n  getKey() {\r\n    return this.key_;\r\n  }\r\n\r\n  /**\r\n   * Set the value to be used as the key for all tiles in the source.\r\n   * @param {string} key The key for tiles.\r\n   * @protected\r\n   */\r\n  setKey(key) {\r\n    if (this.key_ !== key) {\r\n      this.key_ = key;\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {boolean} Opaque.\r\n   */\r\n  getOpaque(projection) {\r\n    return this.opaque_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>|null} Resolutions.\r\n   */\r\n  getResolutions() {\r\n    if (!this.tileGrid) {\r\n      return null;\r\n    }\r\n    return this.tileGrid.getResolutions();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../Tile.js\").default} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the tile grid of the tile source.\r\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\r\n   * @api\r\n   */\r\n  getTileGrid() {\r\n    return this.tileGrid;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    if (!this.tileGrid) {\r\n      return getTileGridForProjection(projection);\r\n    } else {\r\n      return this.tileGrid;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   * @protected\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    assert(\r\n      equivalent(this.getProjection(), projection),\r\n      68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\r\n    );\r\n    return this.tileCache;\r\n  }\r\n\r\n  /**\r\n   * Get the tile pixel ratio for this source. Subclasses may override this\r\n   * method, which is meant to return a supported pixel ratio that matches the\r\n   * provided `pixelRatio` as close as possible.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @return {number} Tile pixel ratio.\r\n   */\r\n  getTilePixelRatio(pixelRatio) {\r\n    return this.tilePixelRatio_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Z.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../size.js\").Size} Tile size.\r\n   */\r\n  getTilePixelSize(z, pixelRatio, projection) {\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\r\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\r\n    if (tilePixelRatio == 1) {\r\n      return tileSize;\r\n    } else {\r\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\r\n   * is outside the resolution and extent range of the tile grid, `null` will be\r\n   * returned.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../proj/Projection.js\").default} [opt_projection] Projection.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\r\n   *     null if no tile URL should be created for the passed `tileCoord`.\r\n   */\r\n  getTileCoordForTileUrlFunction(tileCoord, opt_projection) {\r\n    const projection =\r\n      opt_projection !== undefined ? opt_projection : this.getProjection();\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    if (this.getWrapX() && projection.isGlobal()) {\r\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\r\n    }\r\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\r\n  }\r\n\r\n  /**\r\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\r\n   * @api\r\n   */\r\n  clear() {\r\n    this.tileCache.clear();\r\n  }\r\n\r\n  refresh() {\r\n    this.clear();\r\n    super.refresh();\r\n  }\r\n\r\n  /**\r\n   * Increases the cache size if needed\r\n   * @param {number} tileCount Minimum number of tiles needed.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   */\r\n  updateCacheSize(tileCount, projection) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (tileCount > tileCache.highWaterMark) {\r\n      tileCache.highWaterMark = tileCount;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Marks a tile coord as being used, without triggering a load.\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   */\r\n  useTile(z, x, y, projection) {}\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\r\n * type.\r\n */\r\nexport class TileSourceEvent extends Event {\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../Tile.js\").default} tile The tile.\r\n   */\r\n  constructor(type, tile) {\r\n    super(type);\r\n\r\n    /**\r\n     * The tile related to the event.\r\n     * @type {import(\"../Tile.js\").default}\r\n     * @api\r\n     */\r\n    this.tile = tile;\r\n  }\r\n}\r\n\r\nexport default TileSource;\r\n", "/**\r\n * @module ol/tileurlfunction\r\n */\r\nimport {assert} from './asserts.js';\r\nimport {modulo} from './math.js';\r\nimport {hash as tileCoordHash} from './tilecoord.js';\r\n\r\n/**\r\n * @param {string} template Template.\r\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\r\n */\r\nexport function createFromTemplate(template, tileGrid) {\r\n  const zRegEx = /\\{z\\}/g;\r\n  const xRegEx = /\\{x\\}/g;\r\n  const yRegEx = /\\{y\\}/g;\r\n  const dashYRegEx = /\\{-y\\}/g;\r\n  return (\r\n    /**\r\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\r\n     * @param {number} pixelRatio Pixel ratio.\r\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n     * @return {string|undefined} Tile URL.\r\n     */\r\n    function (tileCoord, pixelRatio, projection) {\r\n      if (!tileCoord) {\r\n        return undefined;\r\n      } else {\r\n        return template\r\n          .replace(zRegEx, tileCoord[0].toString())\r\n          .replace(xRegEx, tileCoord[1].toString())\r\n          .replace(yRegEx, tileCoord[2].toString())\r\n          .replace(dashYRegEx, function () {\r\n            const z = tileCoord[0];\r\n            const range = tileGrid.getFullTileRange(z);\r\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\r\n            const y = range.getHeight() - tileCoord[2] - 1;\r\n            return y.toString();\r\n          });\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Array<string>} templates Templates.\r\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\r\n */\r\nexport function createFromTemplates(templates, tileGrid) {\r\n  const len = templates.length;\r\n  const tileUrlFunctions = new Array(len);\r\n  for (let i = 0; i < len; ++i) {\r\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\r\n  }\r\n  return createFromTileUrlFunctions(tileUrlFunctions);\r\n}\r\n\r\n/**\r\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\r\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\r\n */\r\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\r\n  if (tileUrlFunctions.length === 1) {\r\n    return tileUrlFunctions[0];\r\n  }\r\n  return (\r\n    /**\r\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\r\n     * @param {number} pixelRatio Pixel ratio.\r\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n     * @return {string|undefined} Tile URL.\r\n     */\r\n    function (tileCoord, pixelRatio, projection) {\r\n      if (!tileCoord) {\r\n        return undefined;\r\n      } else {\r\n        const h = tileCoordHash(tileCoord);\r\n        const index = modulo(h, tileUrlFunctions.length);\r\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {string|undefined} Tile URL.\r\n */\r\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {string} url URL.\r\n * @return {Array<string>} Array of urls.\r\n */\r\nexport function expandUrl(url) {\r\n  const urls = [];\r\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\r\n  if (match) {\r\n    // char range\r\n    const startCharCode = match[1].charCodeAt(0);\r\n    const stopCharCode = match[2].charCodeAt(0);\r\n    let charCode;\r\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\r\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\r\n    }\r\n    return urls;\r\n  }\r\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\r\n  if (match) {\r\n    // number range\r\n    const stop = parseInt(match[2], 10);\r\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\r\n      urls.push(url.replace(match[0], i.toString()));\r\n    }\r\n    return urls;\r\n  }\r\n  urls.push(url);\r\n  return urls;\r\n}\r\n", "/**\r\n * @module ol/source/UrlTile\r\n */\r\nimport TileEventType from './TileEventType.js';\r\nimport TileSource, {TileSourceEvent} from './Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport {createFromTemplates, expandUrl} from '../tileurlfunction.js';\r\nimport {getKeyZXY} from '../tilecoord.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Cache size.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {import(\"./State.js\").default} [state] State.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\r\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\r\n * @property {number} [tilePixelRatio] TilePixelRatio.\r\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] TileUrlFunction.\r\n * @property {string} [url] Url.\r\n * @property {Array<string>} [urls] Urls.\r\n * @property {boolean} [wrapX=true] WrapX.\r\n * @property {number} [transition] Transition.\r\n * @property {string} [key] Key.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for sources providing tiles divided into a tile grid over http.\r\n *\r\n * @fires import(\"./Tile.js\").TileSourceEvent\r\n */\r\nclass UrlTile extends TileSource {\r\n  /**\r\n   * @param {Options} options Image tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      cacheSize: options.cacheSize,\r\n      opaque: options.opaque,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      tileGrid: options.tileGrid,\r\n      tilePixelRatio: options.tilePixelRatio,\r\n      wrapX: options.wrapX,\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n      key: options.key,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      zDirection: options.zDirection,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.generateTileUrlFunction_ =\r\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Tile.js\").LoadFunction}\r\n     */\r\n    this.tileLoadFunction = options.tileLoadFunction;\r\n\r\n    if (options.tileUrlFunction) {\r\n      this.tileUrlFunction = options.tileUrlFunction;\r\n    }\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Array<string>|null}\r\n     */\r\n    this.urls = null;\r\n\r\n    if (options.urls) {\r\n      this.setUrls(options.urls);\r\n    } else if (options.url) {\r\n      this.setUrl(options.url);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, boolean>}\r\n     */\r\n    this.tileLoadingKeys_ = {};\r\n  }\r\n\r\n  /**\r\n   * Return the tile load function of the source.\r\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\r\n   * @api\r\n   */\r\n  getTileLoadFunction() {\r\n    return this.tileLoadFunction;\r\n  }\r\n\r\n  /**\r\n   * Return the tile URL function of the source.\r\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\r\n   * @api\r\n   */\r\n  getTileUrlFunction() {\r\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\r\n      ? this.tileUrlFunction.bind(this)\r\n      : this.tileUrlFunction;\r\n  }\r\n\r\n  /**\r\n   * Return the URLs used for this source.\r\n   * When a tileUrlFunction is used instead of url or urls,\r\n   * null will be returned.\r\n   * @return {!Array<string>|null} URLs.\r\n   * @api\r\n   */\r\n  getUrls() {\r\n    return this.urls;\r\n  }\r\n\r\n  /**\r\n   * Handle tile change events.\r\n   * @param {import(\"../events/Event.js\").default} event Event.\r\n   * @protected\r\n   */\r\n  handleTileChange(event) {\r\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\r\n    const uid = getUid(tile);\r\n    const tileState = tile.getState();\r\n    let type;\r\n    if (tileState == TileState.LOADING) {\r\n      this.tileLoadingKeys_[uid] = true;\r\n      type = TileEventType.TILELOADSTART;\r\n    } else if (uid in this.tileLoadingKeys_) {\r\n      delete this.tileLoadingKeys_[uid];\r\n      type =\r\n        tileState == TileState.ERROR\r\n          ? TileEventType.TILELOADERROR\r\n          : tileState == TileState.LOADED\r\n          ? TileEventType.TILELOADEND\r\n          : undefined;\r\n    }\r\n    if (type != undefined) {\r\n      this.dispatchEvent(new TileSourceEvent(type, tile));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the tile load function of the source.\r\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @api\r\n   */\r\n  setTileLoadFunction(tileLoadFunction) {\r\n    this.tileCache.clear();\r\n    this.tileLoadFunction = tileLoadFunction;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the tile URL function of the source.\r\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\r\n   * @param {string} [key] Optional new tile key for the source.\r\n   * @api\r\n   */\r\n  setTileUrlFunction(tileUrlFunction, key) {\r\n    this.tileUrlFunction = tileUrlFunction;\r\n    this.tileCache.pruneExceptNewestZ();\r\n    if (typeof key !== 'undefined') {\r\n      this.setKey(key);\r\n    } else {\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the URL to use for requests.\r\n   * @param {string} url URL.\r\n   * @api\r\n   */\r\n  setUrl(url) {\r\n    const urls = expandUrl(url);\r\n    this.urls = urls;\r\n    this.setUrls(urls);\r\n  }\r\n\r\n  /**\r\n   * Set the URLs to use for requests.\r\n   * @param {Array<string>} urls URLs.\r\n   * @api\r\n   */\r\n  setUrls(urls) {\r\n    this.urls = urls;\r\n    const key = urls.join('\\n');\r\n    if (this.generateTileUrlFunction_) {\r\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\r\n    } else {\r\n      this.setKey(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {string|undefined} Tile URL.\r\n   */\r\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Marks a tile coord as being used, without triggering a load.\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   */\r\n  useTile(z, x, y) {\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (this.tileCache.containsKey(tileCoordKey)) {\r\n      this.tileCache.get(tileCoordKey);\r\n    }\r\n  }\r\n}\r\n\r\nexport default UrlTile;\r\n", "/**\r\n * @module ol/source/TileImage\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport ImageTile from '../ImageTile.js';\r\nimport ReprojTile from '../reproj/Tile.js';\r\nimport TileCache from '../TileCache.js';\r\nimport TileState from '../TileState.js';\r\nimport UrlTile from './UrlTile.js';\r\nimport {ENABLE_RASTER_REPROJECTION} from '../reproj/common.js';\r\nimport {equivalent, get as getProjection} from '../proj.js';\r\nimport {getKey, getKeyZXY} from '../tilecoord.js';\r\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\r\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\r\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\r\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\r\n * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\r\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\r\n * Higher values can increase reprojection performance, but decrease precision.\r\n * @property {import(\"./State.js\").default} [state] Source state.\r\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\r\n * Default is {@link module:ol/ImageTile~ImageTile}.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\r\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\r\n * ```js\r\n * function(imageTile, src) {\r\n *   imageTile.getImage().src = src;\r\n * };\r\n * ```\r\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\r\n * service advertizes 256px by 256px tiles but actually sends 512px\r\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\r\n * should be set to `2`.\r\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\r\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\r\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\r\n * used instead of defining each one separately in the `urls` option.\r\n * @property {Array<string>} [urls] An array of URL templates.\r\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\r\n * request out-of-bounds tiles from the server. When set to `false`, only one\r\n * world will be rendered. When set to `true`, tiles will be requested for one\r\n * world only, but they will be wrapped horizontally to render multiple worlds.\r\n * @property {number} [transition] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {string} [key] Optional tile key for proper cache fetching\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\r\n * Choose whether to use tiles with a higher or lower zoom level when between integer\r\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for sources providing images divided into a tile grid.\r\n *\r\n * @fires import(\"./Tile.js\").TileSourceEvent\r\n * @api\r\n */\r\nclass TileImage extends UrlTile {\r\n  /**\r\n   * @param {!Options} options Image tile options.\r\n   */\r\n  constructor(options) {\r\n    let interpolate =\r\n      options.imageSmoothing !== undefined ? options.imageSmoothing : true;\r\n    if (options.interpolate !== undefined) {\r\n      interpolate = options.interpolate;\r\n    }\r\n\r\n    super({\r\n      attributions: options.attributions,\r\n      cacheSize: options.cacheSize,\r\n      opaque: options.opaque,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      tileGrid: options.tileGrid,\r\n      tileLoadFunction: options.tileLoadFunction\r\n        ? options.tileLoadFunction\r\n        : defaultTileLoadFunction,\r\n      tilePixelRatio: options.tilePixelRatio,\r\n      tileUrlFunction: options.tileUrlFunction,\r\n      url: options.url,\r\n      urls: options.urls,\r\n      wrapX: options.wrapX,\r\n      transition: options.transition,\r\n      interpolate: interpolate,\r\n      key: options.key,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      zDirection: options.zDirection,\r\n    });\r\n\r\n    /**\r\n     * @protected\r\n     * @type {?string}\r\n     */\r\n    this.crossOrigin =\r\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {typeof ImageTile}\r\n     */\r\n    this.tileClass =\r\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Object<string, TileCache>}\r\n     */\r\n    this.tileCacheForProjection = {};\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\r\n     */\r\n    this.tileGridForProjection = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.renderReprojectionEdges_ = false;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    if (!ENABLE_RASTER_REPROJECTION) {\r\n      return super.canExpireCache();\r\n    }\r\n    if (this.tileCache.canExpireCache()) {\r\n      return true;\r\n    } else {\r\n      for (const key in this.tileCacheForProjection) {\r\n        if (this.tileCacheForProjection[key].canExpireCache()) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    if (!ENABLE_RASTER_REPROJECTION) {\r\n      super.expireCache(projection, usedTiles);\r\n      return;\r\n    }\r\n    const usedTileCache = this.getTileCacheForProjection(projection);\r\n\r\n    this.tileCache.expireCache(\r\n      this.tileCache == usedTileCache ? usedTiles : {}\r\n    );\r\n    for (const id in this.tileCacheForProjection) {\r\n      const tileCache = this.tileCacheForProjection[id];\r\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutterForProjection(projection) {\r\n    if (\r\n      ENABLE_RASTER_REPROJECTION &&\r\n      this.getProjection() &&\r\n      projection &&\r\n      !equivalent(this.getProjection(), projection)\r\n    ) {\r\n      return 0;\r\n    } else {\r\n      return this.getGutter();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutter() {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the key to be used for all tiles in the source.\r\n   * @return {string} The key for all tiles.\r\n   */\r\n  getKey() {\r\n    let key = super.getKey();\r\n    if (!this.getInterpolate()) {\r\n      key += ':disable-interpolation';\r\n    }\r\n    return key;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {boolean} Opaque.\r\n   */\r\n  getOpaque(projection) {\r\n    if (\r\n      ENABLE_RASTER_REPROJECTION &&\r\n      this.getProjection() &&\r\n      projection &&\r\n      !equivalent(this.getProjection(), projection)\r\n    ) {\r\n      return false;\r\n    } else {\r\n      return super.getOpaque(projection);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    if (!ENABLE_RASTER_REPROJECTION) {\r\n      return super.getTileGridForProjection(projection);\r\n    }\r\n    const thisProj = this.getProjection();\r\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\r\n      return this.tileGrid;\r\n    } else {\r\n      const projKey = getUid(projection);\r\n      if (!(projKey in this.tileGridForProjection)) {\r\n        this.tileGridForProjection[projKey] =\r\n          getTileGridForProjection(projection);\r\n      }\r\n      return this.tileGridForProjection[projKey];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    if (!ENABLE_RASTER_REPROJECTION) {\r\n      return super.getTileCacheForProjection(projection);\r\n    }\r\n    const thisProj = this.getProjection();\r\n    if (!thisProj || equivalent(thisProj, projection)) {\r\n      return this.tileCache;\r\n    } else {\r\n      const projKey = getUid(projection);\r\n      if (!(projKey in this.tileCacheForProjection)) {\r\n        this.tileCacheForProjection[projKey] = new TileCache(\r\n          this.tileCache.highWaterMark\r\n        );\r\n      }\r\n      return this.tileCacheForProjection[projKey];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {string} key The key set on the tile.\r\n   * @return {!ImageTile} Tile.\r\n   * @private\r\n   */\r\n  createTile_(z, x, y, pixelRatio, projection, key) {\r\n    const tileCoord = [z, x, y];\r\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\r\n      tileCoord,\r\n      projection\r\n    );\r\n    const tileUrl = urlTileCoord\r\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\r\n      : undefined;\r\n    const tile = new this.tileClass(\r\n      tileCoord,\r\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\r\n      tileUrl !== undefined ? tileUrl : '',\r\n      this.crossOrigin,\r\n      this.tileLoadFunction,\r\n      this.tileOptions\r\n    );\r\n    tile.key = key;\r\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!(ImageTile|ReprojTile)} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    const sourceProjection = this.getProjection();\r\n    if (\r\n      !ENABLE_RASTER_REPROJECTION ||\r\n      !sourceProjection ||\r\n      !projection ||\r\n      equivalent(sourceProjection, projection)\r\n    ) {\r\n      return this.getTileInternal(\r\n        z,\r\n        x,\r\n        y,\r\n        pixelRatio,\r\n        sourceProjection || projection\r\n      );\r\n    } else {\r\n      const cache = this.getTileCacheForProjection(projection);\r\n      const tileCoord = [z, x, y];\r\n      let tile;\r\n      const tileCoordKey = getKey(tileCoord);\r\n      if (cache.containsKey(tileCoordKey)) {\r\n        tile = cache.get(tileCoordKey);\r\n      }\r\n      const key = this.getKey();\r\n      if (tile && tile.key == key) {\r\n        return tile;\r\n      } else {\r\n        const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\r\n        const targetTileGrid = this.getTileGridForProjection(projection);\r\n        const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\r\n          tileCoord,\r\n          projection\r\n        );\r\n        const newTile = new ReprojTile(\r\n          sourceProjection,\r\n          sourceTileGrid,\r\n          projection,\r\n          targetTileGrid,\r\n          tileCoord,\r\n          wrappedTileCoord,\r\n          this.getTilePixelRatio(pixelRatio),\r\n          this.getGutter(),\r\n          function (z, x, y, pixelRatio) {\r\n            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\r\n          }.bind(this),\r\n          this.reprojectionErrorThreshold_,\r\n          this.renderReprojectionEdges_,\r\n          this.getInterpolate()\r\n        );\r\n        newTile.key = key;\r\n\r\n        if (tile) {\r\n          newTile.interimTile = tile;\r\n          newTile.refreshInterimChain();\r\n          cache.replace(tileCoordKey, newTile);\r\n        } else {\r\n          cache.set(tileCoordKey, newTile);\r\n        }\r\n        return newTile;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!(ImageTile|ReprojTile)} Tile.\r\n   * @protected\r\n   */\r\n  getTileInternal(z, x, y, pixelRatio, projection) {\r\n    let tile = null;\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    const key = this.getKey();\r\n    if (!this.tileCache.containsKey(tileCoordKey)) {\r\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\r\n      this.tileCache.set(tileCoordKey, tile);\r\n    } else {\r\n      tile = this.tileCache.get(tileCoordKey);\r\n      if (tile.key != key) {\r\n        // The source's params changed. If the tile has an interim tile and if we\r\n        // can use it then we use it. Otherwise we create a new tile.  In both\r\n        // cases we attempt to assign an interim tile to the new tile.\r\n        const interimTile = tile;\r\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\r\n\r\n        //make the new tile the head of the list,\r\n        if (interimTile.getState() == TileState.IDLE) {\r\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\r\n          tile.interimTile = interimTile.interimTile;\r\n        } else {\r\n          tile.interimTile = interimTile;\r\n        }\r\n        tile.refreshInterimChain();\r\n        this.tileCache.replace(tileCoordKey, tile);\r\n      }\r\n    }\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * Sets whether to render reprojection edges or not (usually for debugging).\r\n   * @param {boolean} render Render the edges.\r\n   * @api\r\n   */\r\n  setRenderReprojectionEdges(render) {\r\n    if (\r\n      !ENABLE_RASTER_REPROJECTION ||\r\n      this.renderReprojectionEdges_ == render\r\n    ) {\r\n      return;\r\n    }\r\n    this.renderReprojectionEdges_ = render;\r\n    for (const id in this.tileCacheForProjection) {\r\n      this.tileCacheForProjection[id].clear();\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Sets the tile grid to use when reprojecting the tiles to the given\r\n   * projection instead of the default tile grid for the projection.\r\n   *\r\n   * This can be useful when the default tile grid cannot be created\r\n   * (e.g. projection has no extent defined) or\r\n   * for optimization reasons (custom tile size, resolutions, ...).\r\n   *\r\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\r\n   * @api\r\n   */\r\n  setTileGridForProjection(projection, tilegrid) {\r\n    if (ENABLE_RASTER_REPROJECTION) {\r\n      const proj = getProjection(projection);\r\n      if (proj) {\r\n        const projKey = getUid(proj);\r\n        if (!(projKey in this.tileGridForProjection)) {\r\n          this.tileGridForProjection[projKey] = tilegrid;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {ImageTile} imageTile Image tile.\r\n * @param {string} src Source.\r\n */\r\nfunction defaultTileLoadFunction(imageTile, src) {\r\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =\r\n    src;\r\n}\r\n\r\nexport default TileImage;\r\n"],
  "mappings": "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",
  "names": ["createOrUpdate", "TileGrid", "createOrUpdate", "scale", "LRUCache", "TileCache", "__extends", "TileSource", "TileSourceEvent", "Tile_default", "__extends", "UrlTile", "Tile_default", "__extends", "TileImage", "z", "x", "y", "pixelRatio"]
}
