{
  "version": 3,
  "sources": ["../../ol/src/reproj.js", "../../ol/src/reproj/Triangulation.js"],
  "sourcesContent": ["/**\r\n * @module ol/reproj\r\n */\r\nimport {IMAGE_SMOOTHING_DISABLED} from './renderer/canvas/common.js';\r\nimport {assign} from './obj.js';\r\nimport {\r\n  containsCoordinate,\r\n  createEmpty,\r\n  extend,\r\n  forEachCorner,\r\n  getCenter,\r\n  getHeight,\r\n  getTopLeft,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\nimport {getPointResolution, transform} from './proj.js';\r\nimport {solveLinearSystem} from './math.js';\r\n\r\nlet brokenDiagonalRendering_;\r\n\r\n/**\r\n * This draws a small triangle into a canvas by setting the triangle as the clip region\r\n * and then drawing a (too large) rectangle\r\n *\r\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\r\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\r\n * @param {number} v1 The y-coordinate of the second point.\r\n * @param {number} u2 The x-coordinate of the third point.\r\n * @param {number} v2 The y-coordinate of the third point.\r\n */\r\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, 0);\r\n  ctx.lineTo(u1, v1);\r\n  ctx.lineTo(u2, v2);\r\n  ctx.closePath();\r\n  ctx.save();\r\n  ctx.clip();\r\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * Given the data from getImageData, see if the right values appear at the provided offset.\r\n * Returns true if either the color or transparency is off\r\n *\r\n * @param {Uint8ClampedArray} data The data returned from getImageData\r\n * @param {number} offset The pixel offset from the start of data.\r\n * @return {boolean} true if the diagonal rendering is broken\r\n */\r\nfunction verifyBrokenDiagonalRendering(data, offset) {\r\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\r\n  return (\r\n    Math.abs(data[offset * 4] - 210) > 2 ||\r\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\r\n  );\r\n}\r\n\r\n/**\r\n * Determines if the current browser configuration can render triangular clip regions correctly.\r\n * This value is cached so the function is only expensive the first time called.\r\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\r\n * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the\r\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\r\n * running, but lets hope not.\r\n *\r\n * @return {boolean} true if the Diagonal Rendering is broken.\r\n */\r\nfunction isBrokenDiagonalRendering() {\r\n  if (brokenDiagonalRendering_ === undefined) {\r\n    const ctx = document.createElement('canvas').getContext('2d');\r\n    ctx.globalCompositeOperation = 'lighter';\r\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\r\n    drawTestTriangle(ctx, 4, 5, 4, 0);\r\n    drawTestTriangle(ctx, 4, 5, 0, 5);\r\n    const data = ctx.getImageData(0, 0, 3, 3).data;\r\n    brokenDiagonalRendering_ =\r\n      verifyBrokenDiagonalRendering(data, 0) ||\r\n      verifyBrokenDiagonalRendering(data, 4) ||\r\n      verifyBrokenDiagonalRendering(data, 8);\r\n  }\r\n\r\n  return brokenDiagonalRendering_;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetCenter,\r\n  targetResolution\r\n) {\r\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\r\n\r\n  // calculate the ideal resolution of the source data\r\n  let sourceResolution = getPointResolution(\r\n    targetProj,\r\n    targetResolution,\r\n    targetCenter\r\n  );\r\n\r\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\r\n  if (targetMetersPerUnit !== undefined) {\r\n    sourceResolution *= targetMetersPerUnit;\r\n  }\r\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\r\n  if (sourceMetersPerUnit !== undefined) {\r\n    sourceResolution /= sourceMetersPerUnit;\r\n  }\r\n\r\n  // Based on the projection properties, the point resolution at the specified\r\n  // coordinates may be slightly different. We need to reverse-compensate this\r\n  // in order to achieve optimal results.\r\n\r\n  const sourceExtent = sourceProj.getExtent();\r\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\r\n    const compensationFactor =\r\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\r\n      sourceResolution;\r\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\r\n      sourceResolution /= compensationFactor;\r\n    }\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceExtentResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetExtent,\r\n  targetResolution\r\n) {\r\n  const targetCenter = getCenter(targetExtent);\r\n  let sourceResolution = calculateSourceResolution(\r\n    sourceProj,\r\n    targetProj,\r\n    targetCenter,\r\n    targetResolution\r\n  );\r\n\r\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n    forEachCorner(targetExtent, function (corner) {\r\n      sourceResolution = calculateSourceResolution(\r\n        sourceProj,\r\n        targetProj,\r\n        corner,\r\n        targetResolution\r\n      );\r\n      return isFinite(sourceResolution) && sourceResolution > 0;\r\n    });\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * @typedef {Object} ImageExtent\r\n * @property {import(\"./extent.js\").Extent} extent Extent.\r\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\r\n */\r\n\r\n/**\r\n * Renders the source data into new canvas based on the triangulation.\r\n *\r\n * @param {number} width Width of the canvas.\r\n * @param {number} height Height of the canvas.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {number} sourceResolution Source resolution.\r\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\r\n * @param {number} targetResolution Target resolution.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\r\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\r\n * @param {Array<ImageExtent>} sources Array of sources.\r\n * @param {number} gutter Gutter of the sources.\r\n * @param {boolean} [opt_renderEdges] Render reprojection edges.\r\n * @param {object} [opt_interpolate] Use linear interpolation when resampling.\r\n * @return {HTMLCanvasElement} Canvas with reprojected data.\r\n */\r\nexport function render(\r\n  width,\r\n  height,\r\n  pixelRatio,\r\n  sourceResolution,\r\n  sourceExtent,\r\n  targetResolution,\r\n  targetExtent,\r\n  triangulation,\r\n  sources,\r\n  gutter,\r\n  opt_renderEdges,\r\n  opt_interpolate\r\n) {\r\n  const context = createCanvasContext2D(\r\n    Math.round(pixelRatio * width),\r\n    Math.round(pixelRatio * height)\r\n  );\r\n\r\n  if (!opt_interpolate) {\r\n    assign(context, IMAGE_SMOOTHING_DISABLED);\r\n  }\r\n\r\n  if (sources.length === 0) {\r\n    return context.canvas;\r\n  }\r\n\r\n  context.scale(pixelRatio, pixelRatio);\r\n\r\n  function pixelRound(value) {\r\n    return Math.round(value * pixelRatio) / pixelRatio;\r\n  }\r\n\r\n  context.globalCompositeOperation = 'lighter';\r\n\r\n  const sourceDataExtent = createEmpty();\r\n  sources.forEach(function (src, i, arr) {\r\n    extend(sourceDataExtent, src.extent);\r\n  });\r\n\r\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\r\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\r\n  const stitchContext = createCanvasContext2D(\r\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\r\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution)\r\n  );\r\n\r\n  if (!opt_interpolate) {\r\n    assign(stitchContext, IMAGE_SMOOTHING_DISABLED);\r\n  }\r\n\r\n  const stitchScale = pixelRatio / sourceResolution;\r\n\r\n  sources.forEach(function (src, i, arr) {\r\n    const xPos = src.extent[0] - sourceDataExtent[0];\r\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\r\n    const srcWidth = getWidth(src.extent);\r\n    const srcHeight = getHeight(src.extent);\r\n\r\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\r\n    if (src.image.width > 0 && src.image.height > 0) {\r\n      stitchContext.drawImage(\r\n        src.image,\r\n        gutter,\r\n        gutter,\r\n        src.image.width - 2 * gutter,\r\n        src.image.height - 2 * gutter,\r\n        xPos * stitchScale,\r\n        yPos * stitchScale,\r\n        srcWidth * stitchScale,\r\n        srcHeight * stitchScale\r\n      );\r\n    }\r\n  });\r\n\r\n  const targetTopLeft = getTopLeft(targetExtent);\r\n\r\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n    /* Calculate affine transform (src -> dst)\r\n     * Resulting matrix can be used to transform coordinate\r\n     * from `sourceProjection` to destination pixels.\r\n     *\r\n     * To optimize number of context calls and increase numerical stability,\r\n     * we also do the following operations:\r\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\r\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\r\n     *\r\n     * Src points: xi, yi\r\n     * Dst points: ui, vi\r\n     * Affine coefficients: aij\r\n     *\r\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\r\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\r\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\r\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\r\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\r\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\r\n     */\r\n    const source = triangle.source;\r\n    const target = triangle.target;\r\n    let x0 = source[0][0],\r\n      y0 = source[0][1];\r\n    let x1 = source[1][0],\r\n      y1 = source[1][1];\r\n    let x2 = source[2][0],\r\n      y2 = source[2][1];\r\n    // Make sure that everything is on pixel boundaries\r\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\r\n    const v0 = pixelRound(\r\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\r\n    );\r\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\r\n    const v1 = pixelRound(\r\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\r\n    );\r\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\r\n    const v2 = pixelRound(\r\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\r\n    );\r\n\r\n    // Shift all the source points to improve numerical stability\r\n    // of all the subsequent calculations. The [x0, y0] is used here.\r\n    // This is also used to simplify the linear system.\r\n    const sourceNumericalShiftX = x0;\r\n    const sourceNumericalShiftY = y0;\r\n    x0 = 0;\r\n    y0 = 0;\r\n    x1 -= sourceNumericalShiftX;\r\n    y1 -= sourceNumericalShiftY;\r\n    x2 -= sourceNumericalShiftX;\r\n    y2 -= sourceNumericalShiftY;\r\n\r\n    const augmentedMatrix = [\r\n      [x1, y1, 0, 0, u1 - u0],\r\n      [x2, y2, 0, 0, u2 - u0],\r\n      [0, 0, x1, y1, v1 - v0],\r\n      [0, 0, x2, y2, v2 - v0],\r\n    ];\r\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\r\n    if (!affineCoefs) {\r\n      return;\r\n    }\r\n\r\n    context.save();\r\n    context.beginPath();\r\n\r\n    if (isBrokenDiagonalRendering() || !opt_interpolate) {\r\n      // Make sure that all lines are horizontal or vertical\r\n      context.moveTo(u1, v1);\r\n      // This is the diagonal line. Do it in 4 steps\r\n      const steps = 4;\r\n      const ud = u0 - u1;\r\n      const vd = v0 - v1;\r\n      for (let step = 0; step < steps; step++) {\r\n        // Go horizontally\r\n        context.lineTo(\r\n          u1 + pixelRound(((step + 1) * ud) / steps),\r\n          v1 + pixelRound((step * vd) / (steps - 1))\r\n        );\r\n        // Go vertically\r\n        if (step != steps - 1) {\r\n          context.lineTo(\r\n            u1 + pixelRound(((step + 1) * ud) / steps),\r\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\r\n          );\r\n        }\r\n      }\r\n      // We are almost at u0r, v0r\r\n      context.lineTo(u2, v2);\r\n    } else {\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n    }\r\n\r\n    context.clip();\r\n\r\n    context.transform(\r\n      affineCoefs[0],\r\n      affineCoefs[2],\r\n      affineCoefs[1],\r\n      affineCoefs[3],\r\n      u0,\r\n      v0\r\n    );\r\n\r\n    context.translate(\r\n      sourceDataExtent[0] - sourceNumericalShiftX,\r\n      sourceDataExtent[3] - sourceNumericalShiftY\r\n    );\r\n\r\n    context.scale(\r\n      sourceResolution / pixelRatio,\r\n      -sourceResolution / pixelRatio\r\n    );\r\n\r\n    context.drawImage(stitchContext.canvas, 0, 0);\r\n    context.restore();\r\n  });\r\n\r\n  if (opt_renderEdges) {\r\n    context.save();\r\n\r\n    context.globalCompositeOperation = 'source-over';\r\n    context.strokeStyle = 'black';\r\n    context.lineWidth = 1;\r\n\r\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n      const target = triangle.target;\r\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\r\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\r\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\r\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\r\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\r\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\r\n\r\n      context.beginPath();\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n      context.closePath();\r\n      context.stroke();\r\n    });\r\n\r\n    context.restore();\r\n  }\r\n  return context.canvas;\r\n}\r\n", "/**\r\n * @module ol/reproj/Triangulation\r\n */\r\nimport {\r\n  boundingExtent,\r\n  createEmpty,\r\n  extendCoordinate,\r\n  getArea,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n  getWidth,\r\n  intersects,\r\n} from '../extent.js';\r\nimport {getTransform} from '../proj.js';\r\nimport {log2, modulo} from '../math.js';\r\n\r\n/**\r\n * Single triangle; consists of 3 source points and 3 target points.\r\n * @typedef {Object} Triangle\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\r\n */\r\n\r\n/**\r\n * Maximum number of subdivision steps during raster reprojection triangulation.\r\n * Prevents high memory usage and large number of proj4 calls (for certain\r\n * transformations and areas). At most `2*(2^this)` triangles are created for\r\n * each triangulated extent (tile/image).\r\n * @type {number}\r\n */\r\nconst MAX_SUBDIVISION = 10;\r\n\r\n/**\r\n * Maximum allowed size of triangle relative to world width. When transforming\r\n * corners of world extent between certain projections, the resulting\r\n * triangulation seems to have zero error and no subdivision is performed. If\r\n * the triangle width is more than this (relative to world width; 0-1),\r\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\r\n * @type {number}\r\n */\r\nconst MAX_TRIANGLE_WIDTH = 0.25;\r\n\r\n/**\r\n * @classdesc\r\n * Class containing triangulation of the given target extent.\r\n * Used for determining source data and the reprojection itself.\r\n */\r\nclass Triangulation {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\r\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\r\n   * @param {number} errorThreshold Acceptable error (in source units).\r\n   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    targetProj,\r\n    targetExtent,\r\n    maxSourceExtent,\r\n    errorThreshold,\r\n    opt_destinationResolution\r\n  ) {\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.sourceProj_ = sourceProj;\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.targetProj_ = targetProj;\r\n\r\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\r\n    let transformInvCache = {};\r\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\r\n\r\n    /**\r\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\r\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\r\n     * @private\r\n     */\r\n    this.transformInv_ = function (c) {\r\n      const key = c[0] + '/' + c[1];\r\n      if (!transformInvCache[key]) {\r\n        transformInvCache[key] = transformInv(c);\r\n      }\r\n      return transformInvCache[key];\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.maxSourceExtent_ = maxSourceExtent;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\r\n\r\n    /**\r\n     * @type {Array<Triangle>}\r\n     * @private\r\n     */\r\n    this.triangles_ = [];\r\n\r\n    /**\r\n     * Indicates that the triangulation crosses edge of the source projection.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.wrapsXInSource_ = false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.canWrapXInSource_ =\r\n      this.sourceProj_.canWrapX() &&\r\n      !!maxSourceExtent &&\r\n      !!this.sourceProj_.getExtent() &&\r\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\r\n      ? getWidth(this.sourceProj_.getExtent())\r\n      : null;\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\r\n      ? getWidth(this.targetProj_.getExtent())\r\n      : null;\r\n\r\n    const destinationTopLeft = getTopLeft(targetExtent);\r\n    const destinationTopRight = getTopRight(targetExtent);\r\n    const destinationBottomRight = getBottomRight(targetExtent);\r\n    const destinationBottomLeft = getBottomLeft(targetExtent);\r\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\r\n    const sourceTopRight = this.transformInv_(destinationTopRight);\r\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\r\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\r\n\r\n    /*\r\n     * The maxSubdivision controls how many splittings of the target area can\r\n     * be done. The idea here is to do a linear mapping of the target areas\r\n     * but the actual overal reprojection (can be) extremely non-linear. The\r\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\r\n     * tile size. However this function is also called to remap canvas rendered\r\n     * layers which can be much larger. This calculation increases the maxSubdivision\r\n     * value by the right factor so that each 256x256 pixel area has\r\n     * MAX_SUBDIVISION divisions.\r\n     */\r\n    const maxSubdivision =\r\n      MAX_SUBDIVISION +\r\n      (opt_destinationResolution\r\n        ? Math.max(\r\n            0,\r\n            Math.ceil(\r\n              log2(\r\n                getArea(targetExtent) /\r\n                  (opt_destinationResolution *\r\n                    opt_destinationResolution *\r\n                    256 *\r\n                    256)\r\n              )\r\n            )\r\n          )\r\n        : 0);\r\n\r\n    this.addQuad_(\r\n      destinationTopLeft,\r\n      destinationTopRight,\r\n      destinationBottomRight,\r\n      destinationBottomLeft,\r\n      sourceTopLeft,\r\n      sourceTopRight,\r\n      sourceBottomRight,\r\n      sourceBottomLeft,\r\n      maxSubdivision\r\n    );\r\n\r\n    if (this.wrapsXInSource_) {\r\n      let leftBound = Infinity;\r\n      this.triangles_.forEach(function (triangle, i, arr) {\r\n        leftBound = Math.min(\r\n          leftBound,\r\n          triangle.source[0][0],\r\n          triangle.source[1][0],\r\n          triangle.source[2][0]\r\n        );\r\n      });\r\n\r\n      // Shift triangles to be as close to `leftBound` as possible\r\n      // (if the distance is more than `worldWidth / 2` it can be closer.\r\n      this.triangles_.forEach(\r\n        function (triangle) {\r\n          if (\r\n            Math.max(\r\n              triangle.source[0][0],\r\n              triangle.source[1][0],\r\n              triangle.source[2][0]\r\n            ) -\r\n              leftBound >\r\n            this.sourceWorldWidth_ / 2\r\n          ) {\r\n            const newTriangle = [\r\n              [triangle.source[0][0], triangle.source[0][1]],\r\n              [triangle.source[1][0], triangle.source[1][1]],\r\n              [triangle.source[2][0], triangle.source[2][1]],\r\n            ];\r\n            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n              newTriangle[0][0] -= this.sourceWorldWidth_;\r\n            }\r\n            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n              newTriangle[1][0] -= this.sourceWorldWidth_;\r\n            }\r\n            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n              newTriangle[2][0] -= this.sourceWorldWidth_;\r\n            }\r\n\r\n            // Rarely (if the extent contains both the dateline and prime meridian)\r\n            // the shift can in turn break some triangles.\r\n            // Detect this here and don't shift in such cases.\r\n            const minX = Math.min(\r\n              newTriangle[0][0],\r\n              newTriangle[1][0],\r\n              newTriangle[2][0]\r\n            );\r\n            const maxX = Math.max(\r\n              newTriangle[0][0],\r\n              newTriangle[1][0],\r\n              newTriangle[2][0]\r\n            );\r\n            if (maxX - minX < this.sourceWorldWidth_ / 2) {\r\n              triangle.source = newTriangle;\r\n            }\r\n          }\r\n        }.bind(this)\r\n      );\r\n    }\r\n\r\n    transformInvCache = {};\r\n  }\r\n\r\n  /**\r\n   * Adds triangle to the triangulation.\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @private\r\n   */\r\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\r\n    this.triangles_.push({\r\n      source: [aSrc, bSrc, cSrc],\r\n      target: [a, b, c],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds quad (points in clock-wise order) to the triangulation\r\n   * (and reprojects the vertices) if valid.\r\n   * Performs quad subdivision if needed to increase precision.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\r\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\r\n   * @private\r\n   */\r\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\r\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\r\n    const sourceCoverageX = this.sourceWorldWidth_\r\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\r\n      : null;\r\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\r\n\r\n    // when the quad is wrapped in the source projection\r\n    // it covers most of the projection extent, but not fully\r\n    const wrapsX =\r\n      this.sourceProj_.canWrapX() &&\r\n      sourceCoverageX > 0.5 &&\r\n      sourceCoverageX < 1;\r\n\r\n    let needsSubdivision = false;\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\r\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\r\n        const targetCoverageX =\r\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\r\n        needsSubdivision =\r\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\r\n        needsSubdivision =\r\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n    }\r\n\r\n    if (!needsSubdivision && this.maxSourceExtent_) {\r\n      if (\r\n        isFinite(sourceQuadExtent[0]) &&\r\n        isFinite(sourceQuadExtent[1]) &&\r\n        isFinite(sourceQuadExtent[2]) &&\r\n        isFinite(sourceQuadExtent[3])\r\n      ) {\r\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\r\n          // whole quad outside source projection extent -> ignore\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    let isNotFinite = 0;\r\n\r\n    if (!needsSubdivision) {\r\n      if (\r\n        !isFinite(aSrc[0]) ||\r\n        !isFinite(aSrc[1]) ||\r\n        !isFinite(bSrc[0]) ||\r\n        !isFinite(bSrc[1]) ||\r\n        !isFinite(cSrc[0]) ||\r\n        !isFinite(cSrc[1]) ||\r\n        !isFinite(dSrc[0]) ||\r\n        !isFinite(dSrc[1])\r\n      ) {\r\n        if (maxSubdivision > 0) {\r\n          needsSubdivision = true;\r\n        } else {\r\n          // It might be the case that only 1 of the points is infinite. In this case\r\n          // we can draw a single triangle with the other three points\r\n          isNotFinite =\r\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\r\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\r\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\r\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\r\n          if (\r\n            isNotFinite != 1 &&\r\n            isNotFinite != 2 &&\r\n            isNotFinite != 4 &&\r\n            isNotFinite != 8\r\n          ) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (!needsSubdivision) {\r\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\r\n        const centerSrc = this.transformInv_(center);\r\n\r\n        let dx;\r\n        if (wrapsX) {\r\n          const centerSrcEstimX =\r\n            (modulo(aSrc[0], sourceWorldWidth) +\r\n              modulo(cSrc[0], sourceWorldWidth)) /\r\n            2;\r\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\r\n        } else {\r\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\r\n        }\r\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\r\n        const centerSrcErrorSquared = dx * dx + dy * dy;\r\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\r\n      }\r\n      if (needsSubdivision) {\r\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\r\n          // split horizontally (top & bottom)\r\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\r\n          const bcSrc = this.transformInv_(bc);\r\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\r\n          const daSrc = this.transformInv_(da);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            b,\r\n            bc,\r\n            da,\r\n            aSrc,\r\n            bSrc,\r\n            bcSrc,\r\n            daSrc,\r\n            maxSubdivision - 1\r\n          );\r\n          this.addQuad_(\r\n            da,\r\n            bc,\r\n            c,\r\n            d,\r\n            daSrc,\r\n            bcSrc,\r\n            cSrc,\r\n            dSrc,\r\n            maxSubdivision - 1\r\n          );\r\n        } else {\r\n          // split vertically (left & right)\r\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\r\n          const abSrc = this.transformInv_(ab);\r\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\r\n          const cdSrc = this.transformInv_(cd);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            ab,\r\n            cd,\r\n            d,\r\n            aSrc,\r\n            abSrc,\r\n            cdSrc,\r\n            dSrc,\r\n            maxSubdivision - 1\r\n          );\r\n          this.addQuad_(\r\n            ab,\r\n            b,\r\n            c,\r\n            cd,\r\n            abSrc,\r\n            bSrc,\r\n            cSrc,\r\n            cdSrc,\r\n            maxSubdivision - 1\r\n          );\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (wrapsX) {\r\n      if (!this.canWrapXInSource_) {\r\n        return;\r\n      }\r\n      this.wrapsXInSource_ = true;\r\n    }\r\n\r\n    // Exactly zero or one of *Src is not finite\r\n    // The triangles must have the diagonal line as the first side\r\n    // This is to allow easy code in reproj.s to make it straight for broken\r\n    // browsers that can't handle diagonal clipping\r\n    if ((isNotFinite & 0xb) == 0) {\r\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\r\n    }\r\n    if ((isNotFinite & 0xe) == 0) {\r\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\r\n    }\r\n    if (isNotFinite) {\r\n      // Try the other two triangles\r\n      if ((isNotFinite & 0xd) == 0) {\r\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\r\n      }\r\n      if ((isNotFinite & 0x7) == 0) {\r\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates extent of the `source` coordinates from all the triangles.\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\r\n   */\r\n  calculateSourceExtent() {\r\n    const extent = createEmpty();\r\n\r\n    this.triangles_.forEach(function (triangle, i, arr) {\r\n      const src = triangle.source;\r\n      extendCoordinate(extent, src[0]);\r\n      extendCoordinate(extent, src[1]);\r\n      extendCoordinate(extent, src[2]);\r\n    });\r\n\r\n    return extent;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Triangle>} Array of the calculated triangles.\r\n   */\r\n  getTriangles() {\r\n    return this.triangles_;\r\n  }\r\n}\r\n\r\nexport default Triangulation;\r\n"],
  "mappings": "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",
  "names": ["Triangulation"]
}
