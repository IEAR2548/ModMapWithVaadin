{
  "version": 3,
  "sources": ["../../@vaadin/a11y-base/src/aria-id-reference.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2023 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport {\r\n  addValueToAttribute,\r\n  deserializeAttributeValue,\r\n  removeValueFromAttribute,\r\n  serializeAttributeValue,\r\n} from '@vaadin/component-base/src/dom-utils.js';\r\n\r\nconst attributeToTargets = new Map();\r\n\r\n/**\r\n * Gets or creates a Set with the stored values for each element controlled by this helper\r\n *\r\n * @param {string} attr the attribute name used as key in the map\r\n *\r\n * @returns {WeakMap<HTMLElement, Set<string>} a weak map with the stored values for the elements being controlled by the helper\r\n */\r\nfunction getAttrMap(attr) {\r\n  if (!attributeToTargets.has(attr)) {\r\n    attributeToTargets.set(attr, new WeakMap());\r\n  }\r\n  return attributeToTargets.get(attr);\r\n}\r\n\r\n/**\r\n * Cleans the values set on the attribute to the given element.\r\n * It also stores the current values in the map, if `storeValue` is `true`.\r\n *\r\n * @param {HTMLElement} target\r\n * @param {string} attr the attribute to be cleared\r\n * @param {boolean} storeValue whether or not the current value of the attribute should be stored on the map\r\n * @returns\r\n */\r\nfunction cleanAriaIDReference(target, attr) {\r\n  if (!target) {\r\n    return;\r\n  }\r\n\r\n  target.removeAttribute(attr);\r\n}\r\n\r\n/**\r\n * Storing values of the accessible attributes in a Set inside of the WeakMap.\r\n *\r\n * @param {HTMLElement} target\r\n * @param {string} attr the attribute to be stored\r\n */\r\nfunction storeAriaIDReference(target, attr) {\r\n  if (!target || !attr) {\r\n    return;\r\n  }\r\n  const attributeMap = getAttrMap(attr);\r\n  if (attributeMap.has(target)) {\r\n    return;\r\n  }\r\n  const values = deserializeAttributeValue(target.getAttribute(attr));\r\n  attributeMap.set(target, new Set(values));\r\n}\r\n\r\n/**\r\n * Restores the generated values of the attribute to the given element.\r\n *\r\n * @param {HTMLElement} target\r\n * @param {string} attr\r\n */\r\nexport function restoreGeneratedAriaIDReference(target, attr) {\r\n  if (!target || !attr) {\r\n    return;\r\n  }\r\n  const attributeMap = getAttrMap(attr);\r\n  const values = attributeMap.get(target);\r\n  if (!values || values.size === 0) {\r\n    target.removeAttribute(attr);\r\n  } else {\r\n    addValueToAttribute(target, attr, serializeAttributeValue(values));\r\n  }\r\n  attributeMap.delete(target);\r\n}\r\n\r\n/**\r\n * Sets a new ID reference for a target element and an ARIA attribute.\r\n *\r\n * @typedef {Object} AriaIdReferenceConfig\r\n * @property {string | null | undefined} newId\r\n * @property {string | null | undefined} oldId\r\n * @property {boolean | null | undefined} fromUser\r\n * @param {HTMLElement} target\r\n * @param {string} attr\r\n * @param {AriaIdReferenceConfig | null | undefined} config\r\n * @param config.newId The new ARIA ID reference to set. If `null`, the attribute is removed,\r\n * and `config.fromUser` is true, any stored values are restored. If there are stored values\r\n * and `config.fromUser` is `false`, then `config.newId` is added to the stored values set.\r\n * @param config.oldId The ARIA ID reference to be removed from the attribute. If there are\r\n * stored values and `config.fromUser` is `false`, then `config.oldId` is removed from the\r\n * stored values set.\r\n * @param config.fromUser Indicates whether the function is called by the user or internally.\r\n * When `config.fromUser` is called with `true` for the first time, the function will clear\r\n * and store the attribute value for the given element.\r\n */\r\nexport function setAriaIDReference(target, attr, config = { newId: null, oldId: null, fromUser: false }) {\r\n  if (!target || !attr) {\r\n    return;\r\n  }\r\n\r\n  const { newId, oldId, fromUser } = config;\r\n\r\n  const attributeMap = getAttrMap(attr);\r\n  const storedValues = attributeMap.get(target);\r\n\r\n  if (!fromUser && !!storedValues) {\r\n    // If there's any stored values, it means the attribute is being handled by the user\r\n    // Replace the \"oldId\" with \"newId\" on the stored values set and leave\r\n    oldId && storedValues.delete(oldId);\r\n    newId && storedValues.add(newId);\r\n    return;\r\n  }\r\n\r\n  if (fromUser) {\r\n    if (!storedValues) {\r\n      // If it's called from user and there's no stored values for the attribute,\r\n      // then store the current value\r\n      storeAriaIDReference(target, attr);\r\n    } else if (!newId) {\r\n      // If called from user with newId == null, it means the attribute will no longer\r\n      // be in control of the user and the stored values should be restored\r\n      // Removing the entry on the map for this target\r\n      attributeMap.delete(target);\r\n    }\r\n\r\n    // If it's from user, then clear the attribute value before setting newId\r\n    cleanAriaIDReference(target, attr);\r\n  }\r\n\r\n  removeValueFromAttribute(target, attr, oldId);\r\n\r\n  const attributeValue = !newId ? serializeAttributeValue(storedValues) : newId;\r\n  if (attributeValue) {\r\n    addValueToAttribute(target, attr, attributeValue);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes the {@link attr | attribute} value of the given {@link target} element.\r\n * It also stores the current value, if no stored values are present.\r\n *\r\n * @param {HTMLElement} target\r\n * @param {string} attr\r\n */\r\nexport function removeAriaIDReference(target, attr) {\r\n  storeAriaIDReference(target, attr);\r\n  cleanAriaIDReference(target, attr);\r\n}\r\n"],
  "mappings": ";;;;;;;;AAYA,IAAM,qBAAqB,oBAAI,IAAI;AASnC,SAAS,WAAW,MAAM;AACxB,MAAI,CAAC,mBAAmB,IAAI,IAAI,GAAG;AACjC,uBAAmB,IAAI,MAAM,oBAAI,QAAQ,CAAC;AAAA,EAC5C;AACA,SAAO,mBAAmB,IAAI,IAAI;AACpC;AAWA,SAAS,qBAAqB,QAAQ,MAAM;AAC1C,MAAI,CAAC,QAAQ;AACX;AAAA,EACF;AAEA,SAAO,gBAAgB,IAAI;AAC7B;AAQA,SAAS,qBAAqB,QAAQ,MAAM;AAC1C,MAAI,CAAC,UAAU,CAAC,MAAM;AACpB;AAAA,EACF;AACA,QAAM,eAAe,WAAW,IAAI;AACpC,MAAI,aAAa,IAAI,MAAM,GAAG;AAC5B;AAAA,EACF;AACA,QAAM,SAAS,0BAA0B,OAAO,aAAa,IAAI,CAAC;AAClE,eAAa,IAAI,QAAQ,IAAI,IAAI,MAAM,CAAC;AAC1C;AAQO,SAAS,gCAAgC,QAAQ,MAAM;AAC5D,MAAI,CAAC,UAAU,CAAC,MAAM;AACpB;AAAA,EACF;AACA,QAAM,eAAe,WAAW,IAAI;AACpC,QAAM,SAAS,aAAa,IAAI,MAAM;AACtC,MAAI,CAAC,UAAU,OAAO,SAAS,GAAG;AAChC,WAAO,gBAAgB,IAAI;AAAA,EAC7B,OAAO;AACL,wBAAoB,QAAQ,MAAM,wBAAwB,MAAM,CAAC;AAAA,EACnE;AACA,eAAa,OAAO,MAAM;AAC5B;AAsBO,SAAS,mBAAmB,QAAQ,MAAM,SAAS,EAAE,OAAO,MAAM,OAAO,MAAM,UAAU,MAAM,GAAG;AACvG,MAAI,CAAC,UAAU,CAAC,MAAM;AACpB;AAAA,EACF;AAEA,QAAM,EAAE,OAAO,OAAO,SAAS,IAAI;AAEnC,QAAM,eAAe,WAAW,IAAI;AACpC,QAAM,eAAe,aAAa,IAAI,MAAM;AAE5C,MAAI,CAAC,YAAY,CAAC,CAAC,cAAc;AAG/B,aAAS,aAAa,OAAO,KAAK;AAClC,aAAS,aAAa,IAAI,KAAK;AAC/B;AAAA,EACF;AAEA,MAAI,UAAU;AACZ,QAAI,CAAC,cAAc;AAGjB,2BAAqB,QAAQ,IAAI;AAAA,IACnC,WAAW,CAAC,OAAO;AAIjB,mBAAa,OAAO,MAAM;AAAA,IAC5B;AAGA,yBAAqB,QAAQ,IAAI;AAAA,EACnC;AAEA,2BAAyB,QAAQ,MAAM,KAAK;AAE5C,QAAM,iBAAiB,CAAC,QAAQ,wBAAwB,YAAY,IAAI;AACxE,MAAI,gBAAgB;AAClB,wBAAoB,QAAQ,MAAM,cAAc;AAAA,EAClD;AACF;AASO,SAAS,sBAAsB,QAAQ,MAAM;AAClD,uBAAqB,QAAQ,IAAI;AACjC,uBAAqB,QAAQ,IAAI;AACnC;",
  "names": []
}
