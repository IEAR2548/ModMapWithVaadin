import {
  formLayoutStyles
} from "./chunk-VDTQCTVO.js";
import {
  ResizeMixin
} from "./chunk-2OEODMLR.js";
import {
  ElementMixin
} from "./chunk-QN4QZSZG.js";
import {
  isElementHidden
} from "./chunk-CXDC5LNX.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-KEWLZU7R.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import {
  PolymerElement
} from "./chunk-YBEXGSZO.js";
import {
  html
} from "./chunk-QO5P4LIH.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";

// node_modules/@vaadin/form-layout/theme/lumo/vaadin-form-layout-styles.js
registerStyles(
  "vaadin-form-layout",
  css`
    :host {
      --vaadin-form-layout-column-spacing: var(--lumo-space-l);
      --vaadin-form-layout-row-spacing: 0;
    }
  `,
  { moduleId: "lumo-form-layout" }
);

// node_modules/@vaadin/form-layout/src/vaadin-form-layout-mixin.js
function isValidCSSLength(value) {
  return CSS.supports("word-spacing", value) && !["inherit", "normal"].includes(value);
}
var FormLayoutMixin = (superClass) => class extends ResizeMixin(superClass) {
  static get properties() {
    return {
      /**
       * @typedef FormLayoutResponsiveStep
       * @type {object}
       * @property {string} minWidth - The threshold value for this step in CSS length units.
       * @property {number} columns - Number of columns. Only natural numbers are valid.
       * @property {string} labelsPosition - Labels position option, valid values: `"aside"` (default), `"top"`.
       */
      /**
       * Allows specifying a responsive behavior with the number of columns
       * and the label position depending on the layout width.
       *
       * Format: array of objects, each object defines one responsive step
       * with `minWidth` CSS length, `columns` number, and optional
       * `labelsPosition` string of `"aside"` or `"top"`. At least one item is required.
       *
       * #### Examples
       *
       * ```javascript
       * formLayout.responsiveSteps = [{columns: 1}];
       * // The layout is always a single column, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Sets two responsive steps:
       * // 1. When the layout width is < 40em, one column, labels aside.
       * // 2. Width >= 40em, two columns, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1, labelsPosition: 'top'},
       *   {minWidth: '20em', columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Default value. Three responsive steps:
       * // 1. Width < 20em, one column, labels on top.
       * // 2. 20em <= width < 40em, one column, labels aside.
       * // 3. Width >= 40em, two columns, labels aside.
       * ```
       *
       * @type {!Array<!FormLayoutResponsiveStep>}
       */
      responsiveSteps: {
        type: Array,
        value() {
          return [
            { minWidth: 0, columns: 1, labelsPosition: "top" },
            { minWidth: "20em", columns: 1 },
            { minWidth: "40em", columns: 2 }
          ];
        },
        observer: "_responsiveStepsChanged",
        sync: true
      },
      /**
       * Current number of columns in the layout
       * @private
       */
      _columnCount: {
        type: Number,
        sync: true
      },
      /**
       * Indicates that labels are on top
       * @private
       */
      _labelsOnTop: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_invokeUpdateLayout(_columnCount, _labelsOnTop)"];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__childrenObserver = new MutationObserver(() => this._updateLayout());
    this.__childrenObserver.observe(this, { childList: true });
    this.__childrenAttributesObserver = new MutationObserver((mutations) => {
      if (mutations.some((mutation) => mutation.target.parentElement === this)) {
        this._updateLayout();
      }
    });
    this.__childrenAttributesObserver.observe(this, {
      subtree: true,
      attributes: true,
      attributeFilter: ["colspan", "data-colspan", "hidden"]
    });
    requestAnimationFrame(() => this._selectResponsiveStep());
    requestAnimationFrame(() => this._updateLayout());
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__childrenObserver.disconnect();
    this.__childrenAttributesObserver.disconnect();
  }
  /** @private */
  _naturalNumberOrOne(n) {
    if (typeof n === "number" && n >= 1 && n < Infinity) {
      return Math.floor(n);
    }
    return 1;
  }
  /** @private */
  _responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
    try {
      if (!Array.isArray(responsiveSteps)) {
        throw new Error('Invalid "responsiveSteps" type, an Array is required.');
      }
      if (responsiveSteps.length < 1) {
        throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
      }
      responsiveSteps.forEach((step) => {
        if (this._naturalNumberOrOne(step.columns) !== step.columns) {
          throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
        }
        if (step.minWidth !== void 0 && !isValidCSSLength(step.minWidth)) {
          throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
        }
        if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
          throw new Error(
            `Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`
          );
        }
      });
    } catch (e) {
      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
        console.warn(`${e.message} Using previously set 'responsiveSteps' instead.`);
        this.responsiveSteps = oldResponsiveSteps;
      } else {
        console.warn(`${e.message} Using default 'responsiveSteps' instead.`);
        this.responsiveSteps = [
          { minWidth: 0, columns: 1, labelsPosition: "top" },
          { minWidth: "20em", columns: 1 },
          { minWidth: "40em", columns: 2 }
        ];
      }
    }
    this._selectResponsiveStep();
  }
  /** @private */
  _selectResponsiveStep() {
    let selectedStep;
    const tmpStyleProp = "background-position";
    this.responsiveSteps.forEach((step) => {
      this.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
      const stepMinWidthPx = parseFloat(getComputedStyle(this.$.layout).getPropertyValue(tmpStyleProp));
      if (stepMinWidthPx <= this.offsetWidth) {
        selectedStep = step;
      }
    });
    this.$.layout.style.removeProperty(tmpStyleProp);
    if (selectedStep) {
      this._columnCount = selectedStep.columns;
      this._labelsOnTop = selectedStep.labelsPosition === "top";
    }
  }
  /** @private */
  _invokeUpdateLayout() {
    this._updateLayout();
  }
  /**
   * Update the layout.
   * @protected
   */
  _updateLayout() {
    if (isElementHidden(this)) {
      return;
    }
    const style = getComputedStyle(this);
    const columnSpacing = style.getPropertyValue("--vaadin-form-layout-column-spacing");
    const direction = style.direction;
    const marginStartProp = `margin-${direction === "ltr" ? "left" : "right"}`;
    const marginEndProp = `margin-${direction === "ltr" ? "right" : "left"}`;
    const containerWidth = this.offsetWidth;
    let col = 0;
    Array.from(this.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
      if (child.localName === "br") {
        col = 0;
        return;
      }
      const attrColspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
      let colspan;
      colspan = this._naturalNumberOrOne(parseFloat(attrColspan));
      colspan = Math.min(colspan, this._columnCount);
      const childRatio = colspan / this._columnCount;
      child.style.width = `calc(${childRatio * 100}% - ${1 - childRatio} * ${columnSpacing})`;
      if (col + colspan > this._columnCount) {
        col = 0;
      }
      if (col === 0) {
        child.style.setProperty(marginStartProp, "0px");
      } else {
        child.style.removeProperty(marginStartProp);
      }
      const nextIndex = index + 1;
      const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
      if (col + colspan === this._columnCount) {
        child.style.setProperty(marginEndProp, "0px");
      } else if (nextLineBreak) {
        const colspanRatio = (this._columnCount - col - colspan) / this._columnCount;
        child.style.setProperty(
          marginEndProp,
          `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`
        );
      } else {
        child.style.removeProperty(marginEndProp);
      }
      col = (col + colspan) % this._columnCount;
      if (child.localName === "vaadin-form-item") {
        if (this._labelsOnTop) {
          if (child.getAttribute("label-position") !== "top") {
            child.__useLayoutLabelPosition = true;
            child.setAttribute("label-position", "top");
          }
        } else if (child.__useLayoutLabelPosition) {
          delete child.__useLayoutLabelPosition;
          child.removeAttribute("label-position");
        }
      }
    });
  }
  /**
   * @protected
   * @override
   */
  _onResize(contentRect) {
    if (contentRect.width === 0 && contentRect.height === 0) {
      this.$.layout.style.opacity = "0";
      return;
    }
    this._selectResponsiveStep();
    this._updateLayout();
    this.$.layout.style.opacity = "";
  }
};

// node_modules/@vaadin/form-layout/src/vaadin-form-layout.js
registerStyles("vaadin-form-layout", formLayoutStyles, { moduleId: "vaadin-form-layout-styles" });
var FormLayout = class extends FormLayoutMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-form-layout";
  }
  static get template() {
    return html`
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
  }
};
defineCustomElement(FormLayout);

export {
  FormLayout
};
/*! Bundled license information:

@vaadin/form-layout/src/vaadin-form-layout-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/form-layout/src/vaadin-form-layout.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-ICMFCL6B.js.map
