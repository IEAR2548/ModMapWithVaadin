import {
  ifDefined
} from "./chunk-GCEQFJ47.js";
import {
  ItemMixin
} from "./chunk-U4QG4FU7.js";
import {
  listBox
} from "./chunk-5I4IO4IE.js";
import {
  item
} from "./chunk-7CLLCVSM.js";
import {
  menuOverlayCore
} from "./chunk-GZUGITXY.js";
import {
  ListMixin
} from "./chunk-GMZYPYCE.js";
import {
  PositionMixin
} from "./chunk-B2HJJUI6.js";
import {
  OverlayClassMixin
} from "./chunk-UF5ES3VB.js";
import {
  overlay
} from "./chunk-U2M46WVE.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-K56GLCGU.js";
import {
  announce
} from "./chunk-TAIFBA4G.js";
import {
  I18nMixin
} from "./chunk-RSNLTS32.js";
import {
  afterNextRender
} from "./chunk-TH52KELX.js";
import {
  SlotController
} from "./chunk-FIRGGFKS.js";
import {
  ControllerMixin
} from "./chunk-QZAHM4JN.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-KEWLZU7R.js";
import {
  ResizeMixin
} from "./chunk-2OEODMLR.js";
import {
  ElementMixin
} from "./chunk-QN4QZSZG.js";
import {
  DirMixin
} from "./chunk-QBLL3FQM.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import {
  PolymerElement
} from "./chunk-YBEXGSZO.js";
import {
  html as html2
} from "./chunk-QO5P4LIH.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";
import {
  html,
  render
} from "./chunk-4QYCOPDF.js";

// node_modules/@vaadin/avatar-group/theme/lumo/vaadin-avatar-group-styles.js
registerStyles(
  "vaadin-avatar-group",
  css`
    :host {
      --vaadin-avatar-size: var(--lumo-size-m);
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-group-overlap: 12px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-group-overlap: 10px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-group-overlap: 6px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-group-overlap: 4px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
  { moduleId: "lumo-avatar-group" }
);
var avatarGroupOverlay = css`
  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles("vaadin-avatar-group-overlay", [overlay, menuOverlayCore, avatarGroupOverlay], {
  moduleId: "lumo-avatar-group-overlay"
});
registerStyles("vaadin-avatar-group-menu", listBox, { moduleId: "lumo-avatar-group-menu" });
registerStyles(
  "vaadin-avatar-group-menu-item",
  [
    item,
    css`
      :host {
        padding: var(--lumo-space-xs);
        padding-inline-end: var(--lumo-space-m);
      }

      [part='content'] {
        display: flex;
        align-items: center;
      }

      [part='content'] ::slotted(vaadin-avatar) {
        width: var(--lumo-size-xs);
        height: var(--lumo-size-xs);
        margin-inline-end: var(--lumo-space-s);
      }
    `
  ],
  { moduleId: "lumo-avatar-group-menu-item" }
);

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group-menu.js
var AvatarGroupMenu = class extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-avatar-group-menu";
  }
  static get template() {
    return html2`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
};
defineCustomElement(AvatarGroupMenu);

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group-menu-item.js
var AvatarGroupMenuItem = class extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-avatar-group-menu-item";
  }
  static get template() {
    return html2`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menuitem");
  }
};
defineCustomElement(AvatarGroupMenuItem);

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group-overlay.js
registerStyles("vaadin-avatar-group-overlay", [overlayStyles], {
  moduleId: "vaadin-avatar-group-overlay-styles"
});
var AvatarGroupOverlay = class extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-avatar-group-overlay";
  }
  static get template() {
    return html2`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
defineCustomElement(AvatarGroupOverlay);

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group-mixin.js
var MINIMUM_DISPLAYED_AVATARS = 2;
var DEFAULT_I18N = {
  anonymous: "anonymous",
  activeUsers: {
    one: "Currently one active user",
    many: "Currently {count} active users"
  },
  joined: "{user} joined",
  left: "{user} left"
};
var AvatarGroupMixin = (superClass) => class AvatarGroupMixinClass extends I18nMixin(DEFAULT_I18N, ResizeMixin(OverlayClassMixin(superClass))) {
  static get properties() {
    return {
      /**
       * An array containing the items which will be stamped as avatars.
       *
       * The items objects allow to configure [`name`](#/elements/vaadin-avatar#property-name),
       * [`abbr`](#/elements/vaadin-avatar#property-abbr), [`img`](#/elements/vaadin-avatar#property-img)
       * and [`colorIndex`](#/elements/vaadin-avatar#property-colorIndex) properties on the
       * stamped avatars, and set `className` to provide CSS class names.
       *
       * #### Example
       *
       * ```js
       * group.items = [
       *   {
       *     name: 'User name',
       *     img: 'url-to-image.png',
       *     className: 'even'
       *   },
       *   {
       *     abbr: 'JD',
       *     colorIndex: 1,
       *     className: 'odd'
       *   },
       * ];
       * ```
       *
       * @type {!Array<!AvatarGroupItem> | undefined}
       */
      items: {
        type: Array,
        observer: "__itemsChanged",
        sync: true
      },
      /**
       * The maximum number of avatars to display. By default, all the avatars are displayed.
       * When _maxItemsVisible_ is set, the overflowing avatars are grouped into one avatar with
       * a dropdown. Setting 0 or 1 has no effect so there are always at least two avatars visible.
       * @attr {number} max-items-visible
       */
      maxItemsVisible: {
        type: Number,
        sync: true
      },
      /** @private */
      _avatars: {
        type: Array,
        value: () => [],
        sync: true
      },
      /** @private */
      __itemsInView: {
        type: Number,
        value: null,
        sync: true
      },
      /** @private */
      _overflow: {
        type: Object,
        sync: true
      },
      /** @private */
      _overflowItems: {
        type: Array,
        observer: "__overflowItemsChanged",
        computed: "__computeOverflowItems(items, __itemsInView, maxItemsVisible)"
      },
      /** @private */
      _overflowTooltip: {
        type: Object,
        sync: true
      },
      /** @private */
      _opened: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__i18nItemsChanged(__effectiveI18n, items)",
      "__openedChanged(_opened, _overflow)",
      "__updateAvatarsTheme(_overflow, _avatars, _theme)",
      "__updateAvatars(items, __itemsInView, maxItemsVisible, _overflow, __effectiveI18n)",
      "__updateOverflowAvatar(_overflow, items, __itemsInView, maxItemsVisible)",
      "__updateOverflowTooltip(_overflowTooltip, items, __itemsInView, maxItemsVisible)"
    ];
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following JSON structure and default values:
   * ```
   * {
   *   // Translation of the anonymous user avatar tooltip.
   *   anonymous: 'anonymous',
   *   // Translation of the avatar group accessible label.
   *   // {count} is replaced with the actual count of users.
   *   activeUsers: {
   *     one: 'Currently one active user',
   *     many: 'Currently {count} active users'
   *   },
   *   // Screen reader announcement when user joins group.
   *   // {user} is replaced with the name or abbreviation.
   *   // When neither is set, "anonymous" is used instead.
   *   joined: '{user} joined',
   *   // Screen reader announcement when user leaves group.
   *   // {user} is replaced with the name or abbreviation.
   *   // When neither is set, "anonymous" is used instead.
   *   left: '{user} left'
   * }
   * ```
   * @return {!AvatarGroupI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  /** @protected */
  ready() {
    super.ready();
    this._overflowController = new SlotController(this, "overflow", "vaadin-avatar", {
      initializer: (overflow) => {
        overflow.setAttribute("role", "button");
        overflow.setAttribute("aria-haspopup", "menu");
        overflow.setAttribute("aria-expanded", "false");
        overflow.addEventListener("click", (e) => this._onOverflowClick(e));
        overflow.addEventListener("keydown", (e) => this._onOverflowKeyDown(e));
        const tooltip = document.createElement("vaadin-tooltip");
        tooltip.setAttribute("slot", "tooltip");
        overflow.appendChild(tooltip);
        this._overflow = overflow;
        this._overflowTooltip = tooltip;
      }
    });
    this.addController(this._overflowController);
    const overlay2 = this.$.overlay;
    overlay2.renderer = this.__overlayRenderer.bind(this);
    this._overlayElement = overlay2;
    afterNextRender(this, () => {
      this.__setItemsInView();
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._opened = false;
  }
  /** @private */
  __getMessage(user, action) {
    return action.replace("{user}", user.name || user.abbr || this.__effectiveI18n.anonymous);
  }
  /**
   * Renders items when they are provided by the `items` property and clears the content otherwise.
   * @param {!HTMLElement} root
   * @param {!Select} _select
   * @private
   */
  __overlayRenderer(root) {
    let menu = root.firstElementChild;
    if (!menu) {
      menu = document.createElement("vaadin-avatar-group-menu");
      menu.addEventListener("keydown", (event) => this._onListKeyDown(event));
      root.appendChild(menu);
    }
    menu.textContent = "";
    if (!this._overflowItems) {
      return;
    }
    this._overflowItems.forEach((item2) => {
      menu.appendChild(this.__createItemElement(item2));
    });
  }
  /** @private */
  __createItemElement(item2) {
    const itemElement = document.createElement("vaadin-avatar-group-menu-item");
    const avatar = document.createElement("vaadin-avatar");
    itemElement.appendChild(avatar);
    avatar.setAttribute("aria-hidden", "true");
    avatar.setAttribute("tabindex", "-1");
    avatar.i18n = this.__effectiveI18n;
    if (this._theme) {
      avatar.setAttribute("theme", this._theme);
    }
    avatar.name = item2.name;
    avatar.abbr = item2.abbr;
    avatar.img = item2.img;
    avatar.colorIndex = item2.colorIndex;
    if (item2.className) {
      avatar.className = item2.className;
    }
    if (item2.name) {
      const text = document.createTextNode(item2.name);
      itemElement.appendChild(text);
    }
    return itemElement;
  }
  /** @private */
  _onOverflowClick(e) {
    e.stopPropagation();
    if (this._opened) {
      this.$.overlay.close();
    } else if (!e.defaultPrevented) {
      this._opened = true;
    }
  }
  /** @private */
  _onOverflowKeyDown(e) {
    if (!this._opened) {
      if (/^(Enter|SpaceBar|\s)$/u.test(e.key)) {
        e.preventDefault();
        this._opened = true;
      }
    }
  }
  /** @private */
  _onListKeyDown(event) {
    if (event.key === "Escape" || event.key === "Tab") {
      this._opened = false;
    }
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this.__setItemsInView();
  }
  /** @private */
  _onVaadinOverlayClose(e) {
    if (e.detail.sourceEvent && e.detail.sourceEvent.composedPath().includes(this)) {
      e.preventDefault();
    }
  }
  /** @private */
  _onVaadinOverlayOpen() {
    if (this._menuElement) {
      this._menuElement.focus();
    }
  }
  /** @private */
  __renderAvatars(items) {
    render(
      html`
          ${items.map(
        (item2) => html`
              <vaadin-avatar
                .name="${item2.name}"
                .abbr="${item2.abbr}"
                .img="${item2.img}"
                .colorIndex="${item2.colorIndex}"
                .i18n="${this.__effectiveI18n}"
                class="${ifDefined(item2.className)}"
                with-tooltip
              ></vaadin-avatar>
            `
      )}
        `,
      this,
      { renderBefore: this._overflow }
    );
  }
  /** @private */
  __updateAvatars(items, itemsInView, maxItemsVisible, overflow) {
    if (!overflow || !Array.isArray(items)) {
      return;
    }
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    this.__renderAvatars(limit ? items.slice(0, limit) : items);
    this._avatars = [...this.querySelectorAll("vaadin-avatar")];
  }
  /** @private */
  __computeOverflowItems(items, itemsInView, maxItemsVisible) {
    const count = Array.isArray(items) ? items.length : 0;
    const limit = this.__getLimit(count, itemsInView, maxItemsVisible);
    return limit ? items.slice(limit) : [];
  }
  /** @private */
  __updateOverflowAvatar(overflow, items, itemsInView, maxItemsVisible) {
    if (overflow) {
      const count = Array.isArray(items) ? items.length : 0;
      const maxReached = maxItemsVisible != null && count > this.__getMax(maxItemsVisible);
      overflow.abbr = `+${count - this.__getLimit(count, itemsInView, maxItemsVisible)}`;
      overflow.toggleAttribute("hidden", !maxReached && !(itemsInView && itemsInView < count));
    }
  }
  /** @private */
  __updateAvatarsTheme(overflow, avatars, theme) {
    if (overflow) {
      [overflow, ...avatars].forEach((avatar) => {
        if (theme) {
          avatar.setAttribute("theme", theme);
        } else {
          avatar.removeAttribute("theme");
        }
      });
    }
  }
  /** @private */
  __updateOverflowTooltip(tooltip, items, itemsInView, maxItemsVisible) {
    if (!tooltip || !Array.isArray(items)) {
      return;
    }
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    if (limit == null) {
      return;
    }
    const result = [];
    for (let i = limit; i < items.length; i++) {
      const item2 = items[i];
      if (item2) {
        result.push(item2.name || item2.abbr || "anonymous");
      }
    }
    tooltip.text = result.join("\n");
  }
  /** @private */
  __getLimit(items, itemsInView, maxItemsVisible) {
    let limit = null;
    const adjustedMax = this.__getMax(maxItemsVisible);
    if (maxItemsVisible != null && adjustedMax < items) {
      limit = adjustedMax - 1;
    } else if (itemsInView && itemsInView < items) {
      limit = itemsInView;
    }
    return Math.min(limit, this.__calculateAvatarsFitWidth());
  }
  /** @private */
  __getMax(maxItemsVisible) {
    return Math.max(maxItemsVisible, MINIMUM_DISPLAYED_AVATARS);
  }
  /** @private */
  __itemsChanged(items, oldItems) {
    this.__setItemsInView();
    let added = [];
    let removed = [];
    const hasNewItems = Array.isArray(items);
    const hasOldItems = Array.isArray(oldItems);
    if (hasOldItems) {
      removed = oldItems.filter((item2) => hasNewItems && !items.includes(item2));
    }
    if (hasNewItems) {
      added = items.filter((item2) => hasOldItems && !oldItems.includes(item2));
    }
    this.__announceItemsChange(added, removed);
  }
  /** @private */
  __announceItemsChange(added, removed) {
    let addedMsg = [];
    let removedMsg = [];
    if (added) {
      addedMsg = added.map((user) => this.__getMessage(user, this.__effectiveI18n.joined || "{user} joined"));
    }
    if (removed) {
      removedMsg = removed.map((user) => this.__getMessage(user, this.__effectiveI18n.left || "{user} left"));
    }
    const messages = removedMsg.concat(addedMsg);
    if (messages.length > 0) {
      announce(messages.join(", "));
    }
  }
  /** @private */
  __i18nItemsChanged(effectiveI18n, items) {
    if (effectiveI18n && effectiveI18n.activeUsers) {
      const count = Array.isArray(items) ? items.length : 0;
      const field = count === 1 ? "one" : "many";
      if (effectiveI18n.activeUsers[field]) {
        this.setAttribute("aria-label", effectiveI18n.activeUsers[field].replace("{count}", count || 0));
      }
      this._avatars.forEach((avatar) => {
        avatar.i18n = effectiveI18n;
      });
    }
  }
  /** @private */
  __openedChanged(opened, overflow) {
    if (!overflow) {
      return;
    }
    if (opened) {
      if (!this._menuElement) {
        this._menuElement = this.$.overlay.querySelector("vaadin-avatar-group-menu");
      }
      this._openedWithFocusRing = overflow.hasAttribute("focus-ring");
    } else if (this.__oldOpened) {
      overflow.focus();
      if (this._openedWithFocusRing) {
        overflow.setAttribute("focus-ring", "");
      }
    }
    overflow.setAttribute("aria-expanded", opened === true);
    this.__oldOpened = opened;
  }
  /** @private */
  __overflowItemsChanged(items, oldItems) {
    if (items || oldItems) {
      this.$.overlay.requestContentUpdate();
    }
  }
  /** @private */
  __setItemsInView() {
    const avatars = this._avatars;
    const items = this.items;
    if (!items || !avatars || avatars.length < 3) {
      return;
    }
    let result = this.__calculateAvatarsFitWidth();
    if (result === items.length - 1) {
      result = items.length;
    }
    if (result >= items.length && this._opened) {
      this.$.overlay.close();
      this.$.overlay._flushAnimation("closing");
    }
    this.__itemsInView = result;
  }
  /** @private */
  __calculateAvatarsFitWidth() {
    if (!this.shadowRoot || this._avatars.length < MINIMUM_DISPLAYED_AVATARS) {
      return MINIMUM_DISPLAYED_AVATARS;
    }
    const avatars = this._avatars;
    const avatarWidth = avatars[0].clientWidth;
    const { marginLeft, marginRight } = getComputedStyle(avatars[1]);
    const offset = this.__isRTL ? parseInt(marginRight, 0) - parseInt(marginLeft, 0) : parseInt(marginLeft, 0) - parseInt(marginRight, 0);
    return Math.floor((this.$.container.offsetWidth - avatarWidth) / (avatarWidth + offset));
  }
};

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group-styles.js
var avatarGroupStyles = css`
  :host {
    display: block;
    width: 100%; /* prevent collapsing inside non-stretching column flex */
    --vaadin-avatar-group-overlap: 8px;
    --vaadin-avatar-group-overlap-border: 2px;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='container'] {
    display: flex;
    position: relative;
    width: 100%;
    flex-wrap: nowrap;
  }

  ::slotted(vaadin-avatar:not(:first-child)) {
    -webkit-mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
    mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
    -webkit-mask-size: calc(
      300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6
    );
    mask-size: calc(300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6);
  }

  ::slotted(vaadin-avatar:not([dir='rtl']):not(:first-child)) {
    margin-left: calc(var(--vaadin-avatar-group-overlap) * -1 - var(--vaadin-avatar-outline-width));
    -webkit-mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
    mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
  }

  ::slotted(vaadin-avatar[dir='rtl']:not(:first-child)) {
    margin-right: calc(var(--vaadin-avatar-group-overlap) * -1);
    -webkit-mask-position: calc(
      50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
    );
    mask-position: calc(
      50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
    );
  }
`;

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group.js
registerStyles("vaadin-avatar-group", avatarGroupStyles, { moduleId: "vaadin-avatar-group-styles" });
var AvatarGroup = class extends AvatarGroupMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html2`
      <div id="container" part="container">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>
      <vaadin-avatar-group-overlay
        id="overlay"
        opened="{{_opened}}"
        position-target="[[_overflow]]"
        no-vertical-overlap
        on-vaadin-overlay-close="_onVaadinOverlayClose"
        on-vaadin-overlay-open="_onVaadinOverlayOpen"
      ></vaadin-avatar-group-overlay>
    `;
  }
  static get is() {
    return "vaadin-avatar-group";
  }
};
defineCustomElement(AvatarGroup);

export {
  AvatarGroup
};
/*! Bundled license information:

@vaadin/avatar-group/src/vaadin-avatar-group-menu.js:
  (**
   * @license
   * Copyright (c) 2020 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/avatar-group/src/vaadin-avatar-group-menu-item.js:
  (**
   * @license
   * Copyright (c) 2020 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/avatar-group/src/vaadin-avatar-group-overlay.js:
  (**
   * @license
   * Copyright (c) 2020 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/avatar-group/src/vaadin-avatar-group-mixin.js:
  (**
   * @license
   * Copyright (c) 2020 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/avatar-group/src/vaadin-avatar-group-styles.js:
  (**
   * @license
   * Copyright (c) 2020 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/avatar-group/src/vaadin-avatar-group.js:
  (**
   * @license
   * Copyright (c) 2020 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-KOWYGBTA.js.map
