import {
  InputFieldMixin
} from "./chunk-4Z7GPLQJ.js";
import {
  inputFieldShared as inputFieldShared2
} from "./chunk-WGJN77FX.js";
import {
  inputFieldShared
} from "./chunk-HKTMLLWR.js";
import {
  LabelledInputController
} from "./chunk-RS5C4C66.js";
import {
  ResizeMixin
} from "./chunk-2OEODMLR.js";
import {
  TooltipController
} from "./chunk-JN3IROFX.js";
import {
  SlotController
} from "./chunk-FIRGGFKS.js";
import {
  ElementMixin
} from "./chunk-QN4QZSZG.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-KEWLZU7R.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import {
  PolymerElement
} from "./chunk-YBEXGSZO.js";
import {
  html
} from "./chunk-QO5P4LIH.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";

// node_modules/@vaadin/text-area/theme/lumo/vaadin-text-area-styles.js
var textArea = css`
  [part='input-field'],
  [part='input-field'] ::slotted(textarea) {
    height: auto;
    box-sizing: border-box;
    min-height: 0;
  }

  [part='input-field'] {
    /* Equal to the implicit padding in vaadin-text-field */
    padding-top: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    padding-bottom: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    transition: background-color 0.1s;
    line-height: var(--lumo-line-height-s);
  }

  :host(:not([readonly])) [part='input-field']::after {
    display: none;
  }

  :host([readonly]) [part='input-field'] {
    border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-30pct));
  }

  :host([readonly]) [part='input-field']::after {
    border: none;
  }

  :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
    background-color: var(--lumo-contrast-20pct);
  }

  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
      background-color: var(--lumo-contrast-10pct);
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field'] {
      background-color: var(--lumo-contrast-20pct);
    }
  }

  [part='input-field'] ::slotted(textarea) {
    line-height: inherit;
    --_lumo-text-field-overflow-mask-image: none;
  }

  /* Use sticky positioning to keep prefix/suffix/clear button visible when scrolling textarea container */
  [part='input-field'] ::slotted([slot$='fix']),
  [part='clear-button'] {
    position: sticky;
    top: 0;
    align-self: flex-start;
  }

  [part='input-field'] ::slotted(vaadin-icon[slot$='fix']),
  [part='clear-button'] {
    /* Vertically align icon prefix/suffix/clear button with the first line of text */
    top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
    margin-top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
    /* Reduce effective height to match line height of native textarea, so icons don't increase component size when using single row */
    margin-bottom: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
  }
`;
registerStyles("vaadin-text-area", [inputFieldShared, textArea], {
  moduleId: "lumo-text-area"
});

// node_modules/@vaadin/field-base/src/text-area-controller.js
var TextAreaController = class extends SlotController {
  constructor(host, callback) {
    super(host, "textarea", "textarea", {
      initializer: (node, host2) => {
        const value = host2.getAttribute("value");
        if (value) {
          node.value = value;
        }
        const name = host2.getAttribute("name");
        if (name) {
          node.setAttribute("name", name);
        }
        node.id = this.defaultId;
        if (typeof callback === "function") {
          callback(node);
        }
      },
      useUniqueId: true
    });
  }
};

// node_modules/@vaadin/text-area/src/vaadin-text-area-mixin.js
var TextAreaMixin = (superClass) => class TextAreaMixinClass extends ResizeMixin(InputFieldMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      },
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      },
      /**
       * Minimum number of rows to show. Default is two rows.
       *
       * When using a custom slotted textarea, the minimum number of rows are not applied for backwards compatibility.
       *
       * @attr {number} min-rows
       */
      minRows: {
        type: Number,
        value: 2,
        observer: "__minRowsChanged"
      },
      /**
       * Maximum number of rows to expand to before the text area starts scrolling. This effectively sets a max-height
       * on the `input-field` part. By default, it is not set, and the text area grows with the content without
       * constraints.
       * @attr {number} max-rows
       */
      maxRows: {
        type: Number
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength", "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength", "pattern"];
  }
  static get observers() {
    return ["__updateMinHeight(minRows, inputElement)", "__updateMaxHeight(maxRows, inputElement, _inputField)"];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @protected */
  _onScroll() {
    this.__scrollPositionUpdated();
  }
  /** @protected */
  ready() {
    super.ready();
    this.__textAreaController = new TextAreaController(this, (input) => {
      this._setInputElement(input);
      this._setFocusElement(input);
      this.stateTarget = input;
      this.ariaTarget = input;
    });
    this.addController(this.__textAreaController);
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._inputField = this.shadowRoot.querySelector("[part=input-field]");
    this._inputField.addEventListener("wheel", (e) => {
      const scrollTopBefore = this._inputField.scrollTop;
      this._inputField.scrollTop += e.deltaY;
      if (scrollTopBefore !== this._inputField.scrollTop) {
        e.preventDefault();
        this.__scrollPositionUpdated();
      }
    });
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @private */
  __scrollPositionUpdated() {
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", "0px");
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", `${this._inputField.scrollTop}px`);
  }
  /**
   * @param {unknown} newVal
   * @param {unknown} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    super._valueChanged(newVal, oldVal);
    this._updateHeight();
  }
  /** @private */
  _updateHeight() {
    const input = this.inputElement;
    const inputField = this._inputField;
    if (!input || !inputField) {
      return;
    }
    const scrollTop = inputField.scrollTop;
    const valueLength = this.value ? this.value.length : 0;
    if (this._oldValueLength >= valueLength) {
      const inputFieldHeight = getComputedStyle(inputField).height;
      const inputWidth = getComputedStyle(input).width;
      inputField.style.height = inputFieldHeight;
      input.style.maxWidth = inputWidth;
      input.style.alignSelf = "flex-start";
      input.style.height = "auto";
    }
    this._oldValueLength = valueLength;
    const inputHeight = input.scrollHeight;
    if (inputHeight > input.clientHeight) {
      input.style.height = `${inputHeight}px`;
    }
    input.style.removeProperty("max-width");
    input.style.removeProperty("align-self");
    inputField.style.removeProperty("height");
    inputField.scrollTop = scrollTop;
    this.__updateMaxHeight(this.maxRows);
  }
  /** @private */
  __updateMinHeight(minRows) {
    if (!this.inputElement) {
      return;
    }
    if (this.inputElement === this.__textAreaController.defaultNode) {
      this.inputElement.rows = Math.max(minRows, 1);
    }
  }
  /** @private */
  __updateMaxHeight(maxRows) {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    if (maxRows) {
      const inputStyle = getComputedStyle(this.inputElement);
      const inputFieldStyle = getComputedStyle(this._inputField);
      const lineHeight = parseFloat(inputStyle.lineHeight);
      const contentHeight = lineHeight * maxRows;
      const marginsAndPaddings = parseFloat(inputStyle.paddingTop) + parseFloat(inputStyle.paddingBottom) + parseFloat(inputStyle.marginTop) + parseFloat(inputStyle.marginBottom) + parseFloat(inputFieldStyle.paddingTop) + parseFloat(inputFieldStyle.paddingBottom);
      const maxHeight = Math.ceil(contentHeight + marginsAndPaddings);
      this._inputField.style.setProperty("max-height", `${maxHeight}px`);
    } else {
      this._inputField.style.removeProperty("max-height");
    }
  }
  /**
   * @private
   */
  __minRowsChanged(minRows) {
    if (minRows < 1) {
      console.warn("<vaadin-text-area> minRows must be at least 1.");
    }
  }
  /**
   * Scrolls the textarea to the start if it has a vertical scrollbar.
   */
  scrollToStart() {
    this._inputField.scrollTop = 0;
  }
  /**
   * Scrolls the textarea to the end if it has a vertical scrollbar.
   */
  scrollToEnd() {
    this._inputField.scrollTop = this._inputField.scrollHeight;
  }
  /**
   * Returns true if the current textarea value satisfies all constraints (if any).
   * @return {boolean}
   * @override
   */
  checkValidity() {
    if (!super.checkValidity()) {
      return false;
    }
    if (!this.pattern || !this.inputElement.value) {
      return true;
    }
    try {
      const match = this.inputElement.value.match(this.pattern);
      return match ? match[0] === match.input : false;
    } catch (_) {
      return true;
    }
  }
};

// node_modules/@vaadin/text-area/src/vaadin-text-area-styles.js
var textAreaStyles = css`
  .vaadin-text-area-container {
    flex: auto;
  }

  /* The label, helper text and the error message should neither grow nor shrink. */
  [part='label'],
  [part='helper-text'],
  [part='error-message'] {
    flex: none;
  }

  [part='input-field'] {
    flex: auto;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  ::slotted(textarea) {
    -webkit-appearance: none;
    -moz-appearance: none;
    flex: auto;
    overflow: hidden;
    width: 100%;
    height: 100%;
    outline: none;
    resize: none;
    margin: 0;
    padding: 0 0.25em;
    border: 0;
    border-radius: 0;
    min-width: 0;
    font: inherit;
    font-size: 1em;
    line-height: normal;
    color: inherit;
    background-color: transparent;
    /* Disable default invalid style in Firefox */
    box-shadow: none;
  }

  /* Override styles from <vaadin-input-container> */
  [part='input-field'] ::slotted(textarea) {
    align-self: stretch;
    white-space: pre-wrap;
    box-sizing: border-box;
  }

  [part='input-field'] ::slotted(:not(textarea)) {
    align-self: flex-start;
  }

  /* Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=1739079 */
  :host([disabled]) ::slotted(textarea) {
    user-select: none;
  }
`;

// node_modules/@vaadin/text-area/src/vaadin-text-area.js
registerStyles("vaadin-text-area", [inputFieldShared2, textAreaStyles], { moduleId: "vaadin-text-area-styles" });
var TextArea = class extends TextAreaMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-text-area";
  }
  static get template() {
    return html`
      <div class="vaadin-text-area-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
          on-scroll="_onScroll"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="textarea"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
};
defineCustomElement(TextArea);

export {
  TextArea
};
/*! Bundled license information:

@vaadin/text-area/theme/lumo/vaadin-text-area-styles.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/field-base/src/text-area-controller.js:
  (**
   * @license
   * Copyright (c) 2021 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/text-area/src/vaadin-text-area-mixin.js:
  (**
   * @license
   * Copyright (c) 2021 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/text-area/src/vaadin-text-area-styles.js:
  (**
   * @license
   * Copyright (c) 2021 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/text-area/src/vaadin-text-area.js:
  (**
   * @license
   * Copyright (c) 2021 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/text-area/theme/lumo/vaadin-text-area.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-EQ4UM4TD.js.map
