import "./chunk-BF7H2OG5.js";
import {
  Grid
} from "./chunk-S5OL7CUI.js";
import "./chunk-L6EXTAJV.js";
import "./chunk-UKE2NCRQ.js";
import "./chunk-AM4UAMDV.js";
import {
  iterateRowCells,
  updatePart
} from "./chunk-5ACR4KM5.js";
import "./chunk-ZF3D4CMN.js";
import "./chunk-EGYRAZTZ.js";
import "./chunk-KDMU7KRZ.js";
import "./chunk-F7QS6G5O.js";
import "./chunk-3U65M3F2.js";
import {
  get,
  set
} from "./chunk-U4OQEY5H.js";
import "./chunk-GMZYPYCE.js";
import "./chunk-TAIFBA4G.js";
import "./chunk-2OEODMLR.js";
import "./chunk-FFK3QFYP.js";
import "./chunk-ZFTJKNOJ.js";
import "./chunk-6UYCWOWN.js";
import "./chunk-IMJTZNS3.js";
import "./chunk-TNTYFQYJ.js";
import "./chunk-KMJME6UN.js";
import "./chunk-HTUMVTZR.js";
import "./chunk-CU6AK3MF.js";
import "./chunk-DMZMFF2U.js";
import "./chunk-JN3IROFX.js";
import "./chunk-FIRGGFKS.js";
import "./chunk-4SWSK3CD.js";
import "./chunk-HXO5X6HG.js";
import "./chunk-7TDF2HKG.js";
import "./chunk-CCS6CDM7.js";
import "./chunk-WOH7SGKZ.js";
import "./chunk-XINNUJWD.js";
import "./chunk-VNRF6E57.js";
import "./chunk-MY27H5BQ.js";
import "./chunk-QN4QZSZG.js";
import {
  Debouncer
} from "./chunk-RQAC3AN6.js";
import "./chunk-QZAHM4JN.js";
import "./chunk-E33ETZLW.js";
import "./chunk-CXDC5LNX.js";
import "./chunk-ARCEVOS6.js";
import "./chunk-JOZKWWH6.js";
import "./chunk-BJXKYFZQ.js";
import "./chunk-JJ5PH6RA.js";
import "./chunk-3DUAHG2W.js";
import {
  registerStyles
} from "./chunk-KEWLZU7R.js";
import "./chunk-QBLL3FQM.js";
import {
  animationFrame
} from "./chunk-MTSXO4VS.js";
import {
  defineCustomElement
} from "./chunk-AQ7DMXX6.js";
import "./chunk-YBEXGSZO.js";
import "./chunk-MMSAJ3TN.js";
import "./chunk-KYHIEJIL.js";
import "./chunk-NZOAG24Y.js";
import "./chunk-QO5P4LIH.js";
import "./chunk-KV4N6HS4.js";
import "./chunk-3URU5I64.js";
import "./chunk-2VJ6XAW7.js";
import {
  css
} from "./chunk-WFI4KZJ4.js";
import "./chunk-4QYCOPDF.js";
import "./chunk-DWA4UIM3.js";

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-styles.js
registerStyles(
  "vaadin-grid-pro",
  css`
    :host([navigating]) [part~='cell']:active::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part~='editable-cell'],
    [part~='editable-cell'] ::slotted(vaadin-grid-cell-content) {
      cursor: var(--lumo-clickable-cursor);
    }

    [part~='editable-cell']:hover,
    [part~='editable-cell']:focus {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    }

    /* Indicate editable cells */

    :host([theme~='highlight-editable-cells']) [part~='editable-cell'] {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    }

    :host([theme~='highlight-editable-cells']) [part~='editable-cell']:hover,
    :host([theme~='highlight-editable-cells']) [part~='editable-cell']:focus {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-10pct), var(--lumo-contrast-10pct));
    }

    /* Indicate read-only cells */

    /* prettier-ignore */
    :host([theme~='highlight-read-only-cells']) [tabindex]:not([part~='editable-cell']):not([part~='header-cell']):not([part~='footer-cell']) {
      background-image: repeating-linear-gradient(
        135deg,
        transparent,
        transparent 6px,
        var(--lumo-contrast-5pct) 6px,
        var(--lumo-contrast-5pct) 14px
      );
    }

    /* Loading editor cell styles are used by Flow GridPro */
    :host([loading-editor]) [part~='focused-cell']::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
      animation: vaadin-grid-pro-loading-editor 1.4s infinite;
      opacity: 0;
    }

    @keyframes vaadin-grid-pro-loading-editor {
      50% {
        opacity: 1;
      }
    }

    [part~='updating-cell']::after {
      content: '';
      position: absolute;
      inset: var(--_cell-padding);
      margin: var(--_focus-ring-width);
      border-radius: 4px;
      background-size: max(4em, 50%);
      background-repeat: no-repeat;
      background-position: min(-200%, -4em) 0;
      background-image: linear-gradient(90deg, transparent, var(--lumo-contrast-10pct), transparent);
      animation: vaadin-grid-pro-updating-cell 1.3s ease-out infinite;
    }

    @keyframes vaadin-grid-pro-updating-cell {
      100% {
        background-position: max(300%, 8em) 0;
      }
    }
  `,
  { moduleId: "lumo-grid-pro" }
);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-inline-editing-mixin.js
registerStyles(
  "vaadin-grid-pro",
  css`
    :host([loading-editor]) [part~='focused-cell'] ::slotted(vaadin-grid-cell-content),
    [part~='updating-cell'] ::slotted(vaadin-grid-cell-content) {
      opacity: 0;
      pointer-events: none;
    }
  `,
  {
    moduleId: "vaadin-grid-pro-styles"
  }
);
var InlineEditingMixin = (superClass) => class InlineEditingMixin extends superClass {
  static get properties() {
    return {
      /**
       * When true, pressing Enter while in cell edit mode
       * will move focus to the editable cell in the next row
       * (Shift + Enter - same, but for previous row).
       * @attr {boolean} enter-next-row
       */
      enterNextRow: {
        type: Boolean,
        notify: true
        // FIXME(yuriy-fix): needed by Flow counterpart
      },
      /**
       * When true, after moving to next or previous editable cell using
       * Tab / Shift+Tab, it will be focused without edit mode.
       *
       * When `enterNextRow` is true, pressing Enter will also
       * preserve edit mode, otherwise, it will have no effect.
       * @attr {boolean} single-cell-edit
       */
      singleCellEdit: {
        type: Boolean,
        notify: true
        // FIXME(yuriy-fix): needed by Flow counterpart
      },
      /**
       * When true, the grid enters cell edit mode on a single click
       * instead of the default double click.
       * @attr {boolean} edit-on-click
       */
      editOnClick: {
        type: Boolean
      },
      /** @private */
      _editingDisabled: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__boundItemPropertyChanged = this._onItemPropertyChanged.bind(this);
    this.__boundEditorFocusOut = this._onEditorFocusOut.bind(this);
    this.__boundEditorFocusIn = this._onEditorFocusIn.bind(this);
    this._addEditColumnListener("mousedown", (e) => {
      e.stopImmediatePropagation();
      this.toggleAttribute("navigating", true);
    });
    this._addEditColumnListener("focusout", (e) => {
      e.stopImmediatePropagation();
    });
  }
  /** @protected */
  ready() {
    this.addEventListener(
      "keydown",
      (e) => {
        if (this.hasAttribute("loading-editor") && !["Tab", "Escape", "Enter"].includes(e.key)) {
          e.preventDefault();
          e.stopPropagation();
        }
      },
      true
    );
    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case 27:
          if (this.__edited) {
            this._stopEdit(true);
          }
          break;
        case 9:
          if (this.__edited) {
            this._switchEditCell(e);
          }
          break;
        case 13:
          if (this.__edited) {
            this._switchEditCell(e);
          } else {
            this._enterEditFromEvent(e);
          }
          break;
        case 32:
          if (!this.__edited) {
            this._enterEditFromEvent(e);
          }
          break;
        default:
          if (e.key && e.key.length === 1) {
            this._enterEditFromEvent(e, "text");
          }
          break;
      }
    });
    super.ready();
    this.$.table.addEventListener("click", (e) => {
      const column = this.getEventContext(e).column;
      if (column && this._isEditColumn(column)) {
        if (this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      }
    });
    if (this._ios) {
      let firstClickTime;
      let waitingSecondClick = false;
      this.addEventListener("click", (e) => {
        if (!waitingSecondClick) {
          firstClickTime = (/* @__PURE__ */ new Date()).getTime();
          waitingSecondClick = true;
          setTimeout(() => {
            waitingSecondClick = false;
          }, 300);
        } else {
          waitingSecondClick = false;
          const time = (/* @__PURE__ */ new Date()).getTime();
          if (time - firstClickTime < 300) {
            this._enterEditFromEvent(e);
          }
        }
      });
    } else {
      this.addEventListener("dblclick", (e) => {
        if (!this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      });
    }
  }
  /**
   * Prevents making an edit column cell's parent row active on click.
   *
   * @override
   * @protected
   */
  _shouldPreventCellActivationOnClick(e) {
    return super._shouldPreventCellActivationOnClick(e) || // The clicked cell is editable
    this._isEditColumn(this.getEventContext(e).column);
  }
  /**
   * Override an observer from `DisabledMixin` to stop
   * editing when grid element becomes disabled.
   *
   * @param {boolean} disabled
   * @param {boolean} oldDisabled
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled && this.__edited) {
      this._stopEdit(true);
    }
  }
  /** @protected */
  _checkImports() {
    super._checkImports();
    ["vaadin-grid-pro-edit-column"].forEach((elementName) => {
      const element = this.querySelector(elementName);
      if (element && !customElements.get(elementName)) {
        console.warn(`Make sure you have imported the required module for <${elementName}> element.`);
      }
    });
  }
  /** @private */
  _applyEdit({ path, value, item }) {
    set(path, value, item);
    this.requestContentUpdate();
  }
  /** @private */
  _addEditColumnListener(type, callback) {
    this.addEventListener(type, (e) => {
      const context = this.getEventContext(e);
      const column = context.column;
      const edited = this.__edited;
      if (context.item && this._isEditColumn(column)) {
        const { cell } = this._getGridEventLocation(e);
        if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
          return;
        }
        if (edited && edited.cell === cell) {
          return;
        }
        if (!this._isCellEditable(cell)) {
          return;
        }
        callback(e);
      }
    });
  }
  /** @private */
  _onItemPropertyChanged(e) {
    if (!e.defaultPrevented) {
      this._applyEdit(e.detail);
    }
  }
  /** @private */
  _getRowByIndex(index) {
    return Array.from(this.$.items.children).find((el) => el.index === index);
  }
  /** @private */
  _isEditColumn(column) {
    return column && column.localName.toLowerCase() === "vaadin-grid-pro-edit-column";
  }
  /** @private */
  _getEditColumns() {
    const columnTreeLevel = this._columnTree.length - 1;
    return this._columnTree[columnTreeLevel].filter((column) => this._isEditColumn(column) && !column.hidden).sort((a, b) => a._order - b._order);
  }
  /** @private */
  _cancelStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.cancel();
      delete this._debouncerStopEdit;
    }
  }
  /** @private */
  _flushStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.flush();
      delete this._debouncerStopEdit;
    }
  }
  /** @private */
  _enterEditFromEvent(e, type) {
    const context = this.getEventContext(e);
    const column = context.column;
    const edited = this.__edited;
    if (context.item && this._isEditColumn(column)) {
      const { cell } = this._getGridEventLocation(e);
      if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
        return;
      }
      if (type && column.editorType !== type) {
        return;
      }
      if (edited && edited.cell === cell && column._getEditorComponent(cell).contains(e.target)) {
        return;
      }
      this._flushStopEdit();
      this._startEdit(cell, column);
    } else if (edited) {
      this._stopEdit();
    }
  }
  /** @private */
  _onEditorFocusOut(event) {
    if (this.__shouldIgnoreFocusOut(event)) {
      return;
    }
    this._debouncerStopEdit = Debouncer.debounce(this._debouncerStopEdit, animationFrame, this._stopEdit.bind(this));
  }
  /** @private */
  __shouldIgnoreFocusOut(event) {
    const edited = this.__edited;
    if (edited) {
      const { cell, column } = this.__edited;
      const editor = column._getEditorComponent(cell);
      const path = event.composedPath();
      const nodes = path.slice(0, path.indexOf(editor) + 1).filter((node) => node.nodeType === Node.ELEMENT_NODE);
      if (nodes.some((el) => typeof el._shouldRemoveFocus === "function" && !el._shouldRemoveFocus(event))) {
        return true;
      }
    }
  }
  /** @private */
  _onEditorFocusIn() {
    this._cancelStopEdit();
  }
  /** @private */
  _startEdit(cell, column) {
    const isCellEditable = this._isCellEditable(cell);
    if (this.disabled || this._editingDisabled || !isCellEditable) {
      return;
    }
    this._cancelStopEdit();
    this._scrollHorizontallyToCell(cell);
    const model = this.__getRowModel(cell.parentElement);
    this.__edited = { cell, column, model };
    column._startCellEdit(cell, model);
    this.dispatchEvent(
      new CustomEvent("cell-edit-started", {
        detail: {
          index: model.index,
          item: model.item,
          path: column.path
        },
        composed: true
      })
    );
    this.addEventListener("item-property-changed", this.__boundItemPropertyChanged);
  }
  /**
   * @param {boolean=} shouldCancel
   * @param {boolean=} shouldRestoreFocus
   * @protected
   */
  _stopEdit(shouldCancel, shouldRestoreFocus) {
    if (!this.__edited) {
      return;
    }
    const { cell, column, model } = this.__edited;
    if (!shouldCancel && !this.hasAttribute("loading-editor")) {
      const editor = column._getEditorComponent(cell);
      if (editor) {
        const value = column._getEditorValue(editor);
        if (value !== get(column.path, model.item)) {
          editor.blur();
          this.dispatchEvent(
            new CustomEvent("item-property-changed", {
              detail: {
                index: model.index,
                item: model.item,
                path: column.path,
                value
              },
              bubbles: true,
              cancelable: true,
              composed: true
            })
          );
        }
      }
    }
    column._stopCellEdit(cell, model);
    this.__edited = null;
    this.removeEventListener("item-property-changed", this.__boundItemPropertyChanged);
    if (shouldRestoreFocus) {
      cell.focus();
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  async _switchEditCell(e) {
    if (e.defaultPrevented && e.keyCode === 9) {
      return;
    }
    this._cancelStopEdit();
    const editableColumns = this._getEditColumns();
    const { cell, column, model } = this.__edited;
    e.stopImmediatePropagation();
    const editor = column._getEditorComponent(cell);
    if (e.key === "Tab" && editor && editor.contains(e.target)) {
      const ignore = await new Promise((resolve) => {
        editor.addEventListener(
          "focusout",
          (event) => {
            resolve(this.__shouldIgnoreFocusOut(event));
          },
          { once: true }
        );
      });
      if (ignore) {
        return;
      }
    } else {
      e.preventDefault();
    }
    this._stopEdit();
    let nextIndex = model.index;
    let nextColumn = column;
    let nextCell = cell;
    let directionX = 0;
    let directionY = 0;
    if (e.keyCode === 13 && this.enterNextRow) {
      directionY = e.shiftKey ? -1 : 1;
    }
    if (e.keyCode === 9) {
      directionX = e.shiftKey ? -1 : 1;
    }
    if (directionX || directionY) {
      while (nextCell) {
        if (directionX) {
          nextColumn = editableColumns[editableColumns.indexOf(nextColumn) + directionX];
          if (!nextColumn) {
            nextIndex += directionX;
            nextColumn = editableColumns[directionX > 0 ? 0 : editableColumns.length - 1];
          }
        }
        if (directionY) {
          nextIndex += directionY;
        }
        const nextRow = this._getRowByIndex(nextIndex);
        nextCell = nextRow && Array.from(nextRow.children).find((cell2) => cell2._column === nextColumn);
        if (nextCell && this._isCellEditable(nextCell)) {
          break;
        }
      }
    }
    if (!nextCell) {
      nextCell = cell;
      nextIndex = model.index;
    }
    if (!this.singleCellEdit && nextCell !== cell) {
      this._startEdit(nextCell, nextColumn);
    } else {
      this.__ensureFlatIndexInViewport(nextIndex);
      nextCell.focus();
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {GridItem} item
   * @protected
   */
  _updateItem(row, item) {
    if (this.__edited) {
      const { cell, model } = this.__edited;
      if (cell.parentNode === row && model.item !== item) {
        this._stopEdit();
      }
    }
    super._updateItem(row, item);
  }
  /**
   * Override method from `StylingMixin` to apply `editable-cell` part to the
   * cells of edit columns.
   *
   * @override
   */
  _generateCellPartNames(row, model) {
    super._generateCellPartNames(row, model);
    iterateRowCells(row, (cell) => {
      const isEditable = !row.hasAttribute("loading") && this._isCellEditable(cell);
      const target = cell._focusButton || cell;
      updatePart(target, isEditable, "editable-cell");
    });
  }
  /** @private */
  _isCellEditable(cell) {
    const column = cell._column;
    if (!this._isEditColumn(column)) {
      return false;
    }
    if (!column.isCellEditable) {
      return true;
    }
    const model = this.__getRowModel(cell.parentElement);
    const isEditable = column.isCellEditable(model);
    if (this.__edited && this.__edited.cell === cell && !isEditable) {
      this._stopEdit(true, true);
    }
    return isEditable;
  }
  /**
   * Fired before exiting the cell edit mode, if the value has been changed.
   * If the default is prevented, value change would not be applied.
   *
   * @event item-property-changed
   * @param {Object} detail
   * @param {Object} detail.index the row index of the edited cell
   * @param {Object} detail.item the grid item rendered to the row of the edited cell
   * @param {Object} detail.path the column path of the edited cell
   * @param {Object} detail.value the new value of the edited cell
   */
  /**
   * Fired when the user starts editing a grid cell.
   *
   * @event cell-edit-started
   * @param {Object} detail
   * @param {Object} detail.index the row index of the edited cell
   * @param {Object} detail.item the grid item rendered to the row of the edited cell
   * @param {Object} detail.path the column path of the edited cell
   */
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro.js
var GridPro = class extends InlineEditingMixin(Grid) {
  static get is() {
    return "vaadin-grid-pro";
  }
  static get cvdlName() {
    return "vaadin-grid-pro";
  }
};
defineCustomElement(GridPro);
/*! Bundled license information:

@vaadin/grid-pro/src/vaadin-grid-pro-inline-editing-mixin.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro.js:
  (**
   * @license
   * Copyright (c) 2000 - 2025 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)
*/
//# sourceMappingURL=@vaadin_grid-pro_theme_lumo_vaadin-grid-pro__js.js.map
