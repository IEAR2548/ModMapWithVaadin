import {
  PositionMixin
} from "./chunk-B2HJJUI6.js";
import {
  OverlayMixin
} from "./chunk-T243RQF2.js";
import {
  setNestedOverlay
} from "./chunk-NPC7FAUI.js";
import {
  Debouncer
} from "./chunk-RQAC3AN6.js";
import {
  microTask
} from "./chunk-MTSXO4VS.js";

// node_modules/@vaadin/popover/src/vaadin-popover-position-mixin.js
var PopoverPositionMixin = (superClass) => class PopoverPositionMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * Position of the overlay with respect to the target.
       * Supported values: `top-start`, `top`, `top-end`,
       * `bottom-start`, `bottom`, `bottom-end`, `start-top`,
       * `start`, `start-bottom`, `end-top`, `end`, `end-bottom`.
       */
      position: {
        type: String
      },
      /**
       * Default value used when `position` property is not set.
       * @protected
       */
      _position: {
        type: String,
        value: "bottom"
      },
      /** @private */
      __effectivePosition: {
        type: String,
        computed: "__computePosition(position, _position)"
      }
    };
  }
  /** @protected */
  __computeHorizontalAlign(position) {
    return ["top-end", "bottom-end", "start-top", "start", "start-bottom"].includes(position) ? "end" : "start";
  }
  /** @protected */
  __computeNoHorizontalOverlap(position) {
    return ["start-top", "start", "start-bottom", "end-top", "end", "end-bottom"].includes(position);
  }
  /** @protected */
  __computeNoVerticalOverlap(position) {
    return ["top-start", "top-end", "top", "bottom-start", "bottom", "bottom-end"].includes(position);
  }
  /** @protected */
  __computeVerticalAlign(position) {
    return ["top-start", "top-end", "top", "start-bottom", "end-bottom"].includes(position) ? "bottom" : "top";
  }
  /** @private */
  __computePosition(position, defaultPosition) {
    return position || defaultPosition;
  }
};

// node_modules/@vaadin/popover/src/vaadin-popover-target-mixin.js
var PopoverTargetMixin = (superClass) => class PopoverTargetMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * The id of the element to be used as `target` value.
       * The element should be in the DOM by the time when
       * the attribute is set, otherwise a warning is shown.
       */
      for: {
        type: String,
        observer: "__forChanged"
      },
      /**
       * Reference to the DOM element used both to trigger the overlay
       * by user interaction and to visually position it on the screen.
       *
       * Defaults to an element referenced with `for` attribute, in
       * which case it must be located in the same shadow scope.
       */
      target: {
        type: Object
      },
      /** @private */
      __isConnected: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__targetOrConnectedChanged(target, __isConnected)"];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__isConnected = true;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isConnected = false;
  }
  /** @private */
  __forChanged(forId) {
    if (forId) {
      this.__setTargetByIdDebouncer = Debouncer.debounce(
        this.__setTargetByIdDebouncer,
        microTask,
        () => this.__setTargetById(forId)
      );
    }
  }
  /** @private */
  __setTargetById(targetId) {
    if (!this.isConnected) {
      return;
    }
    const target = this.getRootNode().getElementById(targetId);
    if (target) {
      this.target = target;
    } else {
      console.warn(`No element with id="${targetId}" set via "for" property found on the page.`);
    }
  }
  /** @private */
  __targetOrConnectedChanged(target, isConnected) {
    if (this.__previousTarget && (this.__previousTarget !== target || !isConnected)) {
      this._removeTargetListeners(this.__previousTarget);
    }
    if (target && isConnected) {
      this._addTargetListeners(target);
    }
    this.__previousTarget = target;
  }
  /**
   * @param {HTMLElement} _target
   * @protected
   */
  _addTargetListeners(_target) {
  }
  /**
   * @param {HTMLElement} _target
   * @protected
   */
  _removeTargetListeners(_target) {
  }
};

// node_modules/@vaadin/popover/src/vaadin-popover-overlay-mixin.js
var getClosestOverlay = (node) => {
  let n = node;
  while (n && n !== node.ownerDocument) {
    n = n.parentNode || n.host;
    if (n && n._hasOverlayStackMixin) {
      return n;
    }
  }
  return null;
};
var PopoverOverlayMixin = (superClass) => class PopoverOverlayMixinClass extends PositionMixin(OverlayMixin(superClass)) {
  static get properties() {
    return {
      position: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__openedOrTargetChanged(opened, positionTarget)"];
  }
  /**
   * Tag name prefix used by custom properties.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-popover";
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.positionTarget && this.owner) {
      const style = getComputedStyle(this.owner);
      ["top", "bottom", "start", "end"].forEach((prop) => {
        this.style.setProperty(
          `--${this._tagNamePrefix}-offset-${prop}`,
          style.getPropertyValue(`--${this._tagNamePrefix}-offset-${prop}`)
        );
      });
    }
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (!this.positionTarget || !this.opened) {
      return;
    }
    this.removeAttribute("arrow-centered");
    if (this.position === "bottom" || this.position === "top") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.width / 2 - overlayRect.width / 2;
      if (this.style.left) {
        const left = overlayRect.left + offset;
        if (left > 0) {
          this.style.left = `${left}px`;
          this.setAttribute("arrow-centered", "");
        }
      }
      if (this.style.right) {
        const right = parseFloat(this.style.right) + offset;
        if (right > 0) {
          this.style.right = `${right}px`;
          this.setAttribute("arrow-centered", "");
        }
      }
    }
    if (this.position === "start" || this.position === "end") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.height / 2 - overlayRect.height / 2;
      this.style.top = `${overlayRect.top + offset}px`;
    }
  }
  /** @private */
  __openedOrTargetChanged(opened, target) {
    if (target) {
      const parent = getClosestOverlay(target);
      if (parent) {
        setNestedOverlay(parent, opened ? this : null);
      }
    }
  }
};

export {
  PopoverOverlayMixin,
  PopoverPositionMixin,
  PopoverTargetMixin
};
/*! Bundled license information:

@vaadin/popover/src/vaadin-popover-position-mixin.js:
  (**
   * @license
   * Copyright (c) 2024 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/popover/src/vaadin-popover-target-mixin.js:
  (**
   * @license
   * Copyright (c) 2024 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/popover/src/vaadin-popover-overlay-mixin.js:
  (**
   * @license
   * Copyright (c) 2022 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-JGPS5AJO.js.map
