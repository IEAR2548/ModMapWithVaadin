{
  "version": 3,
  "sources": ["../../@vaadin/overlay/src/vaadin-overlay-stack-mixin.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\n\r\n/**\r\n * Returns all attached overlays in visual stacking order.\r\n * @private\r\n */\r\nconst getAttachedInstances = () =>\r\n  Array.from(document.body.children)\r\n    .filter((el) => el instanceof HTMLElement && el._hasOverlayStackMixin && !el.hasAttribute('closing'))\r\n    .sort((a, b) => a.__zIndex - b.__zIndex || 0);\r\n\r\n/**\r\n * Returns all attached overlay instances excluding notification container,\r\n * which only needs to be in the stack for zIndex but not pointer-events.\r\n * @private\r\n */\r\nconst getOverlayInstances = () => getAttachedInstances().filter((el) => el.$.overlay);\r\n\r\n/**\r\n * Returns true if the overlay is the last one in the opened overlays stack.\r\n * @param {HTMLElement} overlay\r\n * @return {boolean}\r\n * @protected\r\n */\r\nexport const isLastOverlay = (overlay) => overlay === getOverlayInstances().pop();\r\n\r\nconst overlayMap = new WeakMap();\r\n\r\n/**\r\n * Stores the reference to the nested overlay for given parent,\r\n * or removes it when the nested overlay is null.\r\n * @param {HTMLElement} parent\r\n * @param {HTMLElement} nested\r\n * @protected\r\n */\r\nexport const setNestedOverlay = (parent, nested) => {\r\n  if (nested != null) {\r\n    overlayMap.set(parent, nested);\r\n  } else {\r\n    overlayMap.delete(parent);\r\n  }\r\n};\r\n\r\n/**\r\n * @polymerMixin\r\n */\r\nexport const OverlayStackMixin = (superClass) =>\r\n  class OverlayStackMixin extends superClass {\r\n    constructor() {\r\n      super();\r\n\r\n      this._hasOverlayStackMixin = true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this is the last one in the opened overlays stack.\r\n     *\r\n     * @return {boolean}\r\n     * @protected\r\n     */\r\n    get _last() {\r\n      return isLastOverlay(this);\r\n    }\r\n\r\n    /**\r\n     * Brings the overlay as visually the frontmost one.\r\n     */\r\n    bringToFront() {\r\n      let zIndex = '';\r\n      const frontmost = getAttachedInstances()\r\n        .filter((o) => o !== this)\r\n        .pop();\r\n      if (frontmost) {\r\n        const frontmostZIndex = frontmost.__zIndex;\r\n        zIndex = frontmostZIndex + 1;\r\n      }\r\n      this.style.zIndex = zIndex;\r\n      this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);\r\n\r\n      // If there is a nested overlay, call `bringToFront()` for it as well.\r\n      if (overlayMap.has(this)) {\r\n        overlayMap.get(this).bringToFront();\r\n      }\r\n    }\r\n\r\n    /** @protected */\r\n    _enterModalState() {\r\n      if (document.body.style.pointerEvents !== 'none') {\r\n        // Set body pointer-events to 'none' to disable mouse interactions with\r\n        // other document nodes.\r\n        this._previousDocumentPointerEvents = document.body.style.pointerEvents;\r\n        document.body.style.pointerEvents = 'none';\r\n      }\r\n\r\n      // Disable pointer events in other attached overlays\r\n      getOverlayInstances().forEach((el) => {\r\n        if (el !== this) {\r\n          el.$.overlay.style.pointerEvents = 'none';\r\n        }\r\n      });\r\n    }\r\n\r\n    /** @protected */\r\n    _exitModalState() {\r\n      if (this._previousDocumentPointerEvents !== undefined) {\r\n        // Restore body pointer-events\r\n        document.body.style.pointerEvents = this._previousDocumentPointerEvents;\r\n        delete this._previousDocumentPointerEvents;\r\n      }\r\n\r\n      // Restore pointer events in the previous overlay(s)\r\n      const instances = getOverlayInstances();\r\n\r\n      let el;\r\n      // Use instances.pop() to ensure the reverse order\r\n      while ((el = instances.pop())) {\r\n        if (el === this) {\r\n          // Skip the current instance\r\n          continue;\r\n        }\r\n        el.$.overlay.style.removeProperty('pointer-events');\r\n        if (!el.modeless) {\r\n          // Stop after the last modal\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  };\r\n"],
  "mappings": ";AAUA,IAAM,uBAAuB,MAC3B,MAAM,KAAK,SAAS,KAAK,QAAQ,EAC9B,OAAO,CAAC,OAAO,cAAc,eAAe,GAAG,yBAAyB,CAAC,GAAG,aAAa,SAAS,CAAC,EACnG,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,YAAY,CAAC;AAOhD,IAAM,sBAAsB,MAAM,qBAAqB,EAAE,OAAO,CAAC,OAAO,GAAG,EAAE,OAAO;AAQ7E,IAAM,gBAAgB,CAAC,YAAY,YAAY,oBAAoB,EAAE,IAAI;AAEhF,IAAM,aAAa,oBAAI,QAAQ;AASxB,IAAM,mBAAmB,CAAC,QAAQ,WAAW;AAClD,MAAI,UAAU,MAAM;AAClB,eAAW,IAAI,QAAQ,MAAM;AAAA,EAC/B,OAAO;AACL,eAAW,OAAO,MAAM;AAAA,EAC1B;AACF;AAKO,IAAM,oBAAoB,CAAC,eAChC,MAAM,0BAA0B,WAAW;AAAA,EACzC,cAAc;AACZ,UAAM;AAEN,SAAK,wBAAwB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,QAAQ;AACV,WAAO,cAAc,IAAI;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe;AACb,QAAI,SAAS;AACb,UAAM,YAAY,qBAAqB,EACpC,OAAO,CAAC,MAAM,MAAM,IAAI,EACxB,IAAI;AACP,QAAI,WAAW;AACb,YAAM,kBAAkB,UAAU;AAClC,eAAS,kBAAkB;AAAA,IAC7B;AACA,SAAK,MAAM,SAAS;AACpB,SAAK,WAAW,UAAU,WAAW,iBAAiB,IAAI,EAAE,MAAM;AAGlE,QAAI,WAAW,IAAI,IAAI,GAAG;AACxB,iBAAW,IAAI,IAAI,EAAE,aAAa;AAAA,IACpC;AAAA,EACF;AAAA;AAAA,EAGA,mBAAmB;AACjB,QAAI,SAAS,KAAK,MAAM,kBAAkB,QAAQ;AAGhD,WAAK,iCAAiC,SAAS,KAAK,MAAM;AAC1D,eAAS,KAAK,MAAM,gBAAgB;AAAA,IACtC;AAGA,wBAAoB,EAAE,QAAQ,CAAC,OAAO;AACpC,UAAI,OAAO,MAAM;AACf,WAAG,EAAE,QAAQ,MAAM,gBAAgB;AAAA,MACrC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,kBAAkB;AAChB,QAAI,KAAK,mCAAmC,QAAW;AAErD,eAAS,KAAK,MAAM,gBAAgB,KAAK;AACzC,aAAO,KAAK;AAAA,IACd;AAGA,UAAM,YAAY,oBAAoB;AAEtC,QAAI;AAEJ,WAAQ,KAAK,UAAU,IAAI,GAAI;AAC7B,UAAI,OAAO,MAAM;AAEf;AAAA,MACF;AACA,SAAG,EAAE,QAAQ,MAAM,eAAe,gBAAgB;AAClD,UAAI,CAAC,GAAG,UAAU;AAEhB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
