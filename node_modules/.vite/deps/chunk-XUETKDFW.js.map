{
  "version": 3,
  "sources": ["../../@vaadin/grid/src/vaadin-grid-selection-column-base-mixin.js"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2016 - 2025 Vaadin Ltd.\r\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\r\n */\r\nimport { addListener } from '@vaadin/component-base/src/gestures.js';\r\n\r\n/**\r\n * A mixin that provides basic functionality for the\r\n * `<vaadin-grid-selection-column>`. This includes properties, cell rendering,\r\n * and overridable methods for handling changes to the selection state.\r\n *\r\n * **NOTE**: This mixin is re-used by the Flow component, and as such must not\r\n * implement any selection state updates for the column element or the grid.\r\n * Web component-specific selection state updates must be implemented in the\r\n * `<vaadin-grid-selection-column>` itself, by overriding the protected methods\r\n * provided by this mixin.\r\n *\r\n * @polymerMixin\r\n */\r\nexport const GridSelectionColumnBaseMixin = (superClass) =>\r\n  class GridSelectionColumnBaseMixin extends superClass {\r\n    static get properties() {\r\n      return {\r\n        /**\r\n         * Width of the cells for this column.\r\n         */\r\n        width: {\r\n          type: String,\r\n          value: '58px',\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * Override `autoWidth` to enable auto-width\r\n         */\r\n        autoWidth: {\r\n          type: Boolean,\r\n          value: true,\r\n        },\r\n\r\n        /**\r\n         * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.\r\n         * @attr {number} flex-grow\r\n         * @type {number}\r\n         */\r\n        flexGrow: {\r\n          type: Number,\r\n          value: 0,\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * When true, all the items are selected.\r\n         * @attr {boolean} select-all\r\n         * @type {boolean}\r\n         */\r\n        selectAll: {\r\n          type: Boolean,\r\n          value: false,\r\n          notify: true,\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * When true, the active gets automatically selected.\r\n         * @attr {boolean} auto-select\r\n         * @type {boolean}\r\n         */\r\n        autoSelect: {\r\n          type: Boolean,\r\n          value: false,\r\n          sync: true,\r\n        },\r\n\r\n        /**\r\n         * When true, rows can be selected by dragging over the selection column.\r\n         * @attr {boolean} drag-select\r\n         * @type {boolean}\r\n         */\r\n        dragSelect: {\r\n          type: Boolean,\r\n          value: false,\r\n          sync: true,\r\n        },\r\n\r\n        /** @protected */\r\n        _indeterminate: {\r\n          type: Boolean,\r\n          sync: true,\r\n        },\r\n\r\n        /** @protected */\r\n        _selectAllHidden: Boolean,\r\n\r\n        /**\r\n         * Indicates whether the shift key is currently pressed.\r\n         *\r\n         * @protected\r\n         */\r\n        _shiftKeyDown: {\r\n          type: Boolean,\r\n          value: false,\r\n        },\r\n      };\r\n    }\r\n\r\n    static get observers() {\r\n      return [\r\n        '_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, selectAll, _indeterminate, _selectAllHidden)',\r\n      ];\r\n    }\r\n\r\n    constructor() {\r\n      super();\r\n      this.__onCellTrack = this.__onCellTrack.bind(this);\r\n      this.__onCellClick = this.__onCellClick.bind(this);\r\n      this.__onCellMouseDown = this.__onCellMouseDown.bind(this);\r\n      this.__onGridInteraction = this.__onGridInteraction.bind(this);\r\n      this.__onActiveItemChanged = this.__onActiveItemChanged.bind(this);\r\n      this.__onSelectRowCheckboxChange = this.__onSelectRowCheckboxChange.bind(this);\r\n      this.__onSelectAllCheckboxChange = this.__onSelectAllCheckboxChange.bind(this);\r\n    }\r\n\r\n    /** @protected */\r\n    connectedCallback() {\r\n      super.connectedCallback();\r\n      if (this._grid) {\r\n        this._grid.addEventListener('keyup', this.__onGridInteraction);\r\n        this._grid.addEventListener('keydown', this.__onGridInteraction, { capture: true });\r\n        this._grid.addEventListener('mousedown', this.__onGridInteraction);\r\n        this._grid.addEventListener('active-item-changed', this.__onActiveItemChanged);\r\n      }\r\n    }\r\n\r\n    /** @protected */\r\n    disconnectedCallback() {\r\n      super.disconnectedCallback();\r\n      if (this._grid) {\r\n        this._grid.removeEventListener('keyup', this.__onGridInteraction);\r\n        this._grid.removeEventListener('keydown', this.__onGridInteraction, { capture: true });\r\n        this._grid.removeEventListener('mousedown', this.__onGridInteraction);\r\n        this._grid.removeEventListener('active-item-changed', this.__onActiveItemChanged);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Renders the Select All checkbox to the header cell.\r\n     *\r\n     * @override\r\n     */\r\n    _defaultHeaderRenderer(root, _column) {\r\n      let checkbox = root.firstElementChild;\r\n      if (!checkbox) {\r\n        checkbox = document.createElement('vaadin-checkbox');\r\n        checkbox.setAttribute('aria-label', 'Select All');\r\n        checkbox.classList.add('vaadin-grid-select-all-checkbox');\r\n        checkbox.addEventListener('change', this.__onSelectAllCheckboxChange);\r\n        root.appendChild(checkbox);\r\n      }\r\n\r\n      const checked = this.__isChecked(this.selectAll, this._indeterminate);\r\n      checkbox.checked = checked;\r\n      checkbox.hidden = this._selectAllHidden;\r\n      checkbox.indeterminate = this._indeterminate;\r\n    }\r\n\r\n    /**\r\n     * Renders the Select Row checkbox to the body cell.\r\n     *\r\n     * @override\r\n     */\r\n    _defaultRenderer(root, _column, { item, selected }) {\r\n      let checkbox = root.firstElementChild;\r\n      if (!checkbox) {\r\n        checkbox = document.createElement('vaadin-checkbox');\r\n        checkbox.setAttribute('aria-label', 'Select Row');\r\n        checkbox.addEventListener('change', this.__onSelectRowCheckboxChange);\r\n        root.appendChild(checkbox);\r\n        addListener(root, 'track', this.__onCellTrack);\r\n        root.addEventListener('mousedown', this.__onCellMouseDown);\r\n        root.addEventListener('click', this.__onCellClick);\r\n      }\r\n\r\n      checkbox.__item = item;\r\n      checkbox.checked = selected;\r\n\r\n      const isSelectable = this._grid.__isItemSelectable(item);\r\n      checkbox.readonly = !isSelectable;\r\n      checkbox.hidden = !isSelectable && !selected;\r\n    }\r\n\r\n    /**\r\n     * Updates the select all state when the Select All checkbox is switched.\r\n     * The listener handles only user-fired events.\r\n     *\r\n     * @private\r\n     */\r\n    __onSelectAllCheckboxChange(e) {\r\n      if (this._indeterminate || e.currentTarget.checked) {\r\n        this._selectAll();\r\n      } else {\r\n        this._deselectAll();\r\n      }\r\n    }\r\n\r\n    /** @private */\r\n    __onGridInteraction(e) {\r\n      this._shiftKeyDown = e.shiftKey;\r\n\r\n      if (this.autoSelect) {\r\n        // Prevent text selection when shift-clicking to select a range of items.\r\n        this._grid.$.scroller.toggleAttribute('range-selecting', this._shiftKeyDown);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Selects or deselects the row when the Select Row checkbox is switched.\r\n     * The listener handles only user-fired events.\r\n     *\r\n     * @private\r\n     */\r\n    __onSelectRowCheckboxChange(e) {\r\n      this.__toggleItem(e.currentTarget.__item, e.currentTarget.checked);\r\n    }\r\n\r\n    /** @private */\r\n    __onCellTrack(event) {\r\n      if (!this.dragSelect) {\r\n        return;\r\n      }\r\n      this.__dragCurrentY = event.detail.y;\r\n      this.__dragDy = event.detail.dy;\r\n      if (event.detail.state === 'start') {\r\n        const renderedRows = this._grid._getRenderedRows();\r\n        // Get the row where the drag started\r\n        const dragStartRow = renderedRows.find((row) => row.contains(event.currentTarget.assignedSlot));\r\n        // Whether to select or deselect the items on drag\r\n        this.__selectOnDrag = !this._grid._isSelected(dragStartRow._item);\r\n        // Store the index of the row where the drag started\r\n        this.__dragStartIndex = dragStartRow.index;\r\n        // Store the item of the row where the drag started\r\n        this.__dragStartItem = dragStartRow._item;\r\n        // Start the auto scroller\r\n        this.__dragAutoScroller();\r\n      } else if (event.detail.state === 'end') {\r\n        // if drag start and end stays within the same item, then toggle its state\r\n        if (this.__dragStartItem) {\r\n          this.__toggleItem(this.__dragStartItem, this.__selectOnDrag);\r\n        }\r\n        // clear drag state after timeout, which allows preventing the\r\n        // subsequent click event if drag started and ended on the same item\r\n        setTimeout(() => {\r\n          this.__dragStartIndex = undefined;\r\n        });\r\n      }\r\n    }\r\n\r\n    /** @private */\r\n    __onCellMouseDown(e) {\r\n      if (this.dragSelect) {\r\n        // Prevent text selection when starting to drag\r\n        e.preventDefault();\r\n      }\r\n    }\r\n\r\n    /** @private */\r\n    __onCellClick(e) {\r\n      if (this.__dragStartIndex !== undefined) {\r\n        // Stop the click event if drag was enabled. This click event should\r\n        // only occur if drag started and stopped on the same item. In that case\r\n        // the selection state has already been toggled on drag end, and we\r\n        // don't  want to toggle it again from clicking the checkbox or changing\r\n        // the active item.\r\n        e.preventDefault();\r\n      }\r\n    }\r\n\r\n    /** @private */\r\n    _onCellKeyDown(e) {\r\n      const target = e.composedPath()[0];\r\n      // Toggle on Space without having to enter interaction mode first\r\n      if (e.keyCode !== 32) {\r\n        return;\r\n      }\r\n      if (target === this._headerCell) {\r\n        if (this.selectAll) {\r\n          this._deselectAll();\r\n        } else {\r\n          this._selectAll();\r\n        }\r\n      } else if (this._cells.includes(target) && !this.autoSelect) {\r\n        const checkbox = target._content.firstElementChild;\r\n        this.__toggleItem(checkbox.__item);\r\n      }\r\n    }\r\n\r\n    /** @private */\r\n    __onActiveItemChanged(e) {\r\n      const activeItem = e.detail.value;\r\n      if (this.autoSelect) {\r\n        const item = activeItem || this.__previousActiveItem;\r\n        if (item) {\r\n          this.__toggleItem(item);\r\n        }\r\n      }\r\n      this.__previousActiveItem = activeItem;\r\n    }\r\n\r\n    /** @private */\r\n    __dragAutoScroller() {\r\n      if (this.__dragStartIndex === undefined) {\r\n        return;\r\n      }\r\n\r\n      // Get the row being hovered over\r\n      const renderedRows = this._grid._getRenderedRows();\r\n      const hoveredRow = renderedRows.find((row) => {\r\n        const rowRect = row.getBoundingClientRect();\r\n        return this.__dragCurrentY >= rowRect.top && this.__dragCurrentY <= rowRect.bottom;\r\n      });\r\n\r\n      // Get the index of the row being hovered over or the first/last\r\n      // visible row if hovering outside the grid\r\n      let hoveredIndex = hoveredRow ? hoveredRow.index : undefined;\r\n      const scrollableArea = this.__getScrollableArea();\r\n      if (this.__dragCurrentY < scrollableArea.top) {\r\n        hoveredIndex = this._grid._firstVisibleIndex;\r\n      } else if (this.__dragCurrentY > scrollableArea.bottom) {\r\n        hoveredIndex = this._grid._lastVisibleIndex;\r\n      }\r\n\r\n      if (hoveredIndex !== undefined) {\r\n        // Select all items between the start and the current row\r\n        renderedRows.forEach((row) => {\r\n          if (\r\n            (hoveredIndex > this.__dragStartIndex && row.index >= this.__dragStartIndex && row.index <= hoveredIndex) ||\r\n            (hoveredIndex < this.__dragStartIndex && row.index <= this.__dragStartIndex && row.index >= hoveredIndex)\r\n          ) {\r\n            this.__toggleItem(row._item, this.__selectOnDrag);\r\n            this.__dragStartItem = undefined;\r\n          }\r\n        });\r\n      }\r\n\r\n      // Start scrolling in the top/bottom 15% of the scrollable area\r\n      const scrollTriggerArea = scrollableArea.height * 0.15;\r\n      // Maximum number of pixels to scroll per iteration\r\n      const maxScrollAmount = 10;\r\n\r\n      if (this.__dragDy < 0 && this.__dragCurrentY < scrollableArea.top + scrollTriggerArea) {\r\n        const dy = scrollableArea.top + scrollTriggerArea - this.__dragCurrentY;\r\n        const percentage = Math.min(1, dy / scrollTriggerArea);\r\n        this._grid.$.table.scrollTop -= percentage * maxScrollAmount;\r\n      }\r\n      if (this.__dragDy > 0 && this.__dragCurrentY > scrollableArea.bottom - scrollTriggerArea) {\r\n        const dy = this.__dragCurrentY - (scrollableArea.bottom - scrollTriggerArea);\r\n        const percentage = Math.min(1, dy / scrollTriggerArea);\r\n        this._grid.$.table.scrollTop += percentage * maxScrollAmount;\r\n      }\r\n\r\n      // Schedule the next auto scroll\r\n      setTimeout(() => this.__dragAutoScroller(), 10);\r\n    }\r\n\r\n    /**\r\n     * Gets the scrollable area of the grid as a bounding client rect. The\r\n     * scrollable area is the bounding rect of the grid minus the header and\r\n     * footer.\r\n     *\r\n     * @private\r\n     */\r\n    __getScrollableArea() {\r\n      const gridRect = this._grid.$.table.getBoundingClientRect();\r\n      const headerRect = this._grid.$.header.getBoundingClientRect();\r\n      const footerRect = this._grid.$.footer.getBoundingClientRect();\r\n\r\n      return {\r\n        top: gridRect.top + headerRect.height,\r\n        bottom: gridRect.bottom - footerRect.height,\r\n        left: gridRect.left,\r\n        right: gridRect.right,\r\n        height: gridRect.height - headerRect.height - footerRect.height,\r\n        width: gridRect.width,\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Override to handle the user selecting all items.\r\n     * @protected\r\n     */\r\n    _selectAll() {}\r\n\r\n    /**\r\n     * Override to handle the user deselecting all items.\r\n     * @protected\r\n     */\r\n    _deselectAll() {}\r\n\r\n    /**\r\n     * Override to handle the user selecting an item.\r\n     * @param {Object} item the item to select\r\n     * @protected\r\n     */\r\n    _selectItem(_item) {}\r\n\r\n    /**\r\n     * Override to handle the user deselecting an item.\r\n     * @param {Object} item the item to deselect\r\n     * @protected\r\n     */\r\n    _deselectItem(_item) {}\r\n\r\n    /**\r\n     * Toggles the selected state of the given item.\r\n     *\r\n     * @param item the item to toggle\r\n     * @param {boolean} [selected] whether to select or deselect the item\r\n     * @private\r\n     */\r\n    __toggleItem(item, selected = !this._grid._isSelected(item)) {\r\n      if (selected === this._grid._isSelected(item)) {\r\n        // Skip selection if the item is already in the desired state.\r\n        // Note, _selectItem and _deselectItem may be overridden in custom\r\n        // selection column implementations, and calling them unnecessarily\r\n        // might affect performance (e.g. vaadin-grid-flow-selection-column).\r\n        return;\r\n      }\r\n\r\n      if (selected) {\r\n        this._selectItem(item);\r\n      } else {\r\n        this._deselectItem(item);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * IOS needs indeterminate + checked at the same time\r\n     * @private\r\n     */\r\n    __isChecked(selectAll, indeterminate) {\r\n      return indeterminate || selectAll;\r\n    }\r\n  };\r\n"],
  "mappings": "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",
  "names": []
}
